{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Younix","url":"http://iyounix.com"},"pages":[{"title":"404","date":"2018-11-07T04:40:28.000Z","updated":"2018-11-08T01:30:40.287Z","comments":true,"path":"404.html","permalink":"http://iyounix.com/404.html","excerpt":"","text":""},{"title":"沧海一粟","date":"2018-11-07T02:40:28.000Z","updated":"2018-11-08T01:30:40.291Z","comments":true,"path":"about/index.html","permalink":"http://iyounix.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux device 操作接口","slug":"Linux/Linux device 操作接口","date":"2018-11-09T13:00:00.000Z","updated":"2018-11-09T07:20:33.367Z","comments":true,"path":"2018/11/09/Linux/Linux device 操作接口/","link":"","permalink":"http://iyounix.com/2018/11/09/Linux/Linux device 操作接口/","excerpt":"","text":"device 操作 API将新的 device 注册到设备模型device_create-&gt;device_create_vargs-&gt;device_register-&gt;device_add12345678struct device *device_create(struct class *class, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...)&#123; ...... dev = device_create_vargs(class, parent, devt, drvdata, fmt, vargs); ...... return dev;&#125; 123456789101112131415struct device *device_create_vargs(struct class *class, struct device *parent, dev_t devt, void *drvdata, const char *fmt, va_list args)&#123; ...... dev-&gt;devt = devt; dev-&gt;class = class; dev-&gt;parent = parent; dev-&gt;release = device_create_release; dev_set_drvdata(dev, drvdata); ...... retval = device_register(dev); ......&#125; 1234int device_register(struct device *dev) &#123; device_initialize(dev); // 调用初始化 device 结构 return device_add(dev); // 真正将 device 对象 dev 插入设备模型中&#125; device_initialize() 初始化嵌入的 kobject 结构 dev-&gt;kobj, 初始化列表中的孩子列表 kobj-&gt;klist_children，初始化 DMA 冲池 dev-&gt;dma_pools, 初始化自旋锁 dev-&gt;devres_lock等device_add()首先是通过kboject_add()函数将它添加到kobject层次，再把它添加都全局和兄弟链表中，最后添加到其他相关的子系统的驱动程序模型，完成device对象的注册。 从设备模型销毁 devicedevice_destroy() 用于从linux内核系统设备驱动程序模型中移除一个设备，并删除/sys/devices/virtual目录下对应的设备目录及/dev/目录下对应的设备文件1void device_destroy(struct class *dev, dev_t devt); 补充 device create register add 区别可以参考这篇文章 : https://blog.csdn.net/zifehng/article/details/73844845 补充 class_create 和 device_create 区别条件: 如果用户空间支持 udev可以利用内核为我们提供的一组 API , 实现在模块加载的时候自动在 /dev 目录下创建相应设备节点，并在卸载模块时删除该节点.内核中定义了struct class结构体，其实例化的对象对应一个类，内核同时提供了class_create(…)函数，可以用它来创建一个类，这个类存放于sysfs下面，一旦创建好了这个类，再调用device_create(…)函数来在/dev目录下创建相应的设备节点。这样，加载模块的时候，用户空间中的udev会自动响应device_create(…)函数，去/sysfs下寻找对应的类从而创建设备节点。 SOP 如下: mem_class = class_create(THIS_MODULE,&quot;younix_class_char&quot;);建立逻辑设备类, 在 /sys/class/ 下建立了 younix_class_char 目录 device_create(mem_class,NULL,MKDEV(MEM_MAJOR,MEM_MINOR),NULL,&quot;younix_class_char&quot;);建立设备节点, 在 /dev/ 下自动建立 younix_class_char 建立设备节点 Demo 可以参考 : https://blog.csdn.net/tq384998430/article/details/54342044 中 字符设备驱动程序 的 Demo struct device123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** * struct device - The basic device structure * @parent: The device&apos;s &quot;parent&quot; device, the device to which it is attached. * In most cases, a parent device is some sort of bus or host * controller. If parent is NULL, the device, is a top-level device, * which is not usually what you want. * @p: Holds the private data of the driver core portions of the device. * See the comment of the struct device_private for detail. * @kobj: A top-level, abstract class from which other classes are derived. * @init_name: Initial name of the device. * @type: The type of device. * This identifies the device type and carries type-specific * information. * @mutex: Mutex to synchronize calls to its driver. * @bus: Type of bus device is on. * @driver: Which driver has allocated this * @platform_data: Platform data specific to the device. * Example: For devices on custom boards, as typical of embedded * and SOC based hardware, Linux often uses platform_data to point * to board-specific structures describing devices and how they * are wired. That can include what ports are available, chip * variants, which GPIO pins act in what additional roles, and so * on. This shrinks the &quot;Board Support Packages&quot; (BSPs) and * minimizes board-specific #ifdefs in drivers. * @driver_data: Private pointer for driver specific info. * @power: For device power management. * See Documentation/power/devices.txt for details. * @pm_domain: Provide callbacks that are executed during system suspend, * hibernation, system resume and during runtime PM transitions * along with subsystem-level and driver-level callbacks. * @pins: For device pin management. * See Documentation/pinctrl.txt for details. * @numa_node: NUMA node this device is close to. * @dma_mask: Dma mask (if dma&apos;ble device). * @coherent_dma_mask: Like dma_mask, but for alloc_coherent mapping as not all * hardware supports 64-bit addresses for consistent allocations * such descriptors. * @dma_pfn_offset: offset of DMA memory range relatively of RAM * @dma_parms: A low level driver may set these to teach IOMMU code about * segment limitations. * @dma_pools: Dma pools (if dma&apos;ble device). * @dma_mem: Internal for coherent mem override. * @cma_area: Contiguous memory area for dma allocations * @archdata: For arch-specific additions. * @of_node: Associated device tree node. * @acpi_node: Associated ACPI device node. * @devt: For creating the sysfs &quot;dev&quot;. * @id: device instance * @devres_lock: Spinlock to protect the resource of the device. * @devres_head: The resources list of the device. * @knode_class: The node used to add the device to the class list. * @class: The class of the device. * @groups: Optional attribute groups. * @release: Callback to free the device after all references have * gone away. This should be set by the allocator of the * device (i.e. the bus driver that discovered the device). * @iommu_group: IOMMU group the device belongs to. * * @offline_disabled: If set, the device is permanently online. * @offline: Set after successful invocation of bus type&apos;s .offline(). * * At the lowest level, every device in a Linux system is represented by an * instance of struct device. The device structure contains the information * that the device model core needs to model the system. Most subsystems, * however, track additional information about the devices they host. As a * result, it is rare for devices to be represented by bare device structures; * instead, that structure, like kobject structures, is usually embedded within * a higher-level representation of the device. */struct device &#123; struct device *parent; //指向父设备 struct device_private *p; struct kobject kobj; //内嵌的 kobj 对象 const char *init_name; /* initial name of the device */ const struct device_type *type; struct mutex mutex; /* mutex to synchronize calls to * its driver. */ struct bus_type *bus; /* type of bus device is on */ struct device_driver *driver; /* which driver has allocated this device */ void *platform_data; /* Platform specific data, device core doesn&apos;t touch it */ void *driver_data; /* Driver data, set and get with dev_set/get_drvdata */ struct dev_pm_info power; struct dev_pm_domain *pm_domain; u64 *dma_mask; /* dma mask (if dma&apos;able device) */ u64 coherent_dma_mask;/* Like dma_mask, but for alloc_coherent mappings as not all hardware supports 64 bit addresses for consistent allocations such descriptors. */ unsigned long dma_pfn_offset; struct device_dma_parameters *dma_parms; struct list_head dma_pools; /* dma pools (if dma&apos;ble) */ struct dma_coherent_mem *dma_mem; /* internal for coherent mem override */ /* arch specific additions */ struct dev_archdata archdata; struct device_node *of_node; /* associated device tree node */ struct acpi_dev_node acpi_node; /* associated ACPI device node */ dev_t devt; /* dev_t, creates the sysfs &quot;dev&quot; */ u32 id; /* device instance */ spinlock_t devres_lock; struct list_head devres_head; struct klist_node knode_class; struct class *class; const struct attribute_group **groups; /* optional groups */ void (*release)(struct device *dev); struct iommu_group *iommu_group; bool offline_disabled:1; bool offline:1;&#125;; Demo以一个简单的led设备字符设备驱动为例 , 主要关注 创建设备节点 的实现 , 这里是以 device_create 进行创建12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static class *led_class;static int __init led_init(void)&#123; int ret; dev_t devno; struct cdev *cdev; struct dev *dev; /* 注册设备号 */ ret = alloc_chrdev_region(&amp;devno, 0, 1, &quot;led&quot;); if (ret &lt; 0) return ret; /* 分配、初始化、注册cdev*/ cdev = cdev_alloc(); if (IS_ERR(cdev)) &#123; ret = PTR_ERR(cdev); goto out_unregister_devno; &#125; cdev_init(&amp;cdev, &amp;led_fops); cdev.owner = THIS_MODULE; ret = cdev_add(&amp;cdev, devno, 1); if (ret) goto out_free_cdev; /* 创建设备类 */ led_class = class_create(THIS_MODULE, &quot;led_class&quot;); if (IS_ERR(led_class)) &#123; ret = PTR_ERR(led_class); goto out_unregister_cdev; &#125; /* 创建设备节点 */ dev = device_create(led_class, NULL, devno, NULL, &quot;led&quot;); if (IS_ERR(dev)) &#123; ret = PTR_ERR(dev); goto out_del_class; &#125; return 0;out_del_class: class_destroy(c78x_class); out_unregister_cdev: cdev_del(cdev);out_free_cdev: kfree(cdev);out_unregister_devno: unregister_chrdev_region(devno, 1); return ret;&#125;module_init(led_init); 如果使用 device_register 进行创建, 对应 创建设备节点部分应该修改为:1234567891011121314151617181920212223/* 创建设备节点 */ dev = kzalloc(sizeof(*dev), GFP_KERNEL); if (!dev) &#123; ret = -ENOMEM; goto out_del_class; &#125; dev-&gt;class = led_class; // 关联设备类 dev-&gt;parent = NULL; dev-&gt;devt = devno; // 关联设备号 dev_set_drvdata(dev, NULL); dev_set_name(dev, &quot;led&quot;); // 设置节点名字 dev-&gt;release = device_create_release; ret = device_register(dev); if (ret) goto out_put_dev; return 0;out_put_dev: put_device(dev); kree(dev); 如果是使用 device_add() 进行创建, 进行如下修改:123456789101112131415161718192021222324/* 创建设备节点 */ dev = kzalloc(sizeof(*dev), GFP_KERNEL); if (!dev) &#123; ret = -ENOMEM; goto out_del_class; &#125; dev-&gt;class = led_class; // 关联设备类 dev-&gt;parent = NULL; dev-&gt;devt = devno; // 关联设备号 dev_set_drvdata(dev, NULL); dev_set_name(dev, &quot;led&quot;); // 设置节点名字 dev-&gt;release = device_create_release; device_initialize(dev); // 多了这一步 ret = device_add(dev); if (ret) goto out_put_dev; return 0;out_put_dev: put_device(dev); kree(dev);","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"Linux 链表操作接口","slug":"Linux/Linux 链表操作接口","date":"2018-11-09T13:00:00.000Z","updated":"2018-11-09T07:20:33.367Z","comments":true,"path":"2018/11/09/Linux/Linux 链表操作接口/","link":"","permalink":"http://iyounix.com/2018/11/09/Linux/Linux 链表操作接口/","excerpt":"","text":"[TOC] 前提是假设大家有链表的基础https://www.ibm.com/developerworks/cn/linux/kernel/l-chain/index.html 声明和初始化Linux 只定义了链表的节点, 没有专门定义链表头.链表结构是这样建立的 声明时初始化链表 LIST_HEAD_INIT12#define LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;#define LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name) LIST_HEAD_INIT(name)声明一个名为 name 的链表头时，它的next、prev指针都初始化为指向自己 , 这样，我们就有了一个空链表.(Linux用头指针的next是否指向自己来判断链表是否为空)1234static inline int list_empty(const struct list_head *head)&#123; return head-&gt;next == head;&#125; 运行时初始化链表 INIT_LIST_HEAD123#define INIT_LIST_HEAD(ptr) do &#123; \\ (ptr)-&gt;next = (ptr); (ptr)-&gt;prev = (ptr); \\&#125; while (0) 插入 删除 搬移 合并插入对链表的插入操作有两种：在表头插入和在表尾插入。Linux为此提供了两个接口：12static inline void list_add(struct list_head *new, struct list_head *head);static inline void list_add_tail(struct list_head *new, struct list_head *head); 因为Linux链表是循环表，且表头的next、prev分别指向链表中的第一个和最末一个节点，所以，list_add和list_add_tail的区别并不大，实际上，Linux分别用12__list_add(new, head, head-&gt;next);__list_add(new, head-&gt;prev, head); 来实现两个接口，可见，在表头插入是插入在head之后，而在表尾插入是插入在head-&gt;prev之后。假设有一个新nf_sockopt_ops结构变量new_sockopt需要添加到nf_sockopts链表头，我们应当这样操作：1list_add(&amp;new_sockopt.list, &amp;nf_sockopts); 从这里我们看出，nf_sockopts链表中记录的并不是new_sockopt的地址，而是其中的list元素的地址。如何通过链表访问到new_sockopt呢？下面会有详细介绍。 删除1static inline void list_del(struct list_head *entry); 当我们需要删除nf_sockopts链表中添加的new_sockopt项时，我们这么操作：1list_del(&amp;new_sockopt.list); 被剔除下来的new_sockopt.list，prev、next指针分别被设为LIST_POSITION2和LIST_POSITION1两个特殊值，这样设置是为了保证不在链表中的节点项不可访问–对LIST_POSITION1和LIST_POSITION2的访问都将引起页故障。与之相对应，list_del_init()函数将节点从链表中解下来之后，调用LIST_INIT_HEAD()将节点置为空链状态。 搬移Linux提供了将原本属于一个链表的节点移动到另一个链表的操作，并根据插入到新链表的位置分为两类：12static inline void list_move(struct list_head *list, struct list_head *head);static inline void list_move_tail(struct list_head *list, struct list_head *head); 例如list_move(&amp;new_sockopt.list,&amp;nf_sockopts)会把new_sockopt从它所在的链表上删除，并将其再链入nf_sockopts的表头。 合并除了针对节点的插入、删除操作，Linux链表还提供了整个链表的插入功能：1static inline void list_splice(struct list_head *list, struct list_head *head); 假设当前有两个链表，表头分别是list1和list2（都是struct list_head变量），当调用list_splice(&amp;list1,&amp;list2)时，只要list1非空，list1链表的内容将被挂接在list2链表上，位于list2和list2.next（原list2表的第一个节点）之间。新list2链表将以原list1表的第一个节点为首节点，而尾节点不变。如图（虚箭头为next指针）： 图4 链表合并list_splice(&amp;list1,&amp;list2)当list1被挂接到list2之后，作为原表头指针的list1的next、prev仍然指向原来的节点，为了避免引起混乱，Linux提供了一个list_splice_init()函数：1static inline void list_splice_init(struct list_head *list, struct list_head *head); 该函数在将list合并到head链表的基础上，调用INIT_LIST_HEAD(list)将list设置为空链。 遍历由链表节点到数据项变量我们知道，Linux链表中仅保存了数据项结构中list_head成员变量的地址，那么我们如何通过这个list_head成员访问到作为它的所有者的节点数据呢？Linux为此提供了一个list_entry(ptr,type,member)宏，ptr是指向该数据中list_head成员的指针，也就是存储在链表中的地址值，type是数据项的类型，member则是数据项类型定义中list_head成员的变量名，例如，我们要访问nf_sockopts链表中首个nf_sockopt_ops变量，则如此调用：1list_entry(nf_sockopts-&gt;next, struct nf_sockopt_ops, list); 这里”list”正是nf_sockopt_ops结构中定义的用于链表操作的节点成员变量名。 list_entry的使用相当简单，相比之下，它的实现则有一些难懂：1#define list_entry(ptr, type, member) container_of(ptr, type, member) container_of宏定义在[include/linux/kernel.h]中：123#define container_of(ptr, type, member) (&#123; \\ const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \\ (type *)( (char *)__mptr - offsetof(type,member) );&#125;) offsetof宏定义在[include/linux/stddef.h]中：1#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER) size_t最终定义为unsigned int（i386）。 这里container_of使用的是一个利用编译器技术的小技巧，即先求得结构成员在与结构中的偏移量，然后根据成员变量的地址反过来得出属主结构变量的地址。 container_of()和offsetof()并不仅用于链表操作，这里最有趣的地方是((type *)0)-&gt;member，它将0地址强制”转换”为type结构的指针，再访问到type结构中的member成员。在container_of宏中，它用来给typeof()提供参数（typeof()是gcc的扩展，和sizeof()类似），以获得member成员的数据类型；在offsetof()中，这个member成员的地址实际上就是type数据结构中member成员相对于结构变量的偏移量。 如果这么说还不好理解的话，不妨看看下面这张图：图5 offsetof()宏的原理对于给定一个结构，offsetof(type,member)是一个常量，list_entry()正是利用这个不变的偏移量来求得链表数据项的变量地址。 遍历宏 list_for_each_entry()list_for_each_entry = list_for_each() + list_entry() 在[net/core/netfilter.c]的nf_register_sockopt()函数中有这么一段话：12345678……struct list_head *i;…… list_for_each(i, &amp;nf_sockopts) &#123; struct nf_sockopt_ops *ops = (struct nf_sockopt_ops *)i; …… &#125;…… 函数首先定义一个(struct list_head *)指针变量i，然后调用list_for_each(i,&amp;nf_sockopts)进行遍历。在[include/linux/list.h]中，list_for_each()宏是这么定义的：123#define list_for_each(pos, head) \\for (pos = (head)-&gt;next, prefetch(pos-&gt;next); pos != (head); \\ pos = pos-&gt;next, prefetch(pos-&gt;next)) 它实际上是一个for循环，利用传入的pos作为循环变量，从表头head开始，逐项向后（next方向）移动pos，直至又回到head（prefetch()可以不考虑，用于预取以提高遍历速度）。 那么在nf_register_sockopt()中实际上就是遍历nf_sockopts链表。为什么能直接将获得的list_head成员变量地址当成struct nf_sockopt_ops数据项变量的地址呢？我们注意到在struct nf_sockopt_ops结构中，list是其中的第一项成员，因此，它的地址也就是结构变量的地址。更规范的获得数据变量地址的用法应该是：1struct nf_sockopt_ops *ops = list_entry(i, struct nf_sockopt_ops, list); 大多数情况下，遍历链表的时候都需要获得链表节点数据项，也就是说list_for_each()和list_entry()总是同时使用。 对此Linux给出了一个list_for_each_entry()宏：1#define list_for_each_entry(pos, head, member) …… 与list_for_each()不同，这里的pos是数据项结构指针类型，而不是(struct list_head *)。nf_register_sockopt()函数可以利用这个宏而设计得更简单：123456……struct nf_sockopt_ops *ops;list_for_each_entry(ops,&amp;nf_sockopts,list)&#123; ……&#125;…… 某些应用需要反向遍历链表，Linux提供了list_for_each_prev()和list_for_each_entry_reverse()来完成这一操作，使用方法和上面介绍的list_for_each()、list_for_each_entry()完全相同。 如果遍历不是从链表头开始，而是从已知的某个节点pos开始，则可以使用list_for_each_entry_continue(pos,head,member)。有时还会出现这种需求，即经过一系列计算后，如果pos有值，则从pos开始遍历，如果没有，则从链表头开始，为此，Linux专门提供了一个list_prepare_entry(pos,head,member)宏，将它的返回值作为list_for_each_entry_continue()的pos参数，就可以满足这一要求。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"Linux Input 子系统分析","slug":"Linux/Linux Input 子系统分析","date":"2018-11-08T13:00:00.000Z","updated":"2018-11-09T07:20:33.367Z","comments":true,"path":"2018/11/08/Linux/Linux Input 子系统分析/","link":"","permalink":"http://iyounix.com/2018/11/08/Linux/Linux Input 子系统分析/","excerpt":"","text":"[TOC] 框架结构Input 子系统从上到下分为三层实现, 分别为 事件处理层 EventHandler / 核心层 InputCore / 驱动层 Driver Driver 层: 硬件设备读写访问, 中断设置 , 将硬件产生的事件转换为核心层定义的规范提交给 EventHandler.InputCore 层: 为设备驱动层提供了规范和接口。设备驱动层只要关心如何驱动硬件并获得硬件数据（例如按下的按键数据），然后调用核心层提供的接口，核心层会自动把数据提交给事件处理层。EventHandler 层: 用户编程的接口（设备节点），并处理驱动层提交的数据处理。 驱动层流程驱动开发的工作: 设置 input 设备支持的事件类型 (EV_SYN / EV_KEY 等) 注册中断处理函数 输入设备注册到输入子系统中 整体的流程是: 注册初始化, button_init 将被用于 insmod 或者 内核引导过程中 的调用主要负责硬件设备资源 ( 内存 / IO内存 / 中断 / DMA ) 的获取. 1module_init(button_init) 在 button_init 中获取中断, 注册中断当有键被按下 / 松开时 , 调用 button_interrupt 中断处理函数获取按键值 BUTTON_PORT 1request_irq(BUTTON_IRQ, button_interrupt, 0, &quot;button&quot;, NULL) 在 button_interrupt 中完成按键事件的上报需要两步: 1. input_report_key 2.input_sync .这里因为只有一个按键事件, 所以体现不出 input_sync 的作用.但是如果是 TP 事件, 在上报了 x y 坐标后, 需要 input_sync 将 x 和 y 完整地传给 input 子系统.123456static irqreturn_t button_interrupt(int irq, void *dummy)&#123; input_report_key(button_dev, BTN_0, inb(BUTTON_PORT) &amp; 1); input_sync(button_dev); return IRQ_HANDLED;&#125; 注册input设备由 InputCore (input.c) 中的 API 分配一个输入设备 12static struct input_dev *button_dev;button_dev=input_allocate_device(); 设置事件产生时候的事件类型evbit 事件产生时的事件类型(EV_KEY)keybit事件上报的按键值 12button_dev-&gt;evbit[0]= BIT(EV_KEY);button_dev-&gt;keybit[LONG(BTN_0)]= BIT(BTN_0); //#defineLONG(x) ((x)/BITS_PER_LONG) //返回位x的索引 注册为输入设备 1input_register_device(button_dev); DemoDemo 是只有一个按键的设备. 当按压或者释放按键的时候, 会发出 BUTTON_IRQ 中断.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;linux/input.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/init.h&gt;#include &lt;asm/irq.h&gt;#include &lt;asm/io.h&gt;static struct input_dev *button_dev;static irqreturn_t button_interrupt(int irq, void *dummy)&#123; input_report_key(button_dev, BTN_0, inb(BUTTON_PORT) &amp; 1); input_sync(button_dev); return IRQ_HANDLED;&#125;static int __init button_init(void)&#123; int error; //注册中断 if (request_irq(BUTTON_IRQ, button_interrupt, 0, &quot;button&quot;, NULL)) &#123; printk(KERN_ERR &quot;button.c: Can&apos;t allocate irq %d\\n&quot;, button_irq); return -EBUSY; &#125; // button_dev = input_allocate_device(); if (!button_dev) &#123; printk(KERN_ERR &quot;button.c: Not enough memory\\n&quot;); error = -ENOMEM; goto err_free_irq; &#125; button_dev-&gt;evbit[0] = BIT_MASK(EV_KEY); button_dev-&gt;keybit[BIT_WORD(BTN_0)] = BIT_MASK(BTN_0); //注册input设备 error = input_register_device(button_dev); if (error) &#123; printk(KERN_ERR &quot;button.c: Failed to register device\\n&quot;); goto err_free_dev; &#125; return 0; err_free_dev: input_free_device(button_dev); err_free_irq: free_irq(BUTTON_IRQ, button_interrupt); return error;&#125;static void __exit button_exit(void)&#123; input_unregister_device(button_dev); free_irq(BUTTON_IRQ, button_interrupt);&#125;module_init(button_init);module_exit(button_exit); 深入分析Input Initial InputCore 初始化 InputHandler 初始化 InputDevice 初始化 Core 将 Handler 和 Device 进行关联1. InputCore 初始化123456789101112static int __init input_init(void)&#123; int err; //1. 在设备模型 /sys/class 目录注册设备类 err = class_register(&amp;input_class); //2. 在 /proc/bus/input 目录产生设备信息 err = input_proc_init(); //3. 字符设备驱动框架注册 input 子系统的接口操作集合 err = register_chrdev_region(MKDEV(INPUT_MAJOR, 0), INPUT_MAX_CHAR_DEVICES, &quot;input&quot;); ...&#125; 2. InputHandler 初始化拿 TP 的 event-handler 为例 (evdev.c)123456789101112131415161718192021static const struct input_device_id evdev_ids[] = &#123; //设备 ID &#123; .driver_info = 1 &#125;, /* Matches all devices */ &#123; &#125;, /* Terminating zero entry */&#125;;MODULE_DEVICE_TABLE(input, evdev_ids);static struct input_handler evdev_handler = &#123; .event = evdev_event, .events = evdev_events, // 消息处理接口 .connect = evdev_connect, // InputCore 匹配到 device 后调用本接口 , 后面会详细分析 .disconnect = evdev_disconnect, .legacy_minors = true, .minor = EVDEV_MINOR_BASE, //64 event-handler 处理的次设备号的起始点 .name = &quot;evdev&quot;, //handler 的名称 .id_table = evdev_ids,&#125;;static int __init evdev_init(void)&#123; // input-core 提供的接口, 供 input-handler 注册自己 return input_register_handler(&amp;evdev_handler);&#125; 12345input_register_handler INIT_LIST_HEAD list_add_tail//加入input_handler_list全局链表 //遍历input_dev_list全局设备链表,寻找该handler支持的设备 list_for_each_entry(dev, &amp;input_dev_list, node)input_attach_handler(dev, handler); evdev_connect 的调用流程, 关键是注册了 fops.1234567evdev_connect input_get_new_minor //获取 minor 号 device_initialize input_register_handle //注册新的 input handle cdev_init(&amp;evdev-&gt;cdev, &amp;evdev_fops); //很关键, 注册fops, fops我们在后面单独说 cdev_add device_add fops 如下, 包括了123456789101112131415static const struct file_operations evdev_fops = &#123; .owner = THIS_MODULE, .read = evdev_read, .write = evdev_write, .poll = evdev_poll, .open = evdev_open, .release = evdev_release, .unlocked_ioctl = evdev_ioctl,#ifdef CONFIG_COMPAT .compat_ioctl = evdev_ioctl_compat,#endif .fasync = evdev_fasync, .flush = evdev_flush, .llseek = no_llseek,&#125;; 3. InputDevice 初始化这里因设备而异. 比如拿汇顶的 TouchScreen IC GT911 来举例.123456tpd_driver_init tpd_get_dts_info tpd_driver_add(&amp;tpd_device_driver) &lt; 0) tpd_probe input_register_device tpd_driver_add(&amp;tpd_device_driver) &lt; 0)将 tpd_device_driver 添加到 tpd_driver_list 链表中, 关键是tpd_driver_list[i].tpd_local_init = tpd_drv-&gt;tpd_local_init;在 tp device 和 driver match 的时候, 会执行 tpd_probe , 通过 tpd_driver_list 中的 tpd_local_init 找到初始化过程中 device需要进行的动作 (初始化寄存器等) 4. InputCore 和 InputHander 关联匹配在 input_register_handler 和 input_register_device 最后都会使用 input_attach_handler 接口来匹配输入设备和对应的事件处理者。123456789static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)&#123; const struct input_device_id *id; int error; //匹配 handler 和 device 的 ID, event handler 默认处理所有事件类型的设备 id = input_match_device(handler, dev); //匹配成功后调用 handler 的 connect 接口 (evdev_connect) error = handler-&gt;connect(handler, dev, id);&#125;","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"组件_Service.md","slug":"Android_App/组件_Service","date":"2018-11-08T03:20:49.990Z","updated":"2018-10-21T02:08:51.713Z","comments":true,"path":"2018/11/08/Android_App/组件_Service/","link":"","permalink":"http://iyounix.com/2018/11/08/Android_App/组件_Service/","excerpt":"","text":"基本概念Service 是 Android 中实现程序后台运行的解决方案,适合执行那些不需要和用户交互而且还要求长期运行的任务. 4个手动调用的方法startService() 启动服务, 手动调用 startService() 后，自动调用内部方法：onCreate()、onStartCommand().stopService() 关闭服务, 手动调用 stopService() 后，自动调用内部方法：onDestory(). 但是如果没有解绑, 是无法停止服务的bindService() 绑定服务, 手动调用 bindService()后，自动调用内部方法：onCreate()、onBind().unbindService() 解绑服务, 手动调用 unbindService()后，自动调用内部方法：onCreate()、onBind()、onDestory() 内部自动调用的方法onCreat() 创建服务onStartCommand() 开始服务onDestroy() 销毁服务onBind() 绑定服务onUnbind() 解绑服务 重要知识点startService()和 stopService()只能开启和关闭Service，无法操作Service；bindService()和 unbindService()可以操作 Service startService() 开启的Service，调用者退出后Service仍然存在；BindService() 开启的Service，调用者退出后，Service随着调用者销毁。 只使用 startService 启动服务的生命周期手动 startService()onCreate()onStartCommand()手动 stopService()onDestory() 只使用 bindService 绑定服务的生命周期手动 bindService()onCreate()onBind()手动 unBindService()onUnbind()onDestory() 同时使用 startService BindService 服务的生命周期手动 startService()onCreate()onStartCommand()手动 BindService()onBind()手动 unBindService()onUnbind()手动 StopService()onDestory()","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://iyounix.com/tags/android/"}]},{"title":"SOP_全局获取Context方法","slug":"Android_App/SOP_全局获取Context方法","date":"2018-08-11T03:12:05.000Z","updated":"2018-11-08T03:34:58.113Z","comments":true,"path":"2018/08/11/Android_App/SOP_全局获取Context方法/","link":"","permalink":"http://iyounix.com/2018/08/11/Android_App/SOP_全局获取Context方法/","excerpt":"","text":"利用 Application 类.当应用程序启动时 , 系统会自动对 Applicaiton 类进行初始化.我们可以定制自己的一个 Application 类, 以便于管理程序内的 全局状态信息. 自定义 WholeApplication 类1234567891011public class WholeApplication extends Application &#123; private static Context context; public void onCreate() &#123; context = getApplicationContext(); &#125; public static Context getContext() &#123; return context; &#125;&#125; 告知系统,程序启动时应该初始化 WholeApplication 而不是 Application1234&lt;application android:name=\"com.iyounix.practice.wholeapplication\" &gt; &lt;/application&gt; 使用方法任何想要用到 context 的地方 , 使用 WholeApplication.getContext() , 比如:1Toast.makeText(WholeApplication.getContext(), &quot;test&quot; , Toast.LENGTH_SHORT).show(); 问题比如为了让 litepal 正常工作 , 需要声明 :1234&lt;application android:name=\"org.litepal.LitePalApplication\" ...&gt;&lt;/application&gt; 并且在 WholeApplication 的 onCreate() 中初始化:1234public void onCreate() &#123; context = getApplicationContext(); LitePalApplication.initialize(context);&#125;","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"SOP_WebView_XML和JSON","slug":"Android_App/SOP_WebView_XML和JSON","date":"2018-08-11T03:12:05.000Z","updated":"2018-11-08T03:35:15.581Z","comments":true,"path":"2018/08/11/Android_App/SOP_WebView_XML和JSON/","link":"","permalink":"http://iyounix.com/2018/08/11/Android_App/SOP_WebView_XML和JSON/","excerpt":"","text":"JSON两种解析方法 JSONObject123456789101112131415161718private void parseJSONWithJSONObject(String jsonData) &#123; try &#123; // 定义 JASON 数组 , 将服务器返回的数据传入到了 JSONObject 对象中 JSONArray jsonArray = new JSONArray(jsonData); for(int i = 0; i &lt; jsonArray.length(); i++) &#123; JSONObject jsonObject = jsonArray.getJSONObject(i); String id = jsonObject.getString(&quot;id&quot;); String name = jsonObject.getString(&quot;name&quot;); String version = jsonObject.getString(&quot;version&quot;); Log.d(TAG, &quot;parseJSONWithJSONObject: id is &quot;+id); Log.d(TAG, &quot;parseJSONWithJSONObject: name is &quot;+name); Log.d(TAG, &quot;parseJSONWithJSONObject: version is &quot;+version); &#125; &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125;&#125; GSON比如要解析 App 类型的数据 先实现 App 类:1234567891011121314151617181920212223242526272829public class App &#123; private String id; private String name; private String version; public String getId() &#123; return id; &#125; public String getName() &#123; return name; &#125; public String getVersion() &#123; return version; &#125; public void setId(String id) &#123; this.id = id; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setVersion(String version) &#123; this.version = version; &#125;&#125; 然后直接利用 json 创建对象123456789private void parseJSONWithGSON(String jsonData) &#123; Gson gson = new Gson(); List&lt;App&gt; appList = gson.fromJson(jsonData, new TypeToken&lt;List&lt;App&gt;&gt;()&#123;&#125;.getType()); for (App app : appList) &#123; Log.d(TAG, &quot;parseJSONWithGSON: id is &quot; + app.getId()); Log.d(TAG, &quot;parseJSONWithGSON: name is &quot; + app.getName()); Log.d(TAG, &quot;parseJSONWithGSON: version is &quot; + app.getVersion()); &#125;&#125; XMLPull 解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private void parseXMLWithPull(String xmlData) &#123; try &#123; // 1. 工厂类 , 借助工厂类实例的 nuwPullParser() 获得 XmlPullParse 的实例 XmlPullParserFactory factory = XmlPullParserFactory.newInstance(); XmlPullParser xmlPullParser = factory.newPullParser(); // 2. setInput() 将服务器返回的 XML 数据 (xmlData) 设置进去并开始解析 xmlPullParser.setInput(new StringReader(xmlData)); // 3. 开始解析 // 3.1 getEventType() 获取当前的解析事件 int eventType = xmlPullParser.getEventType(); String id = \"\"; String name = \"\"; String version = \"\"; // 3.2 循环解析当前节点 直到 文件结束 while (eventType != XmlPullParser.END_DOCUMENT) &#123; String nodeName = xmlPullParser.getName(); switch (eventType) &#123; // 开始解析某个节点 case XmlPullParser.START_TAG: &#123; if (\"id\".equals(nodeName))&#123; id = xmlPullParser.nextText(); &#125; else if(\"version\".equals(nodeName)) &#123; version = xmlPullParser.nextText(); &#125; else if (\"name\".equals(nodeName)) &#123; name = xmlPullParser.nextText(); &#125; break; &#125; // 完成解析某个节点 case XmlPullParser.END_TAG: &#123; if (\"app\".equals(nodeName)) &#123; Log.d(TAG, \"parseXMLWithPull id is \" + id); Log.d(TAG, \"parseXMLWithPull name is \" + name); Log.d(TAG, \"parseXMLWithPull version is\" + version); &#125; break; &#125; default: break; &#125; eventType = xmlPullParser.next(); &#125; &#125; catch (XmlPullParserException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; SAX 解析MainActivity.java1234567891011121314151617181920private void parseXMLWithSAX(String xmlData) &#123; try &#123; // 创建工厂类 SAXParserFactory factory = SAXParserFactory.newInstance(); // 通过工厂类获取 XMLReader 对象 XMLReader xmlReader = factory.newSAXParser().getXMLReader(); ContentHandler handler = new ContentHandler(); //设置 ContentHanlder 实例到 XMLReader 中 xmlReader.setContentHandler(handler); //开始执行解析 xmlReader.parse(new InputSource(new StringReader(xmlData))); &#125; catch (SAXException e) &#123; e.printStackTrace(); &#125; catch (ParserConfigurationException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; ContentHandler.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137public class ContentHandler extends DefaultHandler &#123; private static final String TAG = &quot;ContentHandler&quot;; private String nodeName; private StringBuilder id; private StringBuilder name; private StringBuilder version; /** * Receive notification of the beginning of the document. * &lt;p&gt; * &lt;p&gt;By default, do nothing. Application writers may override this * method in a subclass to take specific actions at the beginning * of a document (such as allocating the root node of a tree or * creating an output file).&lt;/p&gt; * * @throws SAXException Any SAX exception, possibly * wrapping another exception. * @see org.xml.sax.ContentHandler#startDocument */ @Override public void startDocument() throws SAXException &#123; id = new StringBuilder(); name = new StringBuilder(); version = new StringBuilder(); &#125; /** * Receive notification of the end of the document. * &lt;p&gt; * &lt;p&gt;By default, do nothing. Application writers may override this * method in a subclass to take specific actions at the end * of a document (such as finalising a tree or closing an output * file).&lt;/p&gt; * * @throws SAXException Any SAX exception, possibly * wrapping another exception. * @see org.xml.sax.ContentHandler#endDocument */ @Override public void endDocument() throws SAXException &#123; super.endDocument(); &#125; /** * Receive notification of the start of an element. * 记录当前节点名字 * &lt;p&gt; * &lt;p&gt;By default, do nothing. Application writers may override this * method in a subclass to take specific actions at the start of * each element (such as allocating a new tree node or writing * output to a file).&lt;/p&gt; * * @param uri The Namespace URI, or the empty string if the * element has no Namespace URI or if Namespace * processing is not being performed. * @param localName The local name (without prefix), or the * empty string if Namespace processing is not being * performed. * @param qName The qualified name (with prefix), or the * empty string if qualified names are not available. * @param attributes The attributes attached to the element. If * there are no attributes, it shall be an empty * Attributes object. * @throws SAXException Any SAX exception, possibly * wrapping another exception. * @see org.xml.sax.ContentHandler#startElement */ @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; // 记录当前节点名字 nodeName = localName; &#125; /** * Receive notification of character data inside an element. * &lt;p&gt; * &lt;p&gt;By default, do nothing. Application writers may override this * method to take specific actions for each chunk of character data * (such as adding the data to a node or buffer, or printing it to * a file).&lt;/p&gt; * * @param ch The characters. * @param start The start position in the character array. * @param length The number of characters to use from the * character array. * @throws SAXException Any SAX exception, possibly * wrapping another exception. * @see org.xml.sax.ContentHandler#characters */ @Override public void characters(char[] ch, int start, int length) throws SAXException &#123; // 根据当前的节点名判断将内容添加到哪一个 StringBuilder 中 if (&quot;id&quot;.equals(nodeName)) &#123; id.append(ch, start, length); &#125; else if (&quot;name&quot;.equals(nodeName)) &#123; name.append(ch, start, length); &#125; else if (&quot;version&quot;.equals(nodeName)) &#123; version.append(ch, start, length); &#125; &#125; /** * Receive notification of the end of an element. * &lt;p&gt; * &lt;p&gt;By default, do nothing. Application writers may override this * method in a subclass to take specific actions at the end of * each element (such as finalising a tree node or writing * output to a file).&lt;/p&gt; * * @param uri The Namespace URI, or the empty string if the * element has no Namespace URI or if Namespace * processing is not being performed. * @param localName The local name (without prefix), or the * empty string if Namespace processing is not being * performed. * @param qName The qualified name (with prefix), or the * empty string if qualified names are not available. * @throws SAXException Any SAX exception, possibly * wrapping another exception. * @see org.xml.sax.ContentHandler#endElement */ @Override public void endElement(String uri, String localName, String qName) throws SAXException &#123; if (&quot;app&quot;.equals(localName)) &#123; Log.d(TAG, &quot;endElement: id is &quot; + id.toString().trim()); Log.d(TAG, &quot;endElement: name is &quot; + name.toString().trim()); Log.d(TAG, &quot;endElement: version is &quot; + version.toString().trim()); // 最后将 StringBuilder 清空 id.setLength(0); name.setLength(0); version.setLength(0); &#125; &#125;&#125;","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"SOP_动态权限","slug":"Android_App/SOP_动态权限","date":"2018-08-11T03:12:05.000Z","updated":"2018-11-08T03:34:48.649Z","comments":true,"path":"2018/08/11/Android_App/SOP_动态权限/","link":"","permalink":"http://iyounix.com/2018/08/11/Android_App/SOP_动态权限/","excerpt":"","text":"在程序运行的过程中由用户去授权执行某些可能是危险的的操作. 实现步骤 检查权限ContextCompat.checkSelfPermission参数 1 Context参数 2 具体的权限名字 12345ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.CALL_PHONE)判断有无权限:ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED 申请权限ActivityCompat.requestPermissions参数 1 Context参数 2 权限名参数 3 自定义权限码 1ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123; Manifest.permission.CALL_PHONE &#125;, 1) 之后系统会弹出权限申请对话框, 再调用 onRequestPermissionResult .授权结果会封装在 grantResults 参数中 回调onRequestPermissionResult123456789101112public void onRequestPermissionsResult ( int requestCode, String[] permissions , int[] grantResults) &#123; switch (requestCode) &#123; case 1: if(grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; call(); &#125; else &#123; Toast.makeText(this, &quot;You denied the permission&quot; , Toast.LENGTH_SHORT).show(); &#125; break; default: &#125;&#125;","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"SOP_多线程编程","slug":"Android_App/SOP_多线程编程","date":"2018-08-11T03:12:05.000Z","updated":"2018-11-08T03:34:40.109Z","comments":true,"path":"2018/08/11/Android_App/SOP_多线程编程/","link":"","permalink":"http://iyounix.com/2018/08/11/Android_App/SOP_多线程编程/","excerpt":"","text":"通过实现 Runnable 接口的实例来创建线程123456789101112131415161718192021222324252627282930313233343536373839404142class RunnableDemo implements Runnable &#123; private Thread t; private String threadName; RunnableDemo( String name) &#123; threadName = name; System.out.println(&quot;Creating &quot; + threadName ); &#125; public void run() &#123; System.out.println(&quot;Running &quot; + threadName ); try &#123; for(int i = 4; i &gt; 0; i--) &#123; System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i); // 让线程睡眠一会 Thread.sleep(50); &#125; &#125;catch (InterruptedException e) &#123; System.out.println(&quot;Thread &quot; + threadName + &quot; interrupted.&quot;); &#125; System.out.println(&quot;Thread &quot; + threadName + &quot; exiting.&quot;); &#125; public void start () &#123; System.out.println(&quot;Starting &quot; + threadName ); if (t == null) &#123; t = new Thread (this, threadName); t.start (); &#125; &#125;&#125; public class TestThread &#123; public static void main(String args[]) &#123; RunnableDemo R1 = new RunnableDemo( &quot;Thread-1&quot;); R1.start(); RunnableDemo R2 = new RunnableDemo( &quot;Thread-2&quot;); R2.start(); &#125; &#125; 通过 Runnable 接口的匿名类来创建线程123456new Thread(new Runnable() &#123; @Override public void run() &#123; // 处理具体的逻辑 (耗时) &#125;&#125;).start(); Thread 基本概念创建一个线程的第二种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。 缺点使用继承导致耦合性高 , 不如使用接口 Thread 实例1234567891011121314151617181920212223242526272829303132333435363738394041class ThreadDemo extends Thread &#123; private Thread t; private String threadName; ThreadDemo( String name) &#123; threadName = name; System.out.println(&quot;Creating &quot; + threadName ); &#125; public void run() &#123; // run() 中处理具体的逻辑 System.out.println(&quot;Running &quot; + threadName ); try &#123; for(int i = 4; i &gt; 0; i--) &#123; System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i); // 让线程睡眠一会 Thread.sleep(50); &#125; &#125;catch (InterruptedException e) &#123; System.out.println(&quot;Thread &quot; + threadName + &quot; interrupted.&quot;); &#125; System.out.println(&quot;Thread &quot; + threadName + &quot; exiting.&quot;); &#125; public void start () &#123; System.out.println(&quot;Starting &quot; + threadName ); if (t == null) &#123; t = new Thread (this, threadName); t.start (); &#125; &#125;&#125; public class TestThread &#123; public static void main(String args[]) &#123; ThreadDemo T1 = new ThreadDemo( &quot;Thread-1&quot;); T1.start(); ThreadDemo T2 = new ThreadDemo( &quot;Thread-2&quot;); T2.start(); &#125; &#125;","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"SOP_控件_Fragment","slug":"Android_App/SOP_控件_Fragment","date":"2018-08-11T03:12:05.000Z","updated":"2018-11-08T03:36:06.681Z","comments":true,"path":"2018/08/11/Android_App/SOP_控件_Fragment/","link":"","permalink":"http://iyounix.com/2018/08/11/Android_App/SOP_控件_Fragment/","excerpt":"","text":"Fragment 实例1234567891011121314151617181920212223protected void onCreate(Bundle savedInstanceState) &#123; ... // 1. 创建待添加 fragment 实例 replaceFragment(fragment1); ...&#125;private void replaceFragment(Fragment fragment) &#123; // 2. 获取 FragmentManager FragmentManager fragmentManager = getSupportFragmentManager(); // 3. 开启一个 事务 transaction FragmentTransaction transaction = fragmentManager.beginTransaction(); // 4. 向容器内添加或者替换 fragment // 参数1 容器id 参数2 待添加fragment实例 transaction.replace(R.id.right_layout, fragment); // 添加到返回栈 // 参数为名字,用来描述返回栈的状态 transaction.addToBackStack(null); // 5. 提交 事务 transaction transaction.commit();&#125; 在 onClick 中使用123456789101112131415RightFragment fragment1 = new RightFragment(); AnotherRightFragment fragment2 = new AnotherRightFragment(); @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.button1: replaceFragment(fragment1); break; case R.id.button2: replaceFragment(fragment2); default: break; &#125; &#125; Fragment 和 Activity 通信在 Activity 中调用 fragment 的方法 findFragmentById1RightFragment rightFragment = (RightFragment) getFragmentManager().findFragmentById(R.id.right_fragment); 在 Fragment 中调用 Activity 的方法1MainActivity activity = (MainActivity)getActivity(); Fragment 的生命周期","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"SOP_控件_AlertDialog","slug":"Android_App/SOP_控件_AlertDialog","date":"2018-08-11T03:12:05.000Z","updated":"2018-11-08T03:37:49.787Z","comments":true,"path":"2018/08/11/Android_App/SOP_控件_AlertDialog/","link":"","permalink":"http://iyounix.com/2018/08/11/Android_App/SOP_控件_AlertDialog/","excerpt":"","text":"12345678910111213AlertDialog.Builder builder = new AlertDialog.Builder(context);builder.setTitle(\"Warning\");builder.setMessage(\"You are forced to be offline. Please try to login again.\");builder.setCancelable(false); // 设置为不可取消builder.setPositiveButton(\"OK\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; ActivityCollector.finishAll(); // 销毁所有的活动 Intent intent = new Intent(context , LoginActivity.class); context.startActivity(intent); // 重新启动 LoginActivity &#125;&#125;);builder.show();","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"SOP_Intent传输对象的方法","slug":"Android_App/SOP_Intent传输对象的方法","date":"2018-08-11T03:12:05.000Z","updated":"2018-11-08T03:33:02.421Z","comments":true,"path":"2018/08/11/Android_App/SOP_Intent传输对象的方法/","link":"","permalink":"http://iyounix.com/2018/08/11/Android_App/SOP_Intent传输对象的方法/","excerpt":"","text":"正常的 Intent 传值的方法1234Intent intent = new Intent(FirstActivity.this, SecondActivity.class);intent.putExtra(&quot;string_data&quot;,&quot;hello&quot;);intent.putExtra(&quot;int_data&quot;,100);startActivity(intent); 在 SecondActivity 众通过 getIntent 获取值12getIntent().getStringExtra(&quot;string_data&quot;);getIntent().getIntExtra(&quot;int_data&quot;,0); 传输对象的方法Serializable比如有这样一个 class person12345678public class Person implements Serializable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName() &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge() &#123; this.age = age; &#125;&#125; Serializable 用法12345Person person = new Person();... //初始化赋值Intent intent = new Intent(FirstActivity.this, SecondActivity.class);intent.putExtra(&quot;person_data&quot;, person);startActivity(intent); 在 SecondActivity 众通过 getIntent 获取值1Person person = (Person) getIntent().getSerializableExtra(&quot;person_data&quot;); Parcelable需要修改 class Person:1234567891011121314151617181920212223242526272829303132//1. 首先实现 Parcelable 接口public class Person implements Parcelable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName() &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge() &#123; this.age = age; &#125; //2.1 重写 describeContents 方法 public int describeContents() &#123; return 0;&#125; //2.2 重写 writeToParcel 方法, 将 Person 中的字段一一写出 public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(name); // 写出name dest.writeInt(age); // 写出age &#125; //3. 提供 CREATOR 常量 // 创建 Parcelable.Creator 接口的一个实现, 并将泛型指定为 Person. public static final Parcelable.Creator&lt;Person&gt; CREATOR = new Parcelable.Creator&lt;Person&gt;()&#123; //4.1 重写 createFromParcel , 读取刚才写出的 name 和 age 字段 // 注意! 顺序必须和写出顺序完全相同 public Person createFromParcel(Parcel source) &#123; Person person = new Person(); person.name = source.readString(); //读取 name person.age = source.readInt(); //读取 age return person; &#125; //4.2 重写 newArray public Person[] newArray(int size) &#123; return new Person[size]; &#125; &#125;; Parcelable 用法完全一样:12345Person person = new Person();... //初始化赋值Intent intent = new Intent(FirstActivity.this, SecondActivity.class);intent.putExtra(&quot;person_data&quot;, person);startActivity(intent); 在 SecondActivity 众通过 getIntent 获取值 , 有少许差别1Person person = (Person) getIntent().getParcelableExtra(&quot;person_data&quot;);","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"SOP_Notification","slug":"Android_App/SOP_Notification","date":"2018-08-11T03:12:05.000Z","updated":"2018-11-08T03:35:38.433Z","comments":true,"path":"2018/08/11/Android_App/SOP_Notification/","link":"","permalink":"http://iyounix.com/2018/08/11/Android_App/SOP_Notification/","excerpt":"","text":"在 Activity 中创建 在 BoardCast 中创建 在 Service 中创建 使用 管理 Notification 1NotificationManager manager = (NotificationManager) Context.getSystemService(Context.NOTIFICATION_SERVICE); 构造 Notification 对象通过 NotificationCompat.Builder构造 1Notification notification = new NotificationCompat.Builder(context).build(); 或者123456Notification notification = new NotificationCompat.Builder(context) .setContentTitle(&quot;This is content title&quot;) .setContentText(&quot;This is content Text&quot;) .setWhen(System.currentTimeMillis()) //被通知的时间 .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.large_icon) .build(); 显示通知调用 NotificationManager 的 notifiy() 方法.参数1 id参数2 Notification 对象1manager.notify(1,notificaton) 更多通知技巧1setSound() 设置通知音频setVibrate() 设置振动setLights() 设置光效setDefaults(NotificationCompat.DEFAULT_ALL) 根据当前手机的默认参数设置一切 setSound()1.setSound(Uri.fromFile(new File(&quot;/system/media/audio/ringtones/Luna.ogg&quot;))) setVibrate()1234[0] 手机静止的时长[1] 手机振动的时长[2] 手机静止的时长[3] 手机振动的时长 比如:振 1s – 静 1s – 振 1s 代码为:1.setVibrate(new long[] &#123;0, 1000, 1000, 1000&#125;) 并且 AndroidManifest.xml 里面:1&lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot;/&gt; setLights1.setLights(Color.GREEN,1000,1000) 更多通知技巧2setStyle() 构建富文本通知内容setPriority() 设置通知的重要程度 setStyle参数1. NotificationCompat.Style 默认通知显示内容有限 , 比如 text , 如果过长 只能显示局部.解决方法如下1.setStyle(new NotificationCompat.BigTextStyle().bigText(&quot;This is a longlonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglong Text&quot;)) setPriority参数1.PRIORITY_MIN 最低;比如用户下拉通知栏PRIORITY_LOW 较低;PRIORITY_DEFAULT 默认;通知栏出现小图标PRIORITY_HIGH 较高; 放大,排名靠前PRIORITY_MAX 最高;立刻看到与响应, 比如微信通知弹窗 介绍和 Intent 类似 , 都用于指明’意图’,可以用于启动 Activity/Service/BroadCast.和 Intent 不同 , Intent 立即执行 , PendingIntent 延迟执行. 使用1. 静态获取 PendingIntent 实例getActivity()getBroadcast()getService()参数1 Context参数2 0参数3 Intent对象参数4 PendingIntent 行为: FLAG_ONE_SHOT FLAG_NO_CREATE FLAG_CANCEL_CURRENT FLAG_UPDATE_CURRENT 2. 构造器连缀一个 setContentIntentNotificationCompat.Builder.setContentIntent()参数 PendingIntent 对象12345Intent intent = new Intent(this, NotificationActivity.class);PendingIntent pi = PendingIntent.getActivity(this, 0 ,intent, 0);...Notification notification = new NotificationCompat.Builder(this) .setContentIntent(pi) 3. 取消系统状态栏上面的通知图标3.1 NotificationCompat.Builder 连缀 .setAutoCancel(true)3.2 利用 Manager 的 cancel()12NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);manager.cancel(1);","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"SOP_MediaPlayer","slug":"Android_App/SOP_MediaPlayer","date":"2018-08-11T03:12:05.000Z","updated":"2018-11-08T03:35:49.773Z","comments":true,"path":"2018/08/11/Android_App/SOP_MediaPlayer/","link":"","permalink":"http://iyounix.com/2018/08/11/Android_App/SOP_MediaPlayer/","excerpt":"","text":"常用控制方法Android 通过控制播放器的状态的方式来控制媒体文件的播放，其中： setDataSource() 设置要播放的音频文件位置prepare()和 prepareAsync() 完成准备工作提供了同步和异步两种方式设置播放器进入prepare状态，需要注意的是，如果MediaPlayer实例是由create方法创建的，那么第一次启动播放前不需要再调用prepare（）了，因为create方法里已经调用过了。start()是真正启动文件播放的方法，pause() 暂停播放stop() 停止播放seekTo() 是定位方法，可以让播放器从指定的位置开始播放，需要注意的是该方法是个异步方法，也就是说该方法返回时并不意味着定位完成，尤其是播放的网络文件，真正定位完成时会触发OnSeekComplete.onSeekComplete()，如果需要是可以调用 setOnSeekCompleteListener(OnSeekCompleteListener)设置监听器来处理的。release() 可以释放播放器占用的资源，一旦确定不再使用播放器时应当尽早调用它释放资源。reset() 可以使播放器从 Error 状态中恢复过来，重新会到 Idle 状态。isPlaying() 判断当前的 MediaPlayer 是否正在播放音频getDuration() 获取载入的音频文件的时长 使用 SOP1. 实例化可以使用直接new的方式：1MediaPlayer mp = new MediaPlayer(); 也可以使用create的方式，如：1MediaPlayer mp = MediaPlayer.create(this, R.raw.test_media_file_rsid);//这时就不用调用setDataSource了 2. 设置音频文件路径 setDataSourceMediaPlayer要播放的文件主要包括3个来源：a. 用户在应用中事先自带的resource资源 例如：MediaPlayer.create(this, R.raw.test_media_file_rsid);b. 存储在SD卡或其他文件路径下的媒体文件 例如：mp.setDataSource(“/sdcard/test.mp3”);c. 网络上的媒体文件 例如：mp.setDataSource(“http://www.xxx.com/test.mp3&quot;); MediaPlayer的setDataSource一共四个方法： setDataSource (String path) setDataSource (FileDescriptor fd) setDataSource (Context context, Uri uri) setDataSource (FileDescriptor fd, long offset, long length) 3. 进入准备状态 prepare()4. 操作start() / pause() / reset() 4）设置播放器的监听器： MediaPlayer提供了一些设置不同监听器的方法来更好地对播放器的工作状态进行监听，以期及时处理各种情况， 如： setOnCompletionListener(MediaPlayer.OnCompletionListener listener)、 setOnErrorListener(MediaPlayer.OnErrorListener listener)等,设置播放器时需要考虑到播放器可能出现的情况设置好监听和处理逻辑，以保持播放器的健壮性。","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"组件_ContentProvider","slug":"Android_App/组件_ContentProvider","date":"2018-08-11T03:12:05.000Z","updated":"2018-11-08T03:38:39.741Z","comments":true,"path":"2018/08/11/Android_App/组件_ContentProvider/","link":"","permalink":"http://iyounix.com/2018/08/11/Android_App/组件_ContentProvider/","excerpt":"","text":"基本概念用法两种: 使用现有的ContentProvider来读取和操作相应程序中的数据 创建自己的内容提供器给我们的程序的数据提供外部访问接口 ContentResolver 使用方法ContentResolver resolver = Context.getContentResolver();resolver.insert //增resolver.delete //删resolver.update //改resolver.query //查 参数为 内容URI :content://com.example.app.provider/table1不过得先解析为 URI 对象:Uri uri = Uri.parse(&quot;content://com.example.app.provider/table1&quot;) 使用 内容URI 查询 table1 的内容:1234567Cursor cursor = getContentResolver().query( uri, projection, //指定列名 selection, //Where约束 selectionArgs, //Where占位符提供具体的值 sortOrder //指定查询结果的排序方式); 通过移动游标位置,遍历 Cursor:1234567if (cursor != null)&#123; while (cursor.moveToNext()) &#123; String column1 = cursor.getString(cursor.getColumnIndex(&quot;column1&quot;)); int column2 = cursor.getInt(cursor.getColumnIndex(&quot;column2&quot;)); &#125; cursor.close();&#125; 操作实例//增1234ContentValues values = new ContentValues();values.put(&quot;column1&quot;, &quot;text&quot;);values.put(&quot;column2&quot;, 1);getContentResolver().insert(uri,values); // 增 //改123ContentValues values = new ContentValues();values.put(&quot;column1&quot;, &quot;&quot;);getContentResolver().update(uri. values, &quot;column1 = ? and column2 = ?&quot; , new String[] &#123;&quot;text&quot; , &quot;1&quot;&#125;); //改 //删1getContentResolver().delete(uri, &quot;column2 = ?&quot;, new String[] &#123;&quot;1&quot;&#125;);","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"SOP_异步消息处理机制","slug":"Android_App/SOP_异步消息处理机制","date":"2018-08-11T03:12:05.000Z","updated":"2018-11-08T03:34:30.029Z","comments":true,"path":"2018/08/11/Android_App/SOP_异步消息处理机制/","link":"","permalink":"http://iyounix.com/2018/08/11/Android_App/SOP_异步消息处理机制/","excerpt":"","text":"基本概念 Message线程之间传递的载体.what .arg1 .arg2 字段可以携带整型数据 Handler用于发送和处理 MessageHandler.sendMessage()Handler.handleMessage() MessageQueue存放所有通过 Handler 发送的消息, 等待被处理每个线程只会有一个 MessageQueue LooperLooper 是每个线程 MessageQueue 的管家.Looper.loop() 后, 会进入循环, 当发现 MessageQueue 中存在消息, 就会取出, 并传递到 Handler.handleMessage 中.每个线程也只会有一个 Looper 对象. 流程 主线程创建 Handler 对象, 重写 handle Message() 方法 子线程中要操作 UI 时, 创建 Message 对象, 并通过 Handler 发送 Message 即可 Message 会被添加到 MessageQueue Looper 会一直尝试从 MessageQueue 中取出 Msg, 最后分发到 handleMessage() 中 AsyncTask 基本概念AsyncTask 为抽象类, 需要继承 并 指定三个泛形参数泛形参数:1.Params 在执行 AsyncTask 传入的参数, 用于后台任务中使用2.Progress 后台任务执行时, 如果需要在界面上显示当前进度, 这里的泛形为进度单位3.Result 任务执行完毕后, 对结果进行返回, 这里的泛形为返回类型123456class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123; ...&#125;// Void 不需要参数给后台// Integer 用整型作进度单位// Boolean 作为返回值 重写 4 个方法: onPreExecute()在后台任务执行前开始调用,完成界面初始化 doInBackground(Params…)这里处理所有耗时内容, 将会运行在子线程中.所以不可执行任何 UI 操作, 可以调用 publishProgress 方法进行 UI 更新 onProgressUpdate(Progress…)当调用了 publishProgress 后, 调用本方法, 其中携带的参数就是后台任务中传递过来的可以在此进行 UI 更新 onPostExecute(Result)后台执行完毕 通过 return 返回时, 此方法被调用.Result 作为参数传递到此方法, 一般用其进行 UI 操作. AsyncTask 实例1234567891011121314151617181920212223242526272829303132class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123; protected void onPreExecute() &#123; progressDialog.show(); //显示进度对话框 &#125; protected Boolean doInBackground(Void... params) &#123; while(true)&#123; int downloadPercent = doDownload(); //虚构的方法 //有嗯与计算当前下载进度并返回 publishProgress(downloadPercent); if (downloadPercent &gt;= 100) &#123; break; &#125; &#125; return true; &#125; protected void onProgressUpdate(Integer... values) &#123; //更新下载进度 progressDialog.setMessage(&quot;Downloaded&quot; + values[0] + &quot;%&quot;); &#125; protected void onPostExecute(Boolean result) &#123; progressDialog.dismiss(); // 关闭进度对话框 // 在这里提示下载结果 if (result) &#123; Toast.makeText(context, &quot;Download succeeded&quot;, Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(context, &quot;Download Failed&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; Handler 实例子线程123456789101112131415161718192021 public static final int UPDATE_TEXT = 1; public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.change_text: new Thread(new Runnable() &#123; @Override public void run() &#123;// 不能直接在子线程中操作 UI// text.setText(&quot;Nice to meet you&quot;); Message message = new Message(); message.what = UPDATE_TEXT; handler.sendMessage(message); Log.d(TAG, &quot;onClick run() handler sendMessage&quot;); &#125; &#125;).start(); break; default: break; &#125; &#125; 主线程1234567891011121314151617private Handler handler = new Handler() &#123; //创建 Handler 对象 // 重写父类 handleMessage 方法 // 接收到子线程发送的 sendMessage 后调用 handleMessage 进行处理 public void handleMessage(Message msg) &#123; Log.d(TAG, &quot;handlerMessage: Got Message&quot;); switch(msg.what) &#123; case UPDATE_TEXT: // 进行 UI 操作 text.setText(&quot;Nice To Meet You!&quot;); Log.d(TAG, &quot;handlerMessage: Got Message: UI Update&quot;); break; default: break; &#125; &#125;&#125;;","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"组件_BroadcastReceiver","slug":"Android_App/组件_BroadcastReceiver","date":"2018-08-11T03:12:05.000Z","updated":"2018-11-08T03:33:23.313Z","comments":true,"path":"2018/08/11/Android_App/组件_BroadcastReceiver/","link":"","permalink":"http://iyounix.com/2018/08/11/Android_App/组件_BroadcastReceiver/","excerpt":"","text":"动态注册MainActivity.java12345678910111213141516171819202122232425262728293031323334353637383940 private IntentFilter intentFilter; private NetworkChangeReceiver networkChangeReceiver; // 内部类 onCreate &#123; intentFilter = new IntentFilter(); // 添加 Action intentFilter.addAction(\"android.net.conn.CONNECTIVITY_CHANGE\"); networkChangeReceiver = new NetworkChangeReceiver(); // 内部类实例 registerReceiver(networkChangeReceiver, intentFilter); &#125; // 内部类 class NetworkChangeReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; // 获得系统服务类 ConnectivityManager connectivityManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo(); // 具体的使用场景 if (networkInfo != null &amp;&amp; networkInfo.isAvailable()) &#123; Toast.makeText(context, \"network is available\", Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(context, \"network is unavailable\", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); Log.d(TAG, \"onDestroy\"); unregisterReceiver(networkChangeReceiver); &#125;&#125; AndroidManifest.xml添加权限1&lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /&gt; 静态注册应用场景接受开机广播右击 包名 -&gt; New -&gt; Other -&gt; BroadcastReceiverenabled = true 表示是否启用该 BoardcastReceiverexported = ture 表示允许接受本程序以外的 Boardcast BootCompleteReceiver.java12345678910public class BootCompleteReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; // TODO: This method is called when the BroadcastReceiver is receiving // an Intent broadcast.// throw new UnsupportedOperationException(&quot;Not yet implemented&quot;); Toast.makeText(context, &quot;Boot Complete&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125; AndroidManifest.xml123456789101112&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;/&gt;&lt;application &lt;receiver android:name=&quot;.BootCompleteReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt;&lt;/application&gt; 自定义标准广播应用场景点击 Mainactivity 的 Button ,发送广播然后 App 接收到并弹出 Toast Mainactivity.java123456789// Example 3 MY_BROADCASTButton button = findViewById(R.id.button);button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(&quot;com.iyounix.android.a010broadcasts.MY_BROADCAST&quot;); sendBroadcast(intent); &#125;&#125;); MyBroadcastReceiver.javapublic class MyBroadcastReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { Toast.makeText(context, &quot;received in Younix BoardcastReceiver&quot;,Toast.LENGTH_SHORT).show(); } } AndroidManifest.xml1234567&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.iyounix.android.a010broadcasts.MY_BROADCAST&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"数据持久化_数据库_LitePal 和 SQLite","slug":"Android_App/数据持久化_数据库_LitePal 和 SQLite","date":"2018-08-11T03:12:05.000Z","updated":"2018-11-08T03:38:29.514Z","comments":true,"path":"2018/08/11/Android_App/数据持久化_数据库_LitePal 和 SQLite/","link":"","permalink":"http://iyounix.com/2018/08/11/Android_App/数据持久化_数据库_LitePal 和 SQLite/","excerpt":"","text":"LitePal 基本概念LitePal 是开源的 Android 数据库框架, 采用了 对象关系映射 ORM 模式 .封装了常用数据库功能 ORM(对象关系映射) 指的是 面向对象语言 和 关系型数据库 之间建立一种映射关系. 使用方法配置123dependencies &#123; compile &apos;org.litepal.android:core:2.0.0&apos;&#125; 1android:name=&quot;org.litepal.LitePalApplication&quot; litepal.xml 1Connector.getDatabase() SQLite 简介SQLiteOpenHelper 抽象类{ onCreate() onUpgrade() getReadableDatabase() //以只读的方式打开db getWritableDatabase() //以可读写的方式打开db,如果db只读,则返回异常 SQLiteOpenHelper() //构造方法 // 参数1 Context 参数2 数据库名 参数3 查询数据的时候返回自定义的cursor(null) 参数4 当前数据库的版本号} 文件保存在 /data/data/&lt;package name&gt;/databases/ 目录下 SQL 基本操作建表 Create123456create table Book ( id integer primary key autoincrement, // primary key 将 id 设置为主键 // autoincrement 自增长 author text, // 文本类型 price real, // 浮点型 pages integer, // 整型 name text) 1234567891011121314151617181920212223242526272829public class MyDatabaseHelper extends SQLiteOpenHelper &#123; public static final String CREATE_BOOK = &quot;create table Book (&quot; +&quot;id integer primary key autoincrement,&quot; +&quot;author text,&quot; +&quot;price real,&quot; +&quot;pages integer,&quot; +&quot;name text)&quot;; private Context mContext; public MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); mContext = context; &#125; @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL(CREATE_BOOK); Toast.makeText(mContext, &quot;Create succeeded&quot;, Toast.LENGTH_SHORT).show(); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; &#125;&#125; 实例化抽象类 MyDatabaseHelper12345678910private MyDatabaseHelper dbHelper;dbHelper = new MyDatabaseHelper(this, &quot;BookStore.db&quot;, null, 1); Button createDatabase = findViewById(R.id.create_database); createDatabase.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; dbHelper.getWritableDatabase(); &#125; &#125;); 删表 Drop12db.execSQL(&quot;drop table if exists Book&quot;);db.execSQL(&quot;drop table if exists Category&quot;); 升级 Update第四个参数, 比之前大.12dbHelper = new MyDatabaseHelper(this, &quot;BookStore.db&quot;, null, 2); 查表.table //查表.schema //查看建表语句.exit .quit //退出 数据库操作 CRUD添加数据 insert()insert()参数1 表名参数2 未指定添加数据的情况下,给可为空的列自动赋值NULL. 不用就填null参数3 ContentValues 对象, 提供了 put()方法的重载, 用于添加数据12345678910SQLiteDatabase db = dbHelper.getWritableDatabase(); ContentValues values = new ContentValues(); // 开始组装第一条数据 values.put(&quot;name&quot;, &quot;The Da Vinci Code&quot;); values.put(&quot;author&quot;, &quot;Dan Brown&quot;); values.put(&quot;pages&quot;, 454); values.put(&quot;price&quot;, 16.94); // 插入第一条数据 db.insert(&quot;Book&quot;, null, values); values.clear(); 修改数据 update()update()参数1 表名参数2 ContentValues 对象, 提供了 put()方法的重载, 用于添加数据参数3 4 约束更新某一行或几行 , 默认是更新全部 ; 参数3 对应 where 语句12345SQLiteDatabase db = dbHelper.getWritableDatabase();ContentValues values = new ContentValues();values.put(&quot;price&quot;, 10.99);db.update(&quot;Book&quot;, values, &quot;name = ?&quot;, new String[] &#123;&quot;The Da Vinci Code&quot;&#125;); 删除数据 deleted()delete()参数 1 表名参数 2 3 whereClause 查询语句 , 比如 pages &gt; ? , new Sting[] {“500”}123SQLiteDatabase db = dbHelper.getWritableDatabase();db.delete(&quot;Book&quot;, &quot;pages &gt; ?&quot;, new String[] &#123;&quot;500&quot;&#125;); 查询数据 query()query()参数 1 table 表名 , from table_name参数 2 columns 查询哪几列 , select column1,column2参数 3 selection 4 selectionArgs 约束条件 where column = value参数 5 groupBy 的列 , group by column参数 6 having , group by 的约束 , having column = value参数 7 orderBy , 指定查询的排列方式 , order by column1 column2返回 Cursor 对象12345678910111213141516SQLiteDatabase db = dbHelper.getWritableDatabase();Cursor cursor = db.query(&quot;Book&quot;, null,null,null,null,null,null);if(cursor.moveToFirst())&#123; do &#123; //遍历 Cursor 对象, 取出数据并打印 String name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;)); String author = cursor.getString(cursor.getColumnIndex(&quot;author&quot;)); int pages = cursor.getInt(cursor.getColumnIndex(&quot;pages&quot;)); double price = cursor.getDouble(cursor.getColumnIndex(&quot;price&quot;)); Log.d(TAG,&quot;book name is &quot; + name); Log.d(TAG,&quot;book author is &quot; + author); Log.d(TAG,&quot;book pages is &quot; + pages); Log.d(TAG,&quot;book price is &quot; + price); &#125; while(cursor.moveToNext());&#125;cursor.close(); 直接使用 SQL 操作数据execSQL 和 rawQuery 123456789# 增db.execSQL(&quot;insert into Book (name, author, pages, price) values(?, ?, ?, ?)&quot;, new String[] &#123;&quot;The Da Vinci Code&quot;, &quot;Dan Brown&quot;, &quot;454&quot;, &quot;16.96&quot;&#125;);# 删db.execSQL(&quot;delete from Book where pages &gt; ?&quot;, new String[] &#123;&quot;500&quot;&#125;);# 改db.execSQL(&quot;update Book set price = ? where name = ?&quot;, new String[] &#123;&quot;10.99&quot;, &quot;The Da Vinci Code&quot;&#125;);# 查db.rawQuery(&quot;select * from Book&quot; , null);","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"SOP_WebView","slug":"Android_App/SOP_WebView","date":"2018-08-11T03:12:05.000Z","updated":"2018-11-08T03:38:15.476Z","comments":true,"path":"2018/08/11/Android_App/SOP_WebView/","link":"","permalink":"http://iyounix.com/2018/08/11/Android_App/SOP_WebView/","excerpt":"","text":"WebView 使用 SOPactivity.xml1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;WebView android:id=\"@+id/web_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/WebView&gt;&lt;/LinearLayout&gt; MainActivity.java1234567WebView mWebView = findViewById(R.id.web_view);// 支持 JS 脚本mWebView.getSettings().setJavaScriptEnabled(true);// 当跳转网页的时候, 我们希望还是在当前 WebView 中,而不是访问浏览器mWebView.setWebViewClient(new WebViewClient());// 默认展现的网页mWebView.loadUrl(\"http://www.baidu.com\"); AndroidManifest.xml1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 特殊注意事项子线程中完成服务器结束响应后的回调在获取到服务器响应数据后, 可以对其进行解析和处理.但是网络请求是耗时操作, 需要放在子线程中进行. WebView_Http 基本介绍Client 向 Server 发一条请求 ,Server 收到后返回一些数据给 Client ,Client 对数据进行解析和处理 HttpURLConnection SOP 实例化对象 12URL url = new URL(&quot;http://www.iyounix.com&quot;);HttpURLConnection connection = (HttpURLConnection) url.openConnection(); 设置 Http 请求所使用的方法GET 希望从服务器获取数据POST 希望提交数据给服务器 123456connection.setRequestMethod(&quot;GET&quot;);connection.setRequestMethod(&quot;POST&quot;);// 设置连接超时connection.setConnectTimeout(8000);// 设置读取超时connection.setReadTimeout(8000); 获取服务器返回的输入流 getInputStream() 1InputStream in = connection.getInputStream(); 获取到的输入流可以拿来 进行 各种骚操作. example:12345678910InputStream in = connection.getInputStream(); reader = new BufferedReader(new InputStreamReader(in)); StringBuilder response = new StringBuilder(); String line; //读到读完为止 while ((line = reader.readLine()) != null) &#123; response.append(line); &#125; // Android 的子线程中是无法进行 UI 界面的刷新的 // 通过调用 runOnUiThread 回到主线程进行 UI 的刷新 showResponse(response.toString()); 提交数据给服务器 getOutputStream() 123connection.setRequestMethod(&quot;POST&quot;); DataOutputStream out = new DataOutputStream(connection.getOutputStream()); out.writeBytes(&quot;username=admin &amp; password=123456&quot;); 关闭 1connection.disconnect(); WebView_OKHttp 基本介绍Square 公司开发.https://github.com/square/okhttp OKHttp SOPbuild.gradle添加依赖123dependencies&#123; implementation &apos;com.squareup.okhttp3:okhttp:3.4.1&apos;&#125; MainActivity.java1234567891011121314151617181920212223242526272829// 1. 创建 OkHttpClient 实例 OKHttpClient client = new OkHttpClient();// 2. 创建 Request 对象用来发送请求 Request request = new Request.Builder().build(); // 可以通过连缀其他方法丰富 Request 对象 Request request = new Request.Builder() .url(&quot;http://www.iyounix.com&quot;) .build(); // 3.1 获取服务器返回的数据 GET Response response = client.newCall(request).execute(); // 如下获取返回的具体的内容 String reponseData = response.body().string();// 3.2 向服务器发送请求 POST // 构建 RequestBody 对象存放待提交的参数 RequestBody requestBody = new FormBody.Builder() .add(&quot;username&quot;, &quot;admin&quot;) .add(&quot;password&quot;, &quot;123456&quot;) .build(); // post() Request request = new Request.Builder() .url(&quot;http://www.iyounix.com&quot;) .post(requestBody) .build(); // execute() 请求并获取返回的数据 Response response = client.newCall(request).execute();","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"数据持久化_文件存储","slug":"Android_App/数据持久化_文件存储","date":"2018-08-11T03:12:05.000Z","updated":"2018-11-08T03:33:42.309Z","comments":true,"path":"2018/08/11/Android_App/数据持久化_文件存储/","link":"","permalink":"http://iyounix.com/2018/08/11/Android_App/数据持久化_文件存储/","excerpt":"","text":"写123456789101112131415161718192021222324/** * 文件名 为 data * @param inputText */private void save(String inputText) &#123; FileOutputStream out = null; BufferedWriter writer = null; try &#123; out = openFileOutput(\"data\", Context.MODE_PRIVATE); writer = new BufferedWriter(new OutputStreamWriter(out)); writer.write(inputText); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (writer != null) &#123; writer.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 读12345678910111213141516171819202122232425262728public String load()&#123; FileInputStream in = null; BufferedReader reader = null; StringBuilder content = new StringBuilder(); try &#123; // openFileInput 获取 FileInputStream 对象 in = openFileInput(\"data\"); // 构建 BufferedReader 对象 reader = new BufferedReader(new InputStreamReader(in)); String line = \"\"; // 一行行的读, 读到的内容存在 StringBuilder 中 while ((line = reader.readLine()) != null) &#123; content.append(line); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return content.toString();&#125;","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"数据持久化_SharedPreferences","slug":"Android_App/数据持久化_SharedPreferences","date":"2018-08-11T03:12:05.000Z","updated":"2018-11-08T03:34:05.669Z","comments":true,"path":"2018/08/11/Android_App/数据持久化_SharedPreferences/","link":"","permalink":"http://iyounix.com/2018/08/11/Android_App/数据持久化_SharedPreferences/","excerpt":"","text":"简介通过键值对的方式进行存储. 保存为 xml 文件value - key 存储 获取 SharedPreferences 对象 SharedPreferences.Editor editor = getSharedPreferences(“data”, MODE_PRIVATE).edit(); editor.putString(“name”, “Tom”); editor.apply();123456// 通过 getSharedPreferences() 方法指定 SharedPreferences 文件名为 dataSharedPreferences.Editor editor = getSharedPreferences(&quot;data&quot;, MODE_PRIVATE).edit();editor.putString(&quot;name&quot;, &quot;Tom&quot;);editor.putInt(&quot;age&quot;, 28);editor.putBoolean(&quot;married&quot;,false);editor.apply(); 获取 SharedPreferences 对象的三种方法 Context 类的 getSharedPreferences(): getSharedPreferences(“data”, MODE_PRIVATE); Activity 类的 getPreferences(): getPreferences(MODE_PRIVATE); PreferenceManager 类的 getDefaultSharedPreferences(): PreferenceManager.getDefaultSharedPreferences(Context); 读取123456SharedPreferences pref = getSharedPreferences(&quot;data&quot;, MODE_PRIVATE);//SharedPreferences pref2 = getPreferences(MODE_PRIVATE);//SharedPreferences pref3 = new PreferenceManager.getDefaultSharedPreferences(Context);String name = pref.getString(&quot;name&quot;, &quot;NOBODY&quot;);int age = pref.getInt(&quot;age&quot;,0);boolean married = pref.getBoolean(&quot;married&quot;, false);","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android7.1 RK3399 添加开机播放视频功能","slug":"Android_App/[Android7.1][RK3399] 添加开机播放视频功能","date":"2018-05-31T15:33:05.000Z","updated":"2018-11-08T03:32:03.141Z","comments":true,"path":"2018/05/31/Android_App/[Android7.1][RK3399] 添加开机播放视频功能/","link":"","permalink":"http://iyounix.com/2018/05/31/Android_App/[Android7.1][RK3399] 添加开机播放视频功能/","excerpt":"","text":"Platform: RK3399OS: Android 7.1Kernel: v4.4.83 rk3399上默认已经添加了开机播放视频的功能，只要按照如下改动就可成功播放。1234567891011121314151617181920212223242526kris@eco:~/rk3399/device/rockchip/rk3399$ g dfdiff --git a/device.mk b/device.mkindex 2a730bc..6645072 100755--- a/device.mk+++ b/device.mk@@ -282,3 +282,8 @@ PRODUCT_COPY_FILES += \\ #Kris,170814. PRODUCT_COPY_FILES += \\ device/rockchip/rk3399/kmsg.sh:system/bin/kmsg.sh++#Kris,170904, copy boot video.+PRODUCT_COPY_FILES += \\+ device/rockchip/rk3399/bootvideo.mp4:system/media/bootanimation.ts+diff --git a/rk3399_mid/system.prop b/rk3399_mid/system.propindex a9d895e..b0e1807 100755--- a/rk3399_mid/system.prop+++ b/rk3399_mid/system.prop@@ -45,3 +45,7 @@ ro.sf.lcd_density=280 #Kris,180712,remove lockscreen. ro.lockscreen.disable.default=true++#Kris,180724, enable boot video.+persist.sys.bootvideo.enable=true+persist.sys.bootvideo.showtime=10 //测试验证最大15秒，见后面分析 代码流程：12345678910111213141516171819status_t BootAnimation::readyToRun() &#123; //判断DATA_BOOTVIDEO_FILE或者SYSTEM_BOOTVIDEO_FILE是否存在。 //static const char DATA_BOOTVIDEO_FILE[] = &quot;/data/local/bootanimation.ts&quot;; //static const char SYSTEM_BOOTVIDEO_FILE[] = &quot;/system/media/bootanimation.ts&quot;; if (access(SYSTEM_BOOTVIDEO_FILE, R_OK) == 0)&#123; mVideoFile = (char*)SYSTEM_BOOTVIDEO_FILE; &#125; else if (access(DATA_BOOTVIDEO_FILE, R_OK) == 0)&#123; mVideoFile = (char*)DATA_BOOTVIDEO_FILE; &#125; //persist.sys.bootvideo.enable需要设置成true property_get(&quot;persist.sys.bootvideo.enable&quot;,decrypt, &quot;false&quot;); char value[PROPERTY_VALUE_MAX]; property_get(&quot;persist.sys.bootvideo.showtime&quot;, value, &quot;-1&quot;); if(mVideoFile != NULL &amp;&amp; !strcmp(decrypt, &quot;true&quot;) &amp;&amp;(atoi(value)!=0)) &#123; mVideoAnimation = true; &#125;else&#123; ALOGD(&quot;bootvideo: No boot video animation,EXIT_VIDEO_NAME:%s,bootvideo.showtime:%s\\n&quot;,decrypt,value); &#125;&#125; threadLoop():1234567bool BootAnimation::threadLoop()&#123; //mVideoAnimation为true就播放视频 if (mVideoAnimation)&#123; r = video(); &#125;&#125; video():12345678910111213141516171819202122232425262728bool BootAnimation::video()&#123;...... //视频播放的时间 property_get(&quot;persist.sys.bootvideo.showtime&quot;, value, &quot;-1&quot;); int bootvideo_time = atoi(value);//s //最大不能超过两分钟 if(bootvideo_time &gt; 120) bootvideo_time = 120;...... while(true) &#123; const nsecs_t realVideoTime = systemTime()-mStartbootanimaTime; //这里检查要不要退出 //退出的条件是service.bootanim.exit被置1 checkExit(); property_set(&quot;sys.bootvideo.closed&quot;, &quot;0&quot;); usleep(CHECK_DELAY); //播放完或者播放时间超过了就暂停 if(!mp-&gt;isPlaying()||(((ns2ms(realVideoTime)/1000) &gt; bootvideo_time) &amp;&amp; (bootvideo_time &gt; -1)))&#123; mp-&gt;pause(); &#125; if(exitPending())&#123; ALOGD(&quot;bootvideo:-----------------stop bootanimationvedio&quot;); break; &#125; &#125; ......&#125; 小结：实际验证下来，发现视屏的播放并不能按照预设的时间来执行。大概播放15秒之后MediaPlayer使用的RockFFPlayer会被reset。具体最大播放时间可以打印realVideoTime的值。12307-24 17:46:11.023 733 733 D PhoneStatusBar: disable: &lt; expand* icons alerts system_info back* home* recent* clock search* quick_settings &gt;07-24 17:46:11.024 308 1212 D RockFFPlayer: reset()***********07-24 17:46:11.024 308 1212 D RockFFPlayerBase: dumpStatus(): Started","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android7.1 打开设置中的返回键","slug":"Android_App/[Android7.1] 打开设置中的返回键","date":"2018-05-01T15:33:05.000Z","updated":"2018-11-08T03:31:27.545Z","comments":true,"path":"2018/05/01/Android_App/[Android7.1] 打开设置中的返回键/","link":"","permalink":"http://iyounix.com/2018/05/01/Android_App/[Android7.1] 打开设置中的返回键/","excerpt":"","text":"OS: Android7.1 应用场景Setting App 在没有物理按键和虚拟返回键的时候无法返回.不过 app 中是自带这个功能的, 不过默认是关闭的. 解决方案1234567891011--- a/src/com/android/settings/SettingsActivity.java+++ b/src/com/android/settings/SettingsActivity.java@@ -629,7 +629,8 @@ public class SettingsActivity extends SettingsDrawerActivity mInitialTitleResId, mInitialTitle, false); &#125; else &#123; // No UP affordance if we are displaying the main Dashboard- mDisplayHomeAsUpEnabled = false;+ mDisplayHomeAsUpEnabled = true; // Show Search affordance mDisplaySearch = true; mInitia lTitleResId = R.string.dashboard_title;","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 MTK6737 长按 Power 没有真正关机 (MTK IPO 功能)","slug":"Android_Driver/Driver/[Android6.0][MTK6737] 长按 Power 没有真正关机 (MTK IPO 功能)","date":"2018-03-31T15:33:05.000Z","updated":"2018-11-08T02:35:12.008Z","comments":true,"path":"2018/03/31/Android_Driver/Driver/[Android6.0][MTK6737] 长按 Power 没有真正关机 (MTK IPO 功能)/","link":"","permalink":"http://iyounix.com/2018/03/31/Android_Driver/Driver/[Android6.0][MTK6737] 长按 Power 没有真正关机 (MTK IPO 功能)/","excerpt":"","text":"Hardware:MT6737DeviceOS:Android6.0Kernel: Linux3.18HostOS: Ubuntu16.04 需求正常开机 45s.长按 Power 键进行关机后, 在 5s 内立即按住 Power 键进行开机虽然会正常出现开机动画, 但是会继续之前退出时的状态. 比如正在放歌, 关机, 立即开机, 会出现开机动画, 但是在开机动画界面会继续放关机前的歌, 并回到关机前的界面.这是因为 MTK 有 IPO 快速开关机功能导致的.我们并不需要 IPO 功能, 所以将其裁剪掉. 关掉 IPO 功能device-MTK_IPOH_SUPPORT = yes+MTK_IPOH_SUPPORT = no MTK_IPO_MDRST_SUPPORT = no-MTK_IPO_SUPPORT = yes+MTK_IPO_SUPPORT = no MTK_IPTV_SUPPORT = no MTK_IPV6_SUPPORT = yes MTK_IPV6_TETHER_NDP_MODE = no vendorkernel关掉电池检测和温度检测功能devicedevice/bror/br6737m_65_s_m0/ProjectConfig.mk1MTK_DISABLE_POWER_ON_OFF_VOLTAGE_LIMITATION=yes vendor./vendor/mediatek/proprietary/bootable/bootloader/preloader/custom/br6737t_35g_s_m0/br6737t_35g_s_m0.mk1MTK_DISABLE_POWER_ON_OFF_VOLTAGE_LIMITATION=yes kernelkernel-3.18/arch/arm64/configs/br6737m_65_s_m0_defconfig1CONFIG_MTK_DISABLE_POWER_ON_OFF_VOLTAGE_LIMITATION=y","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"},{"name":"MediaTek","slug":"MediaTek","permalink":"http://iyounix.com/tags/MediaTek/"}]},{"title":"Android6.0 MTK6737 启动流程","slug":"Environment/MTK6737/[IoT4G] 启动流程","date":"2018-03-31T15:33:05.000Z","updated":"2018-11-08T02:15:53.629Z","comments":true,"path":"2018/03/31/Environment/MTK6737/[IoT4G] 启动流程/","link":"","permalink":"http://iyounix.com/2018/03/31/Environment/MTK6737/[IoT4G] 启动流程/","excerpt":"","text":"OS:Android6.0Hardware:MTK6737 [TOC] 一、启动流程概览1. BootRom固化在 CPU 内部。负责从外部的存储器中加载 Preloader。负责 USB Download。 2. Preloader属于 Bootloader 的第一部分。负责 MTK Licensed负责 基础 Module 的 初始化，比如 eMMC，PLL，DRAM 等。负责 加载 LittleKernel（LK） 3. LK属于 Bootloader 的第二部分。负责 设备的初始化。负责 加载 Linux Kernel。支持 fastboot 更新。 4. Kernel负责 设备初始化 / 内核初始化。负责 引导启动内核态 init 进程。 5. Android负责 引导启动用户态 init 进程。负责 Zygote 启动。负责 Framework 初始化等。 以上基本可以化为三个部分：Bootloader（Preloader+LK）、Kernel、Android。后面我们深入代码逐个分析。 二、Bootloader 引导Bootloader 部分主要功能包括 设置处理器和内存频率、指定调试信息端口、可引导的存储设备等。完成可执行环境创建后，把 software 装载到内存并执行。除了装载 software ，外部工具也可以和 bootloader 握手，指示设备进入不同的操作模式（比如 USB 下载模式和 META 模式）。就算没有外部工具的握手，也可以通过自定义按键，使 bootloader 进入这些模式。 由于不同芯片商对 arm core 封装差异比较大，所以不同的 arm 处理器,对于上电引导都是由特定处理器芯片厂商自己开发的程序,这个上电引导程序通常比较简单,会初始化硬件,提供下载模式等,然后才会加载通常的 bootloader （uboot）。 对于 MTK 平台，其 bootloader 分为两个部分 preloader ，依赖平台 LK（little kernel），作用和 uboot 类似，依赖操作系统，负责引导 linux 系统和 Android 框架 我们结合前面的那张图，更加详细的看一下启动过程中 Bootloader 部分的动作： 设备上电，BootROM 开始运行。 BootROM 初始化软件堆栈 （SoftwareStack）、通信端口和可引导存储设备（NAND/EMMC）。 BootROM 从存储器中加载 pre-loader 到内部 SRAM（ISRAM）中，因为这时候还没有初始化外部的 DRAM。 BootROM 跳转 pre-loader 入口并执行。 pre-loader 初始化 DRAM 并加载 u-boot 到 RAM中 pre-loader 跳转到 u-boot 中执行，u-boot 开始做初始化，比如显示初始化 u-boot 从存储器中加载引导镜像（boot image）包括 linux kernel 和 ramdisk u-boot 跳转到 linux kernel 并执行。 2.1 preloader 启动过程2.1.1 preloader 的功能 负责在芯片组平台准备好可执行环境 如果检测到外部工具，会试图通过 uart 或者 usb 与外部工具握手 从 NAND/EMMC 加载 u-boot ，并跳转到 u-boot 使用工具握手,设备能够触发进入下载模式来下载需要的镜像,或是进入工厂/测试模式,比如 META 模式和 ATE 工厂模式,在这些模式下可以测试模块,或是通过传递引导参数给 U-Boot 和 linux kernel 来校准设备 (device calibration)preloader 中的硬件部分PLL 模块调整处理器和外部内存频率。PLL 模块初始化后，处理器和外部内存的频率由 26MHZ/26MHZ 增加到 1GHZ/192MHZ。 UART 模块用于调试或是 META 模式下的握手。默认情况下 UART4 初始化波特率为 9216000bps ，用于调试信息输出。UART1 初始化为 115200bps 和作为 UART META 默认端口。不过 UART1 也可以被作为调试或者是 UART META 端口。 计时器 timer 模块用于计算硬件模块所需要的延时或是超时时间。 内存模块preloader 由 bootROM 加载和芯片组内部的 SRAM 中执行，因为外部的 DRAM 还没有初始化。接下来 preloader 采用内置的内存设置来初始化 DRAM，这样 u-boot 就可以被加载到 DRAM 中并执行。 GPIO PMIC RTC当通过 power 按键开机后，preloader 拉高 RTC 的 PWBB 来保持设备一直有电，并继续引导 u-boot。RTC alarm 可能是设备开机的启动源，这种情况，设备不需要按 power 按键就可以自启动。 USB NAND MSDCpre-loader 可以从 NAND Flash 或者是 EMMC 中加载 u-boot，两种选其一 2.1.2 preloader 启动代码代码流程如下图： 2.2 LK 启动过程LK （Little Kernel）也是一种 bootloader ，作用和 u-boot 差不多。MTK它由 preloader 引导并执行，因为 preloader 中已经完成了硬件模块，所以不需要在 lk 中重新配置这些模块了。但部分模块会在 lk 中重新被复位来配置硬件寄存器，这样可以创造一个干净的环境。比如计时器模块，在 lk 中，timer 被重新复位清零硬件计数来对计时进行复位。 2.2.1 LK 中的上电情景LK 加载后，电池将检查 power 按键是否按下，如果当前启动的原因是 USB 充电器，而不是 power 按键，电池模块将等待用户按下 power 按键启动;12// lk/platform/mt6735/mtk_key.cBOOL mtk_detect_key(unsigned short key) /* key: HW KeyCode */ key 表示要检查的按键码，返回值表示这个按键是否按下，此函数来判断指定的按键是否按下。 2.2.2 LK 中的充电情景 2.2.3 LK 中的其他启动模式Factory mode出厂模式，用于批量生产 META modeMETA 模式，用于批量生产的功能性测试 Advanced META modeMETA 高级模式，用于批量生产时的功能性测试，用以测试多媒体功能，和 android 启动共存恢复模式，用于 SD 卡镜像升级 ATE Factory boot自动测试环境出场模式。通过 PC 的 ATE 工具发送命令测试产品特性。 Alarm bootRTC 闹钟启动 Fastboot刷机 download boot下载时，支持 logo 显示 sw reboot启动原因是重启 2.2.4 LK 启动代码代码流程如下图： lk/arch/arm/crt0.S lk/kernel/main.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/* called from crt0.S */void kmain(void) __NO_RETURN __EXTERNALLY_VISIBLE;void kmain(void)&#123;#if !defined(MACH_FPGA) &amp;&amp; !defined(SB_LK_BRINGUP) boot_time = get_timer(0);#endif // get us into some sort of thread context thread_init_early(); // early arch stuff arch_early_init(); // 使能 MMU、cache // do any super early platform initialization platform_early_init(); // 使能 Uart、中断、定时器、DRAM Banks、wot、display#if defined(MACH_FPGA) || defined(SB_LK_BRINGUP) boot_time = get_timer(0);#endif // do any super early target initialization target_early_init(); // 空，可以在这里实现一些定制的超级初始化 dprintf(INFO, \"welcome to lk\\n\\n\"); // deal with any static constructors dprintf(SPEW, \"calling constructors\\n\"); call_constructors(); // bring up the kernel heap dprintf(SPEW, \"initializing heap\\n\"); heap_init(); // initialize the threading system dprintf(SPEW, \"initializing threads\\n\"); thread_init(); // initialize the dpc system dprintf(SPEW, \"initializing dpc\\n\"); dpc_init(); // initialize kernel timers dprintf(SPEW, \"initializing timers\\n\"); timer_init();#ifdef MTK_LK_IRRX_SUPPORT mtk_ir_init(0);#endif#if (!ENABLE_NANDWRITE) // create a thread to complete system initialization dprintf(SPEW, \"creating bootstrap completion thread\\n\"); thread_resume(thread_create(\"bootstrap2\", &amp;bootstrap2, NULL, DEFAULT_PRIORITY, DEFAULT_STACK_SIZE)); // enable interrupts exit_critical_section(); // become the idle thread thread_become_idle();#else bootstrap_nandwrite();#endif&#125; 这里会创建一个 bootstrap2 线程123456789101112131415161718192021222324252627static int bootstrap2(void *arg)&#123; dprintf(SPEW, \"top of bootstrap2()\\n\"); arch_init(); // 空 // XXX put this somewhere else#if WITH_LIB_BIO bio_init();#endif#if WITH_LIB_FS fs_init();#endif // initialize the rest of the platform dprintf(SPEW, \"initializing platform\\n\"); platform_init(); // 启动模式选择电池、显示 Logo、背光打开、设置软件的环境变量 // initialize the target dprintf(SPEW, \"initializing target\\n\"); target_init(); // 空 dprintf(SPEW, \"calling apps_init()\\n\"); apps_init(); return 0;&#125; apps_init //\\bootable\\bootloader\\lk\\app\\app.cstart_appmt_boot_init //bootable\\bootloader\\lk\\app\\mt_boot\\mt_boot.c 如果 g_boot_mode 为 FASTBOOT 就走 fastboot 模式 否则 boot_linux_from_storage() boot_linux_from_storage() 是关键char g_CMDLINE[200] = COMMANDLINE_TO_KERNEL; 这个 COMMANDLINE_TO_KERNEL 定义在 \\lk\\include\\platform\\mt_reg_base.h 三、Linux 内核启动Linux 内核启动一般由外部 bootloader 引导，也可以在头部嵌入一个 loader，这部分和硬件结合紧密，一般由汇编编写。 3.1 zImage 解压内核 zImage 解压缩head.S 首先初始化自解压相关的如内存等环境，接下来调用 decompress_kernel 进行解压（./arch/arm/boot/compressed/misc.c) 3.2 start_kernel 启动start_kernel 启动内核（./init/main.c)start_kernel 是任何版本 Linux 内核的通用初始化函数，它会初始化很多东西，输出 Linux 版本信息、设置体系结构相关的环境，页表结构初始化，设置系统自陷入口，初始化系统 IRQ，初始化核心调度器等。最后调用 rest_init 3.3 rest_init 调用 kernel_init启动 init 进程执行 schedule 开始任务调度。这个 init 是由 android 的 ./system/core/init 下的代码编译出来的，由此进入了 android 代码。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"},{"name":"MediaTek","slug":"MediaTek","permalink":"http://iyounix.com/tags/MediaTek/"}]},{"title":"Android 反编译 Android APK","slug":"Android_App/[Android] 反编译 Android APK","date":"2018-03-31T15:33:05.000Z","updated":"2018-11-08T03:28:16.980Z","comments":true,"path":"2018/03/31/Android_App/[Android] 反编译 Android APK/","link":"","permalink":"http://iyounix.com/2018/03/31/Android_App/[Android] 反编译 Android APK/","excerpt":"","text":"https://blog.csdn.net/m0_37433067/article/details/79717253 工具（Ubuntu平台下）：a. apktool: 主要将apk中，资源文件及XML文件进行反编译。https://download.csdn.net/download/m0_37433067/10311837b.dex2jar：将dex文件转为jar包及.class文件https://download.csdn.net/download/m0_37433067/10311848c.jd-gui-0.3.3.linux.i686: jar\\dex.samil源码查看工具https://download.csdn.net/download/m0_37433067/10311855工具准备完成。解压好几个文件。使用到解压软件，安装unzip与zip我不过多说明 步骤1. dex2jar.apk 解压, 获取 classes.dex 文件./dex2jar.sh classes.dex 2. jd-gui$ sudo apt-get install libgtk2.0-0:i386$ ./jd-guiopen file 可以看到源码 3. apktool./apktool d -f xxx.apk获取资源文件res","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 修改浏览器默认主页","slug":"Android_App/[Android6.0][RK3399] 修改浏览器默认主页","date":"2018-03-31T15:33:05.000Z","updated":"2018-11-08T03:27:20.996Z","comments":true,"path":"2018/03/31/Android_App/[Android6.0][RK3399] 修改浏览器默认主页/","link":"","permalink":"http://iyounix.com/2018/03/31/Android_App/[Android6.0][RK3399] 修改浏览器默认主页/","excerpt":"","text":"OS: Android6.0Hardware: RK3399 修改默认主页在如下文件packages/apps/Browser/res/values/strings.xml 123&lt;!-- The default homepage. --&gt; &lt;string name=&quot;homepage_base&quot; translatable=&quot;false&quot;&gt; https://www.google.com/webhp?client=&#123;CID&#125;&amp;amp;source=android-home&lt;/string&gt; 修改一个你喜（tao）欢（yan）的主页比如百度：123 &lt;!-- The default homepage. --&gt; &lt;string name=&quot;homepage_base&quot; translatable=&quot;false&quot;&gt; https://www.baidu.com/&lt;/string&gt;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"},{"name":"MediaTek","slug":"MediaTek","permalink":"http://iyounix.com/tags/MediaTek/"}]},{"title":"Android6.0 MTK6737 系统旋转后导航栏丢失，并有黑边","slug":"Android_App/[Android6.0][MTK6737] 系统旋转后导航栏丢失，并有黑边","date":"2018-03-31T15:33:05.000Z","updated":"2018-11-08T03:26:39.852Z","comments":true,"path":"2018/03/31/Android_App/[Android6.0][MTK6737] 系统旋转后导航栏丢失，并有黑边/","link":"","permalink":"http://iyounix.com/2018/03/31/Android_App/[Android6.0][MTK6737] 系统旋转后导航栏丢失，并有黑边/","excerpt":"","text":"Hardware:MT6737DeviceOS:Android6.0Kernel: Linux3.18HostOS: Ubuntu16.04 [TOC] 这个是横屏后遇到的一个问题，当航Bar只看到黑条，在屏幕0/180度时点击无效，90/270度时点黑条的任何地方底部会有Glow的光晕效果和震动效果，但是键值全都是recentApp。 修改方法如下：SystemUI 的 navigation_bar 布局文件中，横屏布局和竖屏布局调换，就可以正常显示了。 12345678910111213141516171819202122232425diff --git a/base/packages/SystemUI/res/layout/navigation_bar.xml b/base/packages/SystemUI/res/layout/navigation_bar.xmlindex c92ba45..2e59921 100644--- a/base/packages/SystemUI/res/layout/navigation_bar.xml+++ b/base/packages/SystemUI/res/layout/navigation_bar.xml@@ -26,7 +26,7 @@ android:background=&quot;@drawable/system_bar_background&quot; &gt; - &lt;FrameLayout android:id=&quot;@+id/rot0&quot;+ &lt;FrameLayout android:id=&quot;@+id/rot90&quot; android:layout_height=&quot;match_parent&quot; android:layout_width=&quot;match_parent&quot; &gt;@@ -176,10 +176,10 @@ /&gt; &lt;/FrameLayout&gt; - &lt;FrameLayout android:id=&quot;@+id/rot90&quot;+ &lt;!-- Debug for navigation_bar disappear after rotation 270 --&gt;+ &lt;FrameLayout android:id=&quot;@+id/rot0&quot; android:layout_height=&quot;match_parent&quot; android:layout_width=&quot;match_parent&quot;- android:visibility=&quot;gone&quot; android:paddingTop=&quot;0dp&quot; &gt; 隐藏如果想要隐藏，可以通过 qemu.hw.mainkeys=1 实现。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"},{"name":"MediaTek","slug":"MediaTek","permalink":"http://iyounix.com/tags/MediaTek/"}]},{"title":"Android6.0 App 添加系统权限","slug":"Android_App/[Android6.0][MTK6737] App 添加系统权限","date":"2018-03-31T15:33:05.000Z","updated":"2018-11-08T03:26:15.960Z","comments":true,"path":"2018/03/31/Android_App/[Android6.0][MTK6737] App 添加系统权限/","link":"","permalink":"http://iyounix.com/2018/03/31/Android_App/[Android6.0][MTK6737] App 添加系统权限/","excerpt":"","text":"Hardware:MT6737DeviceOS:Android6.0Kernel: Linux3.18HostOS: Ubuntu16.04 Android 权限规则介绍1. apk 的签名这种签名不是基于权威证书的，不会决定某个应用允不允许安装，而是一种自签名证书。重要的是，android系统有的权限是基于签名的。比如：system等级的权限有专门对应的签名，签名不对，权限也就获取不到。默认生成的APK文件是 debug 签名的。获取system权限时用到的签名见后面描述。 2. 基于UserID的进程级别的安全机制进程有独立的地址空间，进程与进程间默认是不能互相访问的，Android通过为每一个apk分配唯一的linux userID来实现，名称为”app_”加一个数字，比如app_43不同的UserID，运行在不同的进程，所以apk之间默认便不能相互访问。 Android提供了如下的一种机制，可以使两个apk打破前面讲的这种壁垒。在AndroidManifest.xml 中利用 sharedUserId 属性给不同的 package 分配相同的 userID，通过这样做，两个package可以被当做同一个程序，系统会分配给两个程序相同的UserID。当然，基于安全考虑，两个apk需要相同的签名，否则没有验证也就没有意义了。 3. 默认apk生成的数据对外是不可见的实现方法是：Android会为程序存储的数据分配该程序的 UserID。借助于Linux严格的文件系统访问权限，便实现了apk之间不能相互访问似有数据的机制。例：我的应用创建的一个文件，默认权限如下，可以看到只有UserID为app_21的程序才能读写该文件。1 -rw------- app_21 app_21 87650 2000-01-01 09:48 test.txt 那么如何对外开放呢？ 使用MODE_WORLD_READABLE and/or MODE_WORLD_WRITEABLE标记。 When creating a new file with getSharedPreferences(String, int), openFileOutput(String, int), or openOrCreateDatabase(String, int, SQLiteDatabase.CursorFactory), you can use the MODE_WORLD_READABLE and/or MODE_WORLD_WRITEABLE flags to allow any other package to read/write the file. When setting these flags, the file is still owned by your application, but its global read and/or write permissions have been set appropriately so any other application can see it. 4. AndroidManifest.xml中的显式权限声明Android默认应用是没有任何权限去操作其他应用或系统相关特性的，应用在进行某些操作时都需要显式地去申请相应的权限。在应用安装的时候，package installer会检测该应用请求的权限，根据该应用的签名或者提示用户来分配相应的权限。在程序运行期间是不检测权限的。如果安装时权限获取失败，那执行就会出错，不会提示用户权限不够。大多数情况下，权限不足导致的失败会引发一个 SecurityException，会在系统log（system log）中有相关记录。 5. 权限继承 / UserID继承当我们遇到 apk 权限不足时，我们有时会考虑写一个linux程序，然后由apk调用它去完成某个它没有权限完成的事情，很遗憾，这种方法是行不通的。前面讲过，android权限是在进程层面的，也就是说一个apk应用启动的子进程的权限不可能超越其父进程的权限（即apk的权限），即使单独运行某个应用有权限做某事，但如果它是由一个apk调用的，那权限就会被限制。实际上，android是通过给子进程分配父进程的UserID实现这一机制的。 常见权限不足问题分析首先要知道，普通apk程序是运行在非root、非system层级的，也就是说看要访问的文件的权限时，看的是最后三位。另外，通过system/app安装的apk的权限一般比直接安装或adb install安装的apk的权限要高一些。 言归正传，运行一个android应用程序过程中遇到权限不足，一般分为两种情况: 1. Log中可明显看到权限不足的提示。此种情况一般是AndroidManifest.xml中缺少相应的权限设置，好好查找一番权限列表，应该就可解决，是最易处理的情况。有时权限都加上了，但还是报权限不足，是什么情况呢？Android系统有一些API及权限是需要apk具有一定的等级才能运行的。比如 SystemClock.setCurrentTimeMillis()修改系统时间，WRITE_SECURE_SETTINGS权限好像都是需要有system级的权限才行，也就是说UserID是system. 2. Log里没有报权限不足，而是一些其他Exception的提示,这也有可能是权限不足造成的。比如：我们常会想读/写一个配置文件或其他一些不是自己创建的文件，常会报java.io.FileNotFoundException错误。系统认为比较重要的文件一般权限设置的也会比较严格，特别是一些很重要的(配置)文件或目录。如12 -r--r----- bluetooth bluetooth 935 2010-07-09 20:21 dbus.conf drwxrwx--x system system 2010-07-07 02:05 data dbus.conf好像是蓝牙的配置文件，从权限上来看，根本就不可能改动，非bluetooth用户连读的权利都没有。/data目录下存的是所有程序的私有数据，默认情况下android是不允许普通apk访问/data目录下内容的，通过data目录的权限设置可知，其他用户没有读的权限。所以adb普通权限下在data目录下敲ls命令，会得到opendir failed, Permission denied的错误，通过代码file.listfiles()也无法获得data目录下的内容。上面两种情况，一般都需要提升apk的权限，目前我所知的apk能提升到的权限就是system。 应用获取 system 和 root 权限1. 获取 system 权限1) AndroidManifest.xml 中添加 android:sharedUserId=&quot;android.uid.xxx&gt;eg. 给apk添加system权限123&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;... ... android:sharedUserId=&quot;android.uid.system&quot;&gt; 2) 在对应的 Android.mk 中添加 LOCAL_CERTIFICATE := platform这个动作的目的是为了使用 platform key(platform.pk8 和 platform.x509.pem) 进行签名通过这种方式只能使 apk 的权限升级到 system 级别, 对于需要 root 权限才能访问的文件, apk 还是无法访问. 3) mm 命令编译 另外还有一种方式是独立给 apk 签名, 上面第一步不变 , 第二步是使用目标系统的 Platform 密钥文件重新给 apk 文件签名: 1) 首先找到密钥文件，在Android源码目录中的位置是”build/target/product/security”，下面的platform.pk8和platform.x509.pem两个文件 2) 然后用Android提供的Signapk工具来签名，signapk的源代码是在”build/tools/signapk”下，编译后在out/host/linux-x86/framework下，命令为1java -jar signapk.jar platform.x509.pem platform.pk8 input.apk output.apk 获取 root 权限在 apk 如果想要使用 root 权限可以在程序中通过运行 shell 脚本 / Linux 下的程序实现. 参考 https://blog.csdn.net/dearsq/article/details/78788022 去掉第三方应用的申请权限弹窗比如我的 App 需要 Camera 和 Recorder 权限:12&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt; frameworks/base/services/core/java/com/android/server/pm/DefaultPermissionGrantPolicy.java是用来控制 App 权限的.在其中添加系统 APP 所带权限, 第一次开机后就会将该权限赋予 App. 123456789 PackageParser.Package AiiagePackage = getPackageLPr( &quot;com.android.Aiiage&quot;); if (AiiagePackage != null) &#123;Log.d(TAG, &quot;AiiagePackage &gt;&gt; not null&quot;); grantRuntimePermissionsLPw(AiiagePackage, CAMERA_PERMISSIONS, userId); grantRuntimePermissionsLPw(AiiagePackage, MICROPHONE_PERMISSIONS, userId); &#125;else&#123; Log.d(TAG, &quot;AiiagePackage &gt;&gt; null&quot;); &#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"},{"name":"MediaTek","slug":"MediaTek","permalink":"http://iyounix.com/tags/MediaTek/"}]},{"title":"Android6.0 MTK6737 替换原生 Launcher","slug":"Android_App/[Android6.0][MTK6737] 替换原生 Launcher","date":"2018-03-31T15:33:05.000Z","updated":"2018-11-08T03:26:05.536Z","comments":true,"path":"2018/03/31/Android_App/[Android6.0][MTK6737] 替换原生 Launcher/","link":"","permalink":"http://iyounix.com/2018/03/31/Android_App/[Android6.0][MTK6737] 替换原生 Launcher/","excerpt":"","text":"屏蔽 Launcher3 中的 category123&lt;!-- category android:name=&quot;android.intent.category.HOME&quot; --&gt;&lt;!-- category android:name=&quot;android.intent.category.LAUNCHER&quot; --&gt;&lt;!-- category android:name=&quot;android.intent.category.DEFAULT&quot; --&gt; 在自己的 App 中添加以上三个 category123&lt;category android:name=&quot;android.intent.category.HOME&quot; /&gt;&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"},{"name":"MediaTek","slug":"MediaTek","permalink":"http://iyounix.com/tags/MediaTek/"}]},{"title":"Android6.0 修改默认允许位置来源第三方应用安装","slug":"Android_App/[Android6.0][MTK6737] 修改默认允许位置来源第三方应用安装","date":"2018-03-31T15:33:05.000Z","updated":"2018-11-08T03:26:26.424Z","comments":true,"path":"2018/03/31/Android_App/[Android6.0][MTK6737] 修改默认允许位置来源第三方应用安装/","link":"","permalink":"http://iyounix.com/2018/03/31/Android_App/[Android6.0][MTK6737] 修改默认允许位置来源第三方应用安装/","excerpt":"","text":"Date: Tue May 8 11:48:00 2018 +0800 修改默认允许位置来源第三方应用安装 Change-Id: Ic8526ec6483afcd60b9e6deed86d42acb2f014e3 diff –git a/base/packages/SettingsProvider/res/values/defaults.xml b/base/packages/SettingsProvider/res/values/defaults.xmlindex 645561c..8644de1 100644— a/base/packages/SettingsProvider/res/values/defaults.xml+++ b/base/packages/SettingsProvider/res/values/defaults.xml@@ -37,7 +37,7 @@ &lt;bool name=&quot;def_bluetooth_on&quot;&gt;false&lt;/bool&gt; &lt;bool name=&quot;def_wifi_display_on&quot;&gt;false&lt;/bool&gt; false truetrue&lt;!– Comma-separated list of location providers.Network location is off by default because it requires","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"},{"name":"MediaTek","slug":"MediaTek","permalink":"http://iyounix.com/tags/MediaTek/"}]},{"title":"Android6.0 MTK6737 版本控制和开发流程说明","slug":"Android_Driver/Driver/[Android6.0][MTK6737]版本控制和开发流程说明","date":"2018-03-31T15:33:05.000Z","updated":"2018-11-08T02:34:50.400Z","comments":true,"path":"2018/03/31/Android_Driver/Driver/[Android6.0][MTK6737]版本控制和开发流程说明/","link":"","permalink":"http://iyounix.com/2018/03/31/Android_Driver/Driver/[Android6.0][MTK6737]版本控制和开发流程说明/","excerpt":"","text":"[TOC] 本地编译注册 gitlab 桂成在服务器 10.0.0.3:9000 上搭建了 Gitlab，需要先进行注册 http://10.0.0.3:9000/users/sign_in 桂成将开发者赋予 Developer 或者 Master 权限，并拉进 Group MTK6737_Android6.0 添加 Gitlab 对本地机器的认证 via SSH_Keys 参照如下命令生成 私钥和公钥对（YounixPC 和 YounixPC.pub）。 12345678910111213141516171819202122$ cd ~/.ssh/$ ssh-keygen -t rsa -C \"zhang.yang@aiiage.com\"Generating public/private rsa key pair.Enter file in which to save the key (/home/younix/.ssh/id_rsa): YounixPCEnter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in YounixPC.Your public key has been saved in YounixPC.pub.The key fingerprint is:SHA256:u1BNH8tBqdTx49cEGtCESAMfhvSahhmdXhhCVVXIC7M zhang.yang@aiiage.comThe key's randomart image is:+---[RSA 2048]----+| .oo==*+oO*o. || o.B+o=.++ . || . + +=.o+ o .|| = +Eooo = o.|| o = S . + . o|| . . . . || . . || . . || . |+----[SHA256]-----+ 点击 Gitlab 网站 http://10.0.0.3:9000/ 右上角头像下的子菜单中的 Setting 选项 在左侧菜单中找到 SSH_Keys 标签并点击之 将公钥 YounixPC.pub 中的内容复制到 Key 一栏中 提交后即添加认证完成。 同步代码MTK6737 Android6.0 的代码已经采用 repo 进行管理。http:10.0.0.3:9000/MTK6737_Android6.0123$ cd ~/SDK/MTK/MTK6737_Android6.0$ repo init -u http://10.0.0.3:9000/MTK6737_Android6.0/repo.git --repo-url=https://github.com/dearsq/repo -b master$ repo sync 期间需要输入若干次 Gitlab 的帐号和密码。 //TODO: 添加自动认证 开发流程SDK 被划分为 28 个子 git 仓库，使用 repo 管理。 各模块开发遵循 git 规范。 开发完后本地编译烧录验证，验证通过后即可 git push ，无需提交 PR。所以请保证代码规范 / 无 Bug。 服务器编译服务器中，SDK 的目录为 /home/aiiage/WorkSpace/02.SDK/alps。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"},{"name":"MediaTek","slug":"MediaTek","permalink":"http://iyounix.com/tags/MediaTek/"}]},{"title":"Android6.0 MTK6737 移植 Modem","slug":"Environment/MTK6737/[Android6.0][MTK6737] 移植 Modem","date":"2018-03-31T15:33:05.000Z","updated":"2018-11-08T02:14:01.760Z","comments":true,"path":"2018/03/31/Environment/MTK6737/[Android6.0][MTK6737] 移植 Modem/","link":"","permalink":"http://iyounix.com/2018/03/31/Environment/MTK6737/[Android6.0][MTK6737] 移植 Modem/","excerpt":"","text":"Hardware:MT6737DeviceOS:Android6.0Kernel: Linux3.18HostOS: Ubuntu16.04 一 移植步骤1. 先解压 modem 压缩包2. 安装 modem 编译需要的环境123456789*******************************************recommended Build Environment******************************************** [OS] : Linux* [PERL] : v5.10.1 or v5.14.2* [MAKE] : GNU Make v3.81* [SHELL] : GNU bash v4.1.5* [GCC-ARM-NONE-EABI] : v4.6.2 or above* [NATIVE GCC(UBUNTU)]: v4.5 or above 3. 进行编译12345678910111213141516171819202122232425262728293031323334353637383940414243younix@younixVB:~/WorkSpace2/MTK6737/mcu$ ./make.sh &quot;BR6737M_65_S_M0(LTG_DSDS).mak&quot; new*******************************************recommended Build Environment******************************************** [OS] : Linux* [PERL] : v5.10.1 or v5.14.2* [MAKE] : GNU Make v3.81* [SHELL] : GNU bash v4.1.5* [GCC-ARM-NONE-EABI] : v4.6.2 or above* [NATIVE GCC(UBUNTU)]: v4.5 or aboveproject_name = BR6737M_65_S_M0flavor = LTG_DSDSclean build/BR6737M_65_S_M0/LTG_DSDS/tmp/*.*concatenate make/modem_spec/MTK_MODEM_LTG.makconcatenate make/custom_config/BR6737M_65_S_M0(LTG_DSDS)_EXT.makconcatenate_proj_mak = build/BR6737M_65_S_M0/LTG_DSDS/bin/~BR6737M_65_S_M0(LTG_DSDS).mak*******************************************recommended Build Environment******************************************** [OS] : Linux* [PERL] : v5.10.1 or v5.14.2* [MAKE] : GNU Make v3.81* [SHELL] : GNU bash v4.1.5* [GCC-ARM-NONE-EABI] : v4.6.2 or above* [NATIVE GCC(UBUNTU)]: v4.5 or above******************************************* Start checking current Build Environment ******************************************** [PERL] : v5.18.2 [NOT RECOMMENDED] !!!* [MAKE] : GNU Make v3.81 [OK] !!!* [SHELL] : GNU bash v4.3.11 [HIGHER THAN RECOMMENDED] !!!sh: 1: tools/GCC/4.6.2/linux/bin/arm-none-eabi-gcc: not found* [GCC-ARM-NONE-EABI] : [UNKNOWN VERSION] !!!* [NATIVE GCC(UBUNTU)]: gcc (Ubuntu/Linaro 4.6.4-6ubuntu2) 4.6.4 [OK] !!!current Build Env. is not recommendation To avoid unexpected errors , please install the recommended Tool Chain.******************************************* Build Environment is NOT RECOMMENDED!******************************************* 4. 拷贝 modem 固件到 alps SDK 中接下来利用 pl 脚本自动重命名 modem 固件.1perl device/mediatek/build/build/tools/modemRenameCopy.pl ../modem &quot;BR6737M_65_S_M0(LTG_DSDS)&quot; 这个脚本会自动将 ../modem 中的内容 copy 并 rename 到 vendor 中的 modem 子目录中, 并构建 Android.mk 错误汇总ia32-libs1234567start Drv feature check...get feature list from drv_features.h...get feature list from drv_features_option.h...generate feature check file...validate features...infoFilename = ././build/BR6737M_65_S_M0/LTG_DSDS/bin/log/info.logmake: *** [drv_feature_check] Error 1 关键错误在sh: 1: tools/GCC/4.6.2/linux/bin/arm-none-eabi-gcc: not found 但是实际上该路径是有此 编译工具链的. 原因在于我们所使用的ubuntu应该是64位的，而运行的可执行程序是32位的，问题就出在这里，我们需要安装’’ia32-libs’’， 具体命令就是 sudo apt-get install ia32-libs.会进一步提示 , 软件包已经被替代了, 我们改为安装 lib32z112345However the following packages replace it: lib32z1 lib32ncurses5 lib32bz2-1.0E: Package &apos;ia32-libs&apos; has no installation candidateyounix@younixVB:~/WorkSpace2/MTK6737/mcu$ sudo apt-get install lib32z1 libgcc_s.so.11error while loading shared libraries: libgcc_s.so.1 解决方法:sudo apt install gcc-multilib libstdc++.so.612./build/BR6737M_65_S_M0/LTG_DSDS/bin/log/DbgInfoGen.logtools/DbgInfoGen: error while loading shared libraries: libstdc++.so.6: cannot open shared object file: No such file or directory 解决方法:1sudo apt-get install lib32stdc++6 参考脚本1234567891011121314151617181920212223242526272829303132333435363738#!/bin/bash# $1 -- TAG stringfunction print_err()&#123; echo -e &quot;\\e[0;31;1m$1\\e[0m&quot;&#125;function print_war()&#123; echo -e &quot;\\e[0;33;1m$1\\e[0m&quot;&#125;function print_log()&#123; echo -e &quot;\\e[0;32;1m$1\\e[0m&quot;&#125;export -f print_errexport -f print_warexport -f print_logif [ ! -d &quot;./BINS&quot; ]; then print_log &quot;mkdir -p ./BINS&quot; mkdir -p ./BINSfi#print_err &quot;please switch gcc to 4.4.3 ++++&quot;./make.sh BR6735_65C_L1\\(LTTG_DSDS\\).mak new./../modemRenameCopy.pl . BR6735_65C_L1\\(LTTG_DSDS\\)mv temp_modem ./BINS/temp_modem_lttg_$1./make.sh BR6735_65C_L1\\(LWG_DSDS\\).mak new./../modemRenameCopy.pl . BR6735_65C_L1\\(LWG_DSDS\\)mv temp_modem ./BINS/temp_modem_lwg_$1#print_err &quot;please switch gcc to 4.4 ----&quot;#sudo /root/switchGCC.shtar cjvpf ./BINS/temp_modem_$1.tar.bz2 ./BINS/temp_modem_lttg_$1 ./BINS/temp_modem_lwg_$1exit 0","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"},{"name":"MediaTek","slug":"MediaTek","permalink":"http://iyounix.com/tags/MediaTek/"}]},{"title":"Android6.0 MTK6737 优化开机启动时间","slug":"Android_Sys/[Android6.0][MTK6737] 优化开机启动时间","date":"2018-03-31T15:33:05.000Z","updated":"2018-11-08T02:24:30.733Z","comments":true,"path":"2018/03/31/Android_Sys/[Android6.0][MTK6737] 优化开机启动时间/","link":"","permalink":"http://iyounix.com/2018/03/31/Android_Sys/[Android6.0][MTK6737] 优化开机启动时间/","excerpt":"","text":"Hardware:MTK6737DeviceOS:Android6.0Kernel: Linux3.18HostOS: Ubuntu16.04 [TOC] Google 的文档:https://source.android.com/devices/tech/perf/boot-times 一 Zygote 部分优化预加载class、resources；加载的多了，会影响开机时间；./mobilelog/APLog_2015_0101_000107/bootprof12345678910111213141516171819202122 47630.014113 : Zygote:Preload Start 47790.882882 : Zygote:Preload Start 58315.969138 : Zygote:Preload 3831 classes in 8957ms 58590.519831 : Zygote:Preload 3831 classes in 9260ms 59647.350141 : Zygote:Preload 342 obtain resources in 1327ms 59693.352987 : Zygote:Preload 41 resources in 44ms 59935.724526 : Zygote:Preload 342 obtain resources in 1341ms 59976.014450 : Zygote:Preload 41 resources in 38ms 60671.346067 : Zygote:Preload End 61208.389453 : Zygote:Preload End 63385.657304 : Android:SysServerInit_START ## 用时 17-6=11s 66214.698003 : Android:PackageManagerService_Start 66652.701927 : Android:PMS_scan_START 84856.281124 : Android:PMS_scan_data_done:/system/framework111793.129112 : Android:PMS_scan_data_done:/system/priv-app145123.168422 : Android:PMS_scan_data_done:/system/app154266.032828 : Android:PMS_scan_data_done:/system/vendor/operator/app155273.061292 : Android:PMS_scan_data_done:/system/plugin155287.398831 : Android:PMS_scan_data_done:/data/app160380.926612 : Android:PMS_scan_END162821.175926 : Android:PMS_READY176850.152113 : Android:SysServerInit_END 1.1 裁剪加载类./frameworks/base/preloaded-classes 少加载会影响 App 启动速度 , 此地优化空间不大./frameworks/base/core/res/ 会被打包成 framework-res.apk，确保没有冗余的资源图片，可以挨个检查图片、XML是否在系统中有用到； 二 Build 预提取 odex通常手机升级后会显示 正在优化第*个应用，总共 * 个应用 这个就是在对 APK 做 dexopt 的优化。 odex 是 APK 中提取出来的可运行文件.APK 中的 class.dex 会在 dex 优化过程众被转化为 odex 文件存放. 正常的开机过程中 , 系统需要在开机过程中从 APK 提取 dex 再运行.所以我们可以在 Build 过程中预先提取 dex 将其优化为 odex , 进而达到加快启动速度的目的. 2.1 对于内置 SourceCode 的 APK在Android.mk中都会通过include $(BUILD_PACKAGE)来编译，会调用到package.mk来提取 odex. 2.2 对于通过 prebuilt 方式内置的 APK通过 prebuilt 方式预置的 APK , 默认不会被提取 odex. 2.3 设置方法2.3.1 对于 App 的Android.mk1LOCAL_DEX_PREOPT := false 如果设置为 false 可以使整个系统使用提前优化的时候，某个app不使用提前优化。如果设置为 true 则编译生成的文件有 oat 文件, 即在 build 过程中被提前优化. 2.3.2 对于 system.img 如果设置了:1WITH_DEXPREOPT := true 打开这个宏之后，无论是有源码还是无源码的预置apk预编译时都会提取odex文件。如有发现user版本未提取odex，请检查device.mk文件配置：1234ifeq ($(TARGET_BUILD_VARIANT),user) WITH_DEXPREOPT := true DONT_DEXPREOPT_PREBUILTS := true //此句注释掉endif 对于64bit的芯片,若apk只有32bit的lib或者只能作为32bit运行，请在预置apk时在android.mk中添加下边的TAG标记此apk为32bit：1LOCAL_MULTILIB :=32 但是这个会导致 system.img 中的所有东西都被 pre-optimized , 即 system.img 会变得很大. 此时可能需要调大 system.img 的大小限制.在编译的时候，/system/framework/ 目录下面的jar包，和 /system/app，/system/priv-app/，/system/vendor/app 下面的apk文件，都会在编译时，做odex优化。 2.3.3 对于 jar 包 , 如果不想jar包做odex优化，可以在/buid/core/java_library.mk文件中设置：1LOCAL_DEX_PREOPT := false 这样在编译时，jar包就不会做odex优化。 三 开机动画bootanimation 时间 最好不要超过 system_server 启动时间 (11s) ( 63385.657304 : Android:SysServerInit_START 到 Android:SysServerInit_END) 不要播放 mp3 bootanimation.zip 图片越少越好 四 无用的服务/frameworks/base/services/java/com/android/server/SystemServer.java比如：DropBoxManagerService和调试相关，可以异步加载或者直接阉割掉;比如：PinnerService没有配置相关则可以去除;其他Service可以挨个排查.非必要的服务可以放在 system_server 进程外启动. 五 App 的优化5.1 App 本身优化尽量少把APP设置为persist；优化每一个有源码的persist APP；使他们启动尽可能快；1234com.android.systemui(PersistAP)com.mediatek.ims(PersistAP)com.android.phone(PersistAP)com.android.settings 精简apk包；（1）删除没有用到的，图片、资源文件、没有用到的jar包文件、不需要使用的so文件；（2）预置自己的APP，假如设备只会加载drawable-xxhdpi中的资源，那么可以在drawable包重复的资源可以直接删除；（3）预置自己的APP，假如设置只支持英文，values-da、values-fa这样的多语言支持资源都可以删除；（4）apk中只保留和系统适配的so文件，比如：armv7和arm64的so文件； Application的onCreate方法中不要有耗时的代码段； 通过修改–compiler-filter 为 speed、quick、speed-profile来提高 APK 的启动速度；speed 模式优化的类较多，这时优化后的vdex、odex的文件较大，应用启动过程包括映射apk文件的过程，文件偏大导致有一定的时间损耗；但 speed 模式优化后，Java类执行更快；所以这个需要针对具体的应用多次验证，没有普适性； 5.2 系统 App 裁剪PackageManagerServicescanDirTracedLI（1）减少预置APP的数量（对开机速度会有较为明显的提升）；（2）删除没有必要的apk包；（3）单线程scan分区里面的apk并不一定能充分使用IO资源，尝试改为多线程异步scan；（4）精简系统，把系统中用不到的apk包、有重复功能的apk移除，这样既可以使系统有更大的剩余存储空间又可以减少scan的时间，加快开机； 六 定频定核调高 CPU 频率, 副作用是带来功耗12345678910111213/system/core/rootdir/init.rcon early-init#mtk beginwrite /proc/ppm/policy/ut_fix_core_num &quot;4 4&quot;write /proc/ppm/policy/ut_fix_freq_idx &quot;0 0&quot;#mtk endon property:sys.boot_completed=1bootchart stop#mtk beginwrite /proc/ppm/policy/ut_fix_core_num &quot;-1 -1&quot;write /proc/ppm/policy/ut_fix_freq_idx &quot;-1 -1&quot;#mtk end","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"},{"name":"MediaTek","slug":"MediaTek","permalink":"http://iyounix.com/tags/MediaTek/"}]},{"title":"Android6.0 MTK6737 UVC Camera 移植","slug":"Android_Driver/Driver/[Android6.0][MTK6737]UVC Camera 移植","date":"2018-03-31T15:33:05.000Z","updated":"2018-11-08T02:35:19.068Z","comments":true,"path":"2018/03/31/Android_Driver/Driver/[Android6.0][MTK6737]UVC Camera 移植/","link":"","permalink":"http://iyounix.com/2018/03/31/Android_Driver/Driver/[Android6.0][MTK6737]UVC Camera 移植/","excerpt":"","text":"Hardware:MT6737DeviceOS:Android6.0Kernel: Linux3.18HostOS: Ubuntu16.04 基础知识USB video class（又称为USB video device class or UVC）就是USB device class视频产品在不需要安装任何的驱动程序下即插即用，包括摄像头、数字摄影机、模拟视频转换器、电视卡及静态视频相机。Linux内核之中，已经集成了对UVCCamre的支持。 V4L2Video4Linux或V4L是一个视频截取及设备输出API，以及Linux的驱动程序框架，支持很多USB摄像头、电视调谐卡以及其他设备。简单的讲V4L2就是用来管理UVC设备的并且能够提供视频相关的一些API。那么这些API怎么使用或者能被谁使用呢。在Linux系统上有很多的开源软件能够支持V4L2。常见的又FFmpeg、opencv、Skype、Mplayer等等。 移植步骤内核部分对于 MTK 平台，本身是不支持 UVC Camera 的。但是 Linux 源码中是有进行支持的，所以我们进行相应的修改： 对于 Kernel 若需要打开UVC CAMERA 需要在内核中配置：CONFIG_MEDIA_SUPPORT=yCONFIG_MEDIA_CAMERA_SUPPORT=yCONFIG_VIDEO_DEV=yCONFIG_VIDEO_V4L2=yCONFIG_VIDEOBUF2_CORE=yCONFIG_VIDEOBUF2_MEMOPS=yCONFIG_VIDEOBUF2_VMALLOC=yCONFIG_MEDIA_USB_SUPPORT=yCONFIG_USB_VIDEO_CLASS=yUSB_VIDEO_CLASS_INPUT_EVDEV = y OTG 相关的配置：CONFIG_USB_MTK_OTG=yCONFIG_USB_MTK_HDRC=yCONFIG_USB_MTK_HDRC_HCD=y 权限问题：本以为添加了/dev/video0 0666 root root就可以了，但是，有时候video0会变成video1，第一次打开SimpleWebCam.apk软件的时候，图像正常，之后再次进入SimpleWebCam.apk，就没有图像了。查看了日志信息，显示没有找到设备。在查看root@:/dev #，dev/video0变成了dev/video1！USB摄像头并没有换，为什么会显示dev/video1。修改了SimpleWebCam.apk，使其支持video0~video3，但是日志输出E/WebCam ( 3352): Cannot open ‘/dev/video1’: 13,Permission denied，于是我们的解决方法如下：system/core/rootdir/ueventd.rc 下添加：/dev/video0 0666 root root/dev/video1 0666 root root/dev/video2 0666 root root/dev/video3 0666 root root 安全策略：如果 SeLinux 没有关闭，还需要在 system_app.te 进行如下修改。1allow system_app video_device:chr_file &#123; read write open getattr &#125;; 应用层部分v4l2 - Video for Linux 2，是Linux内核中关于视频设备的内核驱动框架，为上层的访问底层的视频设备提供了统一的接口。同时是针对uvc免驱usb设备的编程框架，主要用于采集 usb 摄像头等。 操作方式在v4l2编程中，一般使用ioctl函数来对设备进行操作：1extern int ioctl (int __fd, unsigned long int __request, …) __THROW; __fd：设备的ID，例如用open函数打开/dev/video0后返回的cameraFd；__request：具体的命令标志符。 在进行V4L2开发中，一般会用到以下的命令标志符：VIDIOC_REQBUFS：分配内存VIDIOC_QUERYBUF：把VIDIOC_REQBUFS中分配的数据缓存转换成物理地址VIDIOC_QUERYCAP：查询驱动功能VIDIOC_ENUM_FMT：获取当前驱动支持的视频格式VIDIOC_S_FMT：设置当前驱动的视频格式VIDIOC_G_FMT：读取当前驱动的视频格式VIDIOC_TRY_FMT：验证当前驱动的视频格式VIDIOC_CROPCAP：查询驱动的修剪能力VIDIOC_S_CROP：设置视频信号的边框VIDIOC_G_CROP：读取视频信号的边框VIDIOC_QBUF：把数据放回缓存队列VIDIOC_DQBUF：把数据从缓存中读取出来VIDIOC_STREAMON：开始视频采集VIDIOC_STREAMOFF：结束视频采集VIDIOC_QUERYSTD：检查当前视频设备支持的标准，例如PAL或NTSC。这些IO调用，有些是必须的，有些是可选择的。 在网上有开源的应用simplewebcam，它已经实现了基本的v4l2视频采集流程。大概看下它是怎么做的 操作流程http://www.hep.by/gnu/kernel/usb/usbfs-ioctl.html 代码实现1. 打开设备驱动节点123456789101112131415161718192021222324int opendevice(int i)&#123; struct stat st; sprintf(dev_name,&quot;/dev/video%d&quot;,i); if (-1 == stat (dev_name, &amp;st)) &#123; LOGE(&quot;Cannot identify &apos;%s&apos;: %d, %s&quot;, dev_name, errno, strerror (errno)); return ERROR_LOCAL; &#125; if (!S_ISCHR (st.st_mode)) &#123; LOGE(&quot;%s is no device&quot;, dev_name); return ERROR_LOCAL; &#125; fd = open (dev_name, O_RDWR); if (-1 == fd) &#123; LOGE(&quot;Cannot open &apos;%s&apos;: %d, %s&quot;, dev_name, errno, strerror (errno)); return ERROR_LOCAL; &#125; return SUCCESS_LOCAL;&#125; 2. 查询驱动功能12345678910111213141516171819202122232425262728int initdevice(void) &#123; struct v4l2_capability cap; struct v4l2_format fmt; unsigned int min; if (-1 == xioctl (fd, VIDIOC_QUERYCAP, &amp;cap)) &#123; if (EINVAL == errno) &#123; LOGE(&quot;%s is no V4L2 device&quot;, dev_name); return ERROR_LOCAL; &#125; else &#123; return errnoexit (&quot;VIDIOC_QUERYCAP&quot;); &#125; &#125; if (!(cap.capabilities &amp; V4L2_CAP_VIDEO_CAPTURE)) &#123; LOGE(&quot;%s is no video capture device&quot;, dev_name); return ERROR_LOCAL; &#125; if (!(cap.capabilities &amp; V4L2_CAP_STREAMING)) &#123; LOGE(&quot;%s does not support streaming i/o&quot;, dev_name); return ERROR_LOCAL; &#125; ......&#125; 3. 设置视频格式123456789101112131415161718int initdevice(void) &#123; struct v4l2_capability cap; struct v4l2_format fmt; ...... CLEAR (fmt); fmt.type = ; fmt.fmt.pix.width = IMG_WIDTH; fmt.fmt.pix.height = IMG_HEIGHT; fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG; if (-1 == xioctl (fd, VIDIOC_S_FMT, &amp;fmt)) return errnoexit (&quot;VIDIOC_S_FMT&quot;); ......&#125; 4. 申请帧缓存并映射到用户空间12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int initmmap(void)&#123; struct v4l2_requestbuffers req; CLEAR (req); req.count = 4; req.type = ; req.memory = V4L2_MEMORY_MMAP; if (-1 == xioctl (fd, VIDIOC_REQBUFS, &amp;req)) &#123; if (EINVAL == errno) &#123; LOGE(&quot;%s does not support memory mapping&quot;, dev_name); return ERROR_LOCAL; &#125; else &#123; return errnoexit (&quot;VIDIOC_REQBUFS&quot;); &#125; &#125; if (req.count &lt; 2) &#123; LOGE(&quot;Insufficient buffer memory on %s&quot;, dev_name); return ERROR_LOCAL; &#125; buffers = calloc (req.count, sizeof (*buffers)); if (!buffers) &#123; LOGE(&quot;Out of memory&quot;); return ERROR_LOCAL; &#125; for (n_buffers = 0; n_buffers &lt; req.count; ++n_buffers) &#123; struct v4l2_buffer buf; CLEAR (buf); buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; buf.memory = V4L2_MEMORY_MMAP; buf.index = n_buffers; if (-1 == xioctl (fd, VIDIOC_QUERYBUF, &amp;buf)) return errnoexit (&quot;VIDIOC_QUERYBUF&quot;); buffers[n_buffers].length = buf.length; buffers[n_buffers].start = mmap (NULL , buf.length, PROT_READ | PROT_WRITE, MAP_SHARED, fd, buf.m.offset); if (MAP_FAILED == buffers[n_buffers].start) return errnoexit (&quot;mmap&quot;); &#125; return SUCCESS_LOCAL;&#125; 需要注意的点调试步骤 通过 lsusb 命令，找到当前 UVC Camera 的 PID 和 VID 123root@br6737m_65_s_m0:/ # lsusbBus 001 Device 007: ID 058f:5608Bus 001 Device 001: ID 1d6b:0002 查看摄像头设备节点是否有生成： 12root@br6737m_65_s_m0:/ # /dev/video*/dev/video0 查看摄像头驱动信息：如果摄像头枚举成功，会输出如下信息： 123456789101112131415161718root@br6737m_65_s_m0:/ # cat /sys/kernel/debug/usb/devicesT: Bus=01 Lev=01 Prnt=01 Port=00 Cnt=01 Dev#= 7 Spd=480 MxCh= 0D: Ver= 2.00 Cls=ef(misc ) Sub=02 Prot=01 MxPS=64 #Cfgs= 1P: Vendor=058f ProdID=5608 Rev= 0.03S: Manufacturer=Alcor Micro, Corp.S: Product=USB 2.0 CameraC:* #Ifs= 2 Cfg#= 1 Atr=80 MxPwr=200mAA: FirstIf#= 0 IfCount= 2 Cls=0e(video) Sub=03 Prot=00I:* If#= 0 Alt= 0 #EPs= 1 Cls=0e(video) Sub=01 Prot=00 Driver=uvcvideoE: Ad=82(I) Atr=03(Int.) MxPS= 16 Ivl=2048msI:* If#= 1 Alt= 0 #EPs= 0 Cls=0e(video) Sub=02 Prot=00 Driver=uvcvideoI: If#= 1 Alt= 1 #EPs= 1 Cls=0e(video) Sub=02 Prot=00 Driver=uvcvideoE: Ad=81(I) Atr=05(Isoc) MxPS=3072 Ivl=125usI: If#= 1 Alt= 2 #EPs= 1 Cls=0e(video) Sub=02 Prot=00 Driver=uvcvideoE: Ad=81(I) Atr=05(Isoc) MxPS=3072 Ivl=125usI: If#= 1 Alt= 3 #EPs= 1 Cls=0e(video) Sub=02 Prot=00 Driver=uvcvideoE: Ad=81(I) Atr=05(Isoc) MxPS=3072 Ivl=125us 查看是否遵循 UVC 协议： 12345678lsusb -d 058f:5608 -v | grep &quot;14 Video&quot;Couldn&apos;t open device, some information will be missing bFunctionClass 14 Video bInterfaceClass 14 Video bInterfaceClass 14 Video bInterfaceClass 14 Video bInterfaceClass 14 Video bInterfaceClass 14 Video 打开/关闭linux uvc driver log sudo echo 0xffff &gt; /sys/module/uvcvideo/parameters/trace 打开sudo echo 0 &gt; /sys/module/uvcvideo/parameters/trace 关闭 利用测试 App 进行测试。 问题汇总1.手机没有对应摄像头，例如手机可能只有两个摄像头，下标从0开始，Camera.open(2)打开的是第3个摄像头就会出问题123456789101112private void openCamera(int cameraFacing) throws RuntimeException &#123; releaseCamera(); Camera.CameraInfo info = new Camera.CameraInfo(); for (int i = 0; i &lt; Camera.getNumberOfCameras(); i++) &#123; Camera.getCameraInfo(i, info); if (info.facing == cameraFacing) &#123; mCamera = Camera.open(i); // 打开对应的摄像头，获取到camera实例 mIsOpened = true; return; &#125; &#125; &#125; 2.应用没有对应权限或者对应权限没有打开。在 AndroidManifest.xml 加上对应权限1&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt; 再检查你的应用对应的权限是否打开3.代码中使用了手机不支持的预览尺寸可以通过如下代码查看你的手机支持的预览尺寸有哪些（不同手机支持的预览大小不一样） 12345List&lt;Size&gt; previewSizes = mCamera.getParameters().getSupportedPreviewSizes(); for (int i = 0; i &lt; previewSizes.size(); i++) &#123; Size psize = previewSizes.get(i); Log.i(TAG + &quot;initCamera&quot;, &quot;PreviewSize,width: &quot; + psize.width + &quot; height: &quot; + psize.height); &#125; 之后查看log就可以看到了 将 USB Camera 插到电脑上，显示如下信息： 123456789101112[810715.631151] usb 1-9: new high-speed USB device number 102 using xhci_hcd[810716.055509] usb 1-9: New USB device found, idVendor=058f, idProduct=5608[810716.055513] usb 1-9: New USB device strings: Mfr=3, Product=1, SerialNumber=0[810716.055516] usb 1-9: Product: USB 2.0 Camera[810716.055519] usb 1-9: Manufacturer: Alcor Micro, Corp.[810716.070201] uvcvideo: Found UVC 1.00 device USB 2.0 Camera (058f:5608)[810716.072748] uvcvideo 1-9:1.0: Entity type for entity Extension 6 was not initialized![810716.072750] uvcvideo 1-9:1.0: Entity type for entity Processing 5 was not initialized![810716.072751] uvcvideo 1-9:1.0: Entity type for entity Selector 4 was not initialized![810716.072752] uvcvideo 1-9:1.0: Entity type for entity Camera 1 was not initialized![810716.072854] input: USB 2.0 Camera: USB 2.0 Camera as /devices/pci0000:00/0000:00:14.0/usb1/1-9/1-9:1.0/input/input31[810751.767560] usb 1-9: USB disconnect, device number 102 MTK 平台默认不支持 YUV 格式的 UVC, 仅支持 MJPEG 格式的 Camera.而且因为 USB ISO 优化做的不够好的原因, 仅仅只能支持 1-2 帧的数据传输.需要合入 USB 2.0 相关的 Patch 才能流畅的(30帧)支持 MJPEG 格式的 UVC camera. 参考Android USB Camera(1) : 调试记录: https://blog.csdn.net/eternity9255/article/details/53069037 https://www.cnblogs.com/sky-heaven/p/7209590.htmlhttp://bbs.raindi.net/thread-9866-1-1.htmlhttps://blog.csdn.net/eternity9255/article/details/53069037https://blog.csdn.net/king_jie0210/article/details/71106720https://blog.csdn.net/panp85/article/details/51087693https://blog.csdn.net/orz415678659/article/details/10022993","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"},{"name":"MediaTek","slug":"MediaTek","permalink":"http://iyounix.com/tags/MediaTek/"}]},{"title":"Android6.0 MTK6737 添加长按Power重启按钮","slug":"Android_App/[Android6.0][MTK6737]添加长按Power重启按钮","date":"2018-03-31T15:33:05.000Z","updated":"2018-11-08T03:27:00.348Z","comments":true,"path":"2018/03/31/Android_App/[Android6.0][MTK6737]添加长按Power重启按钮/","link":"","permalink":"http://iyounix.com/2018/03/31/Android_App/[Android6.0][MTK6737]添加长按Power重启按钮/","excerpt":"","text":"Hardware:MT6737DeviceOS:Android6.0Kernel: Linux3.18HostOS: Ubuntu16.04 [TOC] 添加字符串资源中文资源文件core/res/res/values-zh-rCN/strings.xml123456789101112base/core/res/res/values-zh-rCN/strings.xml@@ -201,6 +201,9 @@ &lt;string name=&quot;shutdown_confirm_question&quot; msgid=&quot;2906544768881136183&quot;&gt;&quot;您要关机吗？&quot;&lt;/string&gt; &lt;string name=&quot;reboot_safemode_title&quot; msgid=&quot;7054509914500140361&quot;&gt;&quot;重新启动并进入安全模式&quot;&lt;/string&gt; &lt;string name=&quot;reboot_safemode_confirm&quot; msgid=&quot;55293944502784668&quot;&gt;&quot;您要重新启动并进入安全模式吗？这样会停用您已安装的所有第三方应用。再次重新启动将恢复这些应用。&quot;&lt;/string&gt;+ &lt;string name=&quot;reboot_title&quot;&gt;&quot;重启&quot;&lt;/string&gt;+ &lt;string name=&quot;reboot_confirm&quot; product=&quot;tablet&quot;&gt;&quot;您的平板电脑将会重启。&quot;&lt;/string&gt;+ &lt;string name=&quot;reboot_confirm&quot; product=&quot;default&quot;&gt;&quot;您的手机将会重启。&quot;&lt;/string&gt; &lt;string name=&quot;recent_tasks_title&quot; msgid=&quot;3691764623638127888&quot;&gt;&quot;近期任务&quot;&lt;/string&gt; &lt;string name=&quot;no_recent_tasks&quot; msgid=&quot;8794906658732193473&quot;&gt;&quot;最近没有运行任何应用&quot;&lt;/string&gt; &lt;string name=&quot;global_actions&quot; product=&quot;tablet&quot; msgid=&quot;408477140088053665&quot;&gt;&quot;平板电脑选项&quot;&lt;/string&gt; 英文资源文件base/core/res/res/values/strings.xml1234567891011121314151617181920212223242526272829diff --git a/base/core/res/res/values/strings.xml b/base/core/res/res/values/strings.xmlindex 370db27..a88e35d 100644--- a/base/core/res/res/values/strings.xml+++ b/base/core/res/res/values/strings.xml@@ -538,6 +538,14 @@ This will disable all third party applications you have installed. They will be restored when you reboot again.&lt;/string&gt; + &lt;!-- Title of dialog to confirm rebooting. --&gt;+ &lt;string name=&quot;reboot_title&quot;&gt;Reboot&lt;/string&gt;++ &lt;!-- Reboot Confirmation Dialog. When the user chooses to reboot the device, there will+ be a confirmation dialog. This is the message. --&gt;+ &lt;string name=&quot;reboot_confirm&quot; product=&quot;tablet&quot;&gt;Your tablet will reboot.&lt;/string&gt;+ &lt;string name=&quot;reboot_confirm&quot; product=&quot;default&quot;&gt;Your phone will reboot.&lt;/string&gt;+ &lt;!-- Recent Tasks dialog: title TODO: this should move to SystemUI.apk, but the code for the old recent dialog is still in the framework@@ -562,6 +570,10 @@ &lt;!-- label for item that turns off power in phone options dialog --&gt; &lt;string name=&quot;global_action_power_off&quot;&gt;Power off&lt;/string&gt; + &lt;!-- label for item that reboots the phone in phone options dialog --&gt;+ &lt;string name=&quot;global_action_reboot&quot;&gt;Reboot&lt;/string&gt;+ &lt;!-- modified by Younix --&gt;+ &lt;!-- label for item that generates a bug report in the phone options dialog --&gt; &lt;string name=&quot;global_action_bug_report&quot;&gt;Bug report&lt;/string&gt; 添加 config.xml123456789base/core/res/res/values/config.xml@@ -2030,6 +2030,7 @@ --&gt; &lt;string-array translatable=&quot;false&quot; name=&quot;config_globalActionsList&quot;&gt; &lt;item&gt;power&lt;/item&gt;+ &lt;item&gt;reboot&lt;/item&gt; &lt;item&gt;bugreport&lt;/item&gt; &lt;item&gt;users&lt;/item&gt; &lt;/string-array&gt; 添加 public.xmlbase/core/res/res/values/public.xml12345678@@ -782,6 +782,7 @@ &lt;public type=&quot;drawable&quot; name=&quot;ic_lock_idle_alarm&quot; id=&quot;0x0108002e&quot; /&gt; &lt;public type=&quot;drawable&quot; name=&quot;ic_lock_lock&quot; id=&quot;0x0108002f&quot; /&gt; &lt;public type=&quot;drawable&quot; name=&quot;ic_lock_power_off&quot; id=&quot;0x01080030&quot; /&gt;+ &lt;public type=&quot;drawable&quot; name=&quot;ic_lock_power_reboot&quot; id=&quot;0x0108009e&quot; /&gt; &lt;public type=&quot;drawable&quot; name=&quot;ic_lock_silent_mode&quot; id=&quot;0x01080031&quot; /&gt; &lt;public type=&quot;drawable&quot; name=&quot;ic_lock_silent_mode_off&quot; id=&quot;0x01080032&quot; /&gt; &lt;public type=&quot;drawable&quot; name=&quot;ic_menu_add&quot; id=&quot;0x01080033&quot; /&gt; 添加 symbols.xmlbase/core/res/res/values/symbols.xml12345678910111213141516171819202122232425@@ -818,6 +818,8 @@ &lt;java-symbol type=&quot;string&quot; name=&quot;reboot_to_update_reboot&quot; /&gt; &lt;java-symbol type=&quot;string&quot; name=&quot;reboot_to_reset_title&quot; /&gt; &lt;java-symbol type=&quot;string&quot; name=&quot;reboot_to_reset_message&quot; /&gt;+ &lt;java-symbol type=&quot;string&quot; name=&quot;reboot_confirm&quot; /&gt;+ &lt;java-symbol type=&quot;string&quot; name=&quot;reboot_title&quot; /&gt; &lt;java-symbol type=&quot;string&quot; name=&quot;reboot_safemode_confirm&quot; /&gt; &lt;java-symbol type=&quot;string&quot; name=&quot;reboot_safemode_title&quot; /&gt; &lt;java-symbol type=&quot;string&quot; name=&quot;relationTypeAssistant&quot; /&gt;@@ -1482,6 +1484,7 @@ &lt;java-symbol type=&quot;drawable&quot; name=&quot;ic_jog_dial_vibrate_on&quot; /&gt; &lt;java-symbol type=&quot;drawable&quot; name=&quot;ic_lock_airplane_mode&quot; /&gt; &lt;java-symbol type=&quot;drawable&quot; name=&quot;ic_lock_airplane_mode_off&quot; /&gt;+ &lt;java-symbol type=&quot;drawable&quot; name=&quot;ic_lock_power_reboot&quot; /&gt; &lt;java-symbol type=&quot;drawable&quot; name=&quot;ic_menu_cc&quot; /&gt; &lt;java-symbol type=&quot;drawable&quot; name=&quot;jog_tab_bar_left_unlock&quot; /&gt; &lt;java-symbol type=&quot;drawable&quot; name=&quot;jog_tab_bar_right_sound_off&quot; /&gt;@@ -1550,6 +1553,7 @@ &lt;java-symbol type=&quot;string&quot; name=&quot;bugreport_status&quot; /&gt; &lt;java-symbol type=&quot;string&quot; name=&quot;faceunlock_multiple_failures&quot; /&gt; &lt;java-symbol type=&quot;string&quot; name=&quot;global_action_power_off&quot; /&gt;+ &lt;java-symbol type=&quot;string&quot; name=&quot;global_action_reboot&quot; /&gt; &lt;java-symbol type=&quot;string&quot; name=&quot;global_actions_airplane_mode_off_status&quot; /&gt; &lt;java-symbol type=&quot;string&quot; name=&quot;global_actions_airplane_mode_on_status&quot; /&gt; &lt;java-symbol type=&quot;string&quot; name=&quot;global_actions_toggle_airplane_mode&quot; /&gt; 添加 drawable添加 iconframeworks\\base\\core\\res\\res\\drawable添加四种分辨率的 reboot 图标 添加 xml core/res/res/drawable/ic_lock_power_reboot.xml123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!-- Copyright (c) 2014, The Linux Foundation. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. * Neither the name of The Linux Foundation nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.--&gt;&lt;bitmap xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:src=&quot;@drawable/ic_lock_power_reboot_alpha&quot; android:tint=&quot;?attr/colorControlNormal&quot; /&gt; 添加代码逻辑1. GlobalActions.java\\frameworks\\base\\core\\res\\res\\values\\symbols.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@@ -40,6 +40,7 @@ import android.net.ConnectivityManager; import android.os.Build; import android.os.Bundle; import android.os.Handler;+import android.os.IPowerManager; import android.os.Message; import android.os.RemoteException; import android.os.ServiceManager;@@ -93,6 +94,7 @@ class GlobalActions implements DialogInterface.OnDismissListener, DialogInterfac /* Valid settings for global actions keys. * see config.xml config_globalActionList */ private static final String GLOBAL_ACTION_KEY_POWER = &quot;power&quot;;+ private static final String GLOBAL_ACTION_KEY_REBOOT = &quot;reboot&quot;; private static final String GLOBAL_ACTION_KEY_AIRPLANE = &quot;airplane&quot;; private static final String GLOBAL_ACTION_KEY_BUGREPORT = &quot;bugreport&quot;; private static final String GLOBAL_ACTION_KEY_SILENT = &quot;silent&quot;;@@ -273,6 +275,9 @@ class GlobalActions implements DialogInterface.OnDismissListener, DialogInterfac &#125; if (GLOBAL_ACTION_KEY_POWER.equals(actionKey)) &#123; mItems.add(new PowerAction());+ &#125; else if (GLOBAL_ACTION_KEY_REBOOT.equals(actionKey)) &#123;+ Log.d(TAG,&quot;add reboot actions&quot;);+ mItems.add(new RebootAction()); &#125; else if (GLOBAL_ACTION_KEY_AIRPLANE.equals(actionKey)) &#123; mItems.add(mAirplaneModeOn); &#125; else if (GLOBAL_ACTION_KEY_BUGREPORT.equals(actionKey)) &#123;@@ -367,6 +372,37 @@ class GlobalActions implements DialogInterface.OnDismissListener, DialogInterfac &#125; &#125;+ private final class RebootAction extends SinglePressAction &#123;+ private RebootAction() &#123;+ super(com.android.internal.R.drawable.ic_lock_power_reboot,+ R.string.global_action_reboot);+ &#125;++ @Override+ public boolean showDuringKeyguard() &#123;+ return true;+ &#125;++ @Override+ public boolean showBeforeProvisioning() &#123;+ return true;+ &#125;++ @Override+ public void onPress() &#123;+ try &#123;+ IPowerManager pm = IPowerManager.Stub.asInterface(ServiceManager+ .getService(Context.POWER_SERVICE));+ pm.reboot(true, null, false);+ &#125; catch (RemoteException e) &#123;+ Log.e(TAG, &quot;PowerManager service died!&quot;, e);+ return;+ &#125;+ &#125;+ &#125;++ 2. ShutdownThread.javabase/services/core/java/com/android/server/power/ShutdownThread.java1234567891011121314151617181920212223242526272829303132333435363738394041-217,13 +217,27 @@ public final class ShutdownThread extends Thread &#123; &#125; &#125; - final int longPressBehavior = context.getResources().getInteger(+ boolean showRebootOption = false;+ String[] defaultActions = context.getResources().getStringArray(+ com.android.internal.R.array.config_globalActionsList);+ for (int i = 0; i &lt; defaultActions.length; i++) &#123;+ if (defaultActions[i].equals(&quot;reboot&quot;)) &#123;+ showRebootOption = true;+ break;+ &#125;+ &#125;++ final int longPressBehavior = context.getResources().getInteger( com.android.internal.R.integer.config_longPressOnPowerBehavior);- final int resourceId = mRebootSafeMode+ //final int resourceId = mRebootSafeMode+ int resourceId = mRebootSafeMode ? com.android.internal.R.string.reboot_safemode_confirm : (longPressBehavior == 2 ? com.android.internal.R.string.shutdown_confirm_question : com.android.internal.R.string.shutdown_confirm);+ if (showRebootOption &amp;&amp; !mRebootSafeMode) &#123;+ resourceId = com.android.internal.R.string.reboot_confirm;+ &#125; Log.d(TAG, &quot;Notifying thread to start shutdown longPressBehavior=&quot; + longPressBehavior); @@ -237,7 +251,9 @@ public final class ShutdownThread extends Thread &#123; sConfirmDialog = new AlertDialog.Builder(context) .setTitle(mRebootSafeMode ? com.android.internal.R.string.reboot_safemode_title- : com.android.internal.R.string.power_off)+ : showRebootOption+ ? com.android.internal.R.string.reboot_title+ : com.android.internal.R.string.power_off) .setMessage(resourceId) .setPositiveButton(com.android.internal.R.string.yes, new DialogInterface.OnClickListener() &#123;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"},{"name":"MediaTek","slug":"MediaTek","permalink":"http://iyounix.com/tags/MediaTek/"}]},{"title":"Android6.0 MTK6737 设置屏幕旋转 270 度","slug":"Android_Driver/Driver/[Android6.0][MTK6737] 设置屏幕旋转 270 度","date":"2018-03-31T15:33:05.000Z","updated":"2018-11-08T02:35:08.112Z","comments":true,"path":"2018/03/31/Android_Driver/Driver/[Android6.0][MTK6737] 设置屏幕旋转 270 度/","link":"","permalink":"http://iyounix.com/2018/03/31/Android_Driver/Driver/[Android6.0][MTK6737] 设置屏幕旋转 270 度/","excerpt":"","text":"Hardware:MT6737DeviceOS:Android6.0Kernel: Linux4.10HostOS: Ubuntu16.04 [TOC] 屏幕显示LK 部分alps/vendor/mediatek/proprietary/bootable/bootloader/lk/project/br6737m_65_s_m0.mk1MTK_LCM_PHYSICAL_ROTATION = 270 kernel 部分kernel-3.18/arch/arm64/configs/br6737m_65_s_m0_debug_defconfig1CONFIG_MTK_LCM_PHYSICAL_ROTATION=&quot;270&quot; MTK 定制的应用层device/bror/br6737m_65_s_m0/ProjectConfig.mk1MTK_LCM_PHYSICAL_ROTATION = 270 Android 官方的应用层system.prop 中的 ro.sf.hwrotation 属性。包括开机动画（bootanimation.zip）都是由这个控制的。1234567--- a/bror/br6737m_65_s_m0/system.prop+++ b/bror/br6737m_65_s_m0/system.prop@@ -61,6 +61,7 @@ ro.kernel.zio=38,108,105,16 #ro.boot.selinux=disable ro.sf.lcd_density=240+ro.sf.hwrotation=270 TP坐标通过交换 x y 坐标实现旋转kernel-3.18/drivers/input/touchscreen/mediatek/12#define GTP_CHANGE_X2Y 1 //swap x y #define TPD_WARP_X kernel-3.18/drivers/input/touchscreen/mediatek/12345678 input_x = TPD_WARP_X(abs_x_max, input_x); // input_x = abs_x_max - 1 - input_x input_y = TPD_WARP_Y(abs_y_max, input_y); // input_y = input_y + #if GTP_CHANGE_X2Y + GTP_SWAP(input_x,input_y); + #endif #if GTP_WITH_HOVER id = coor_data[0]; 导航栏丢失旋转 90/270 度之后系统导航栏丢失，并在右边产生有黑边。是 MTK 的 Bug。解决办法参见另外一片博文。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"},{"name":"MediaTek","slug":"MediaTek","permalink":"http://iyounix.com/tags/MediaTek/"}]},{"title":"Android6.0 MTK6737 DCT 工具介绍","slug":"Environment/MTK6737/[IoT4G] MTK DCT 工具介绍","date":"2018-03-31T15:33:05.000Z","updated":"2018-11-08T02:14:52.918Z","comments":true,"path":"2018/03/31/Environment/MTK6737/[IoT4G] MTK DCT 工具介绍/","link":"","permalink":"http://iyounix.com/2018/03/31/Environment/MTK6737/[IoT4G] MTK DCT 工具介绍/","excerpt":"","text":"OS:Android6.0Hardware:MTK6737 [TOC] MTK 的 DCTDriver Customization ToolMTK 为 GPIO、I2C 等配置制作了一个工具叫做 DCT ， 可以直接在 UI 里面配置好 I2C 相关定义（codegen.dws 文件中），配好后编译会自动生成一些相关的 DTS 文件和头文件（如 cust_i2c.dtsi）。 运行流该工具的运行流如下： 硬件原理图 描述硬件配置的 Excel3.1 SA / Baseband 工程师 负责在 DCT 中 Key in3.2 描述文件（.fig .cmp）将被加载到 DCT 中 DCT 将生成定制化的源码（.c .h） 也将生成 工程文件（.dws） .fig 为芯片级定制文件（比如 mt6737.fig）其中将描述和这个芯片相关的硬件定制信息，比如 GPIO pin 数，支持的 mode，上拉下拉状态 ADC 通道个数 外部中断管脚 矩阵键盘大小 .cmp 为元件描述文件（比如 *.cmp）对于每个 DCT 所支持的元件（比如 GPIO EINT ADC keypad 和 UEM），都会有一个元件变量文件 DCT 文件清单工具在如下目录中./vendor/mediatek/proprietary/bootable/bootloader/preloader/tools/dct./vendor/mediatek/proprietary/bootable/bootloader/lk/scripts/dct./kernel-3.18/tools/dct 配置文件在如下目录Codegen.dwsPreloader: bootable/bootloader/preloader/custom/${PROJECT}/dct/dctLK: bootable/bootloader/lk/target/${PROJECT} /dct/dctKernel: kernel-3.10/drivers/misc/mediatek/mach/mt6735/${PROJECT}/dct/dctVendor: vendor/mediatek/proprietary/custom/ ${PROJECT}/kernel/dct比如：./vendor/mediatek/proprietary/bootable/bootloader/preloader/custom/bd6737m_35g_b_m0/dct/dct/codegen.dws./vendor/mediatek/proprietary/bootable/bootloader/lk/target/bd6737m_35g_b_m0/dct/dct/codegen.dws./kernel-3.18/drivers/misc/mediatek/mach/mt6735/bd6737m_35g_b_m0/dct/dct/codegen.dws./vendor/mediatek/proprietary/custom/bd6737m_35g_b_m0/kernel/dct/dct/codegen.dws其中所有的 codegen.dws 应该完全相同。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"},{"name":"MediaTek","slug":"MediaTek","permalink":"http://iyounix.com/tags/MediaTek/"}]},{"title":"Android6.0 MTK6737 环境搭建和烧录中的问题","slug":"Environment/MTK6737/[Android6.0][MT6737] 环境搭建和烧录","date":"2018-03-30T15:33:05.000Z","updated":"2018-11-08T02:18:39.901Z","comments":true,"path":"2018/03/30/Environment/MTK6737/[Android6.0][MT6737] 环境搭建和烧录/","link":"","permalink":"http://iyounix.com/2018/03/30/Environment/MTK6737/[Android6.0][MT6737] 环境搭建和烧录/","excerpt":"","text":"Hardware:MT6737DeviceOS:Android6.0Kernel: Linux3.18HostOS: Ubuntu16.04 编译问题@Ubuntu16.04teei_daemon.te ERROR12345678#allow osi tmpfs:lnk_file read;device/mediatek/common/sepolicy/teei_daemon.te:30:ERROR &apos;unknown type teei_client_device&apos; at token &apos;;&apos; on line 25309:#define for mlsconstraintypeattribute teei_client_device mlstrustedobject;checkpolicy: error(s) encountered while parsing configurationout/host/linux-x86/bin/checkpolicy: loading policy configuration from out/target/product/br6737m_65_s_m0/obj/ETC/sepolicy.recovery_intermediates/policy_recovery.confexternal/sepolicy/Android.mk:96: recipe for target &apos;out/target/product/br6737m_65_s_m0/obj/ETC/sepolicy.recovery_intermediates/sepolicy.recovery&apos; failedmake: *** [out/target/product/br6737m_65_s_m0/obj/ETC/sepolicy.recovery_intermediates/sepolicy.recovery] Error 1 123device/mediatek/common/sepolicy/teei_daemon.te # 去掉最后一行-- typeattribute teei_client_device mlstrustedobject； clang 报错修改 alps/art/build/android.common_build.mk 大概81行12-- ifneq ($(WITHOUT_HOST_CLANG),true)++ ifeq ($(WITHOUT_HOST_CLANG),false) 如果解决，那么 OK。如果没有解决。还需要如下修改：1234# 请自行做好原始 ld 的备份cp /usr/bin/ld.gold prebuilts/gcc/Linux-x86/host/x86_64-linux-glibc2.11-4.6/x86_64-linux/bin/ldmake update-apimake -j8 # 重新编译 如果仍然有报错，那么回退上述的所有修改，修改 build/core/clang/HOST_x86_common.mk：12345678910111213141516171819202122CLANG_CONFIG_x86_DARWIN_HOST_EXTRA_CFLAGS := \\ -integrated-asCLANG_CONFIG_x86_DARWIN_HOST_EXTRA_CFLAGS += -fstack-protector-strongendififeq ($(HOST_OS),linux)CLANG_CONFIG_x86_LINUX_HOST_EXTRA_ASFLAGS := \\ --gcc-toolchain=$($(clang_2nd_arch_prefix)HOST_TOOLCHAIN_FOR_CLANG) \\ --sysroot $($(clang_2nd_arch_prefix)HOST_TOOLCHAIN_FOR_CLANG)/sysroot \\## 上面一行最后加上换行符 并添加下面这行 -B$($(clang_2nd_arch_prefix)HOST_TOOLCHAIN_FOR_CLANG)/x86_64-linux/binCLANG_CONFIG_x86_LINUX_HOST_EXTRA_CFLAGS := \\ --gcc-toolchain=$($(clang_2nd_arch_prefix)HOST_TOOLCHAIN_FOR_CLANG)CLANG_CONFIG_x86_LINUX_HOST_EXTRA_CFLAGS += -fstack-protector-strongifneq ($(strip $($(clang_2nd_arch_prefix)HOST_IS_64_BIT)),)CLANG_CONFIG_x86_LINUX_HOST_EXTRA_CPPFLAGS := \\ --gcc-toolchain=$($(clang_2nd_arch_prefix)HOST_TOOLCHAIN_FOR_CLANG) \\ --sysroot $($(clang_2nd_arch_prefix)HOST_TOOLCHAIN_FOR_CLANG)/sysroot \\ libcam 无法编译的问题错误信息：1make: *** No rule to make target &apos;out/target/product/br6737m_65_s_m0/obj_arm/STATIC_LIBRARIES/libcam.halmemory_intermediates/export_includes&apos;, needed by &apos;out/target/product/br6737m_65_s_m0/obj_arm/SHARED_LIBRARIES/libcam_platform_intermediates/import_includes&apos;. Stop 解决方法：1aiiage@repo:~/alps$ cp -a vendor/mediatek/proprietary/hardware/mtkcam/legacy/platform/mt6735m/hal/memory vendor/mediatek/proprietary/hardware/mtkcam/legacy/platform/mt6735m/entry/ 烧录问题@LinuxS_BROM_CMD_JUMP_DA_FAIL是由于 Ubuntu14.04 / 16.04 环境问题。 是由于modemmanager包在ubuntu 14.04 或是更高版本中对于MTK的Flash 工具支持不完全，所造成的，如果想使用MTK的Flash工具，就要卸载这个包12345678910111213sudo apt-get remove modemmanager //卸载modemmanager包sudo service udev restart //从启udev# 卸载这个服务之后可能会造成内核模块 cdc_acm 不可用．执行以下命令进行检查lsmod | grep cdc_acm //检查 # 执行后出现： cdc_acm 36864 0 //表示可用# 如果没有任何输出： sudo modprobe cdc_acm //智能安装cdc_acmok 如果出现pmt changed for the rom; it must be downloaded这个错误，则选择固件升级，便可以下载。 S_INVALID_BBCHIP_TYPE芯片类型不匹配 可能是 lunch 错工程。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"},{"name":"MediaTek","slug":"MediaTek","permalink":"http://iyounix.com/tags/MediaTek/"}]},{"title":"Android6.0 MTK6737 开发环境搭建","slug":"Environment/MTK6737/[IoT4G] MTK开发环境搭建","date":"2018-03-29T15:33:05.000Z","updated":"2018-11-08T02:18:00.438Z","comments":true,"path":"2018/03/29/Environment/MTK6737/[IoT4G] MTK开发环境搭建/","link":"","permalink":"http://iyounix.com/2018/03/29/Environment/MTK6737/[IoT4G] MTK开发环境搭建/","excerpt":"","text":"Hardware: MTK6737Android: 6.0(API 23)Kernel: Linux 3.4.67 [TOC] 安装编译环境并编译安装编译环境依赖包2&gt;ubuntu &lt; 12.041sudo apt-get install git-core gnupg flex bison ccache gperf libsdl1.2-dev libesd0-dev libwxgtk2.6-dev build-essential zip curl libncurses5-dev zlib1g-dev valgrind libc6-dev lib32ncurses5-dev x11proto-core-dev libx11-dev lib32readline-gplv2-dev lib32z1-dev libgl1-mesa-dev gcc-4.4 g++-4.4 g++-4.4-multilib g++-multilib mingw32 tofrodos python-markdown libxml2-utils xsltproc wine 3&gt;ubuntu = 14.041sudo apt-get install git-core gnupg flex bison ccache gperf libsdl1.2-dev libesd0-dev libwxgtk2.8-dev build-essential zip curl libncurses5-dev zlib1g-dev valgrind libc6-dev lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev g++-multilib g++-4.8-multilib mingw32 tofrodos python-markdown libxml2-utils xsltproc libc6-dev-i386 lib32z1 lib32ncurses5 lib32bz2-1.0 lib32readline-gplv2-dev wine 安装无问题 ubuntu = 16.041sudo apt-get install git-core gnupg flex bison ccache gperf libsdl1.2-dev libesd0-dev libwxgtk2.8-dev build-essential zip curl libncurses5-dev zlib1g-dev valgrind libc6-dev lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev g++-multilib g++-4.8-multilib tofrodos python-markdown libxml2-utils xsltproc libc6-dev-i386 lib32z1 lib32ncurses5 wine mingw32 lib32bz2-1.0 lib32readline-gplv2-dev 报错有如下无法定位：libwxgtk2.8-dev mingw32lib32bz2-1.0 lib32readline-gplv2-dev 在 Ubuntu16.04 中libwxgtk2.8-dev 已经升级为 libwxgtk3.0-dev;lib32bz2-1.0 已经升级为 libbz2-1.0:i386;lib32readline-gplv2-dev 已经升级为 lib32readline6-dev;所以：1sudo apt install libwxgtk3.0-dev lib32readline6-dev libbz2-1.0:i386 mingw32 需要在 sudo vi /etc/apt/sources.list添加源：1deb http://us.archive.ubuntu.com/ubuntu trusty main universe 之后如下即可12sudo apt updatesudo apt install mingw32 bootloader 和 kernel 编译全编译：12cd runyee/scripts/./auto.sh IoT_bd6737m_35g_b_m0_ry_smt_hd720_pcb_v1 v00 eng 了解到现在我们的模块 lunch 的是 bd6737m_35g_b_m0 这个 project 模块编译：首先通过 get_build_var 获得 project name：12345get_build_var TARGET_DEVICEop_project_nameget_build_var TARGET_BUILD_VARIANTeng 分模块编译的时候可以传入preloader： 单独编译1make -j4 pl 2&gt;&amp;1 | tee pl_build.log 会生成 bootable/bootloader/preloader/bin build 脚本编译：12cd bootable/bootloader/preloaderTARGET_PRODUCT=$op_project_name ./build.sh 2&gt;&amp;1 | tee preloader_build.log lk:1make -j4 lk 2&gt;&amp;1 | tee lk_build.log 会生成 bootable/bootloader/lk/build-xx Kernel: 单独编译123cd kernel-3.18mkdir outmake -j4 O=out 2&gt;&amp;1 | tee kernel_build.log 会生成 kernel-3.18/out/arch/arm64/boot/Image.gz-dtb build 脚本编译1make -j8 n k &amp;&amp; make -j8 r bootimage clean:12345678# Clean ALLmake clean# Clean PLmake clean-pl# Clean lkmake clean-lk# Clean kernelmake clean-kernel Android 编译12345678# 1. 环境变量source build/envsetup.sh# 2. 选择工程lunch full_bd6737m_35g_b_m0-eng# 3. MTK 环境变量source mbldev.sh# 4. 编译make -j4 2 &gt; &amp;1 | tee mtk_build.log 打包123456789101112# pack boot imagemake -j4 bootimage# pack system image 根据依赖规则重新生成所有要打包的文件make -j4 systemimage# pack system image 快速打包 system image# （如果所修改模块与其他模块没有依赖关系，直接 build 对应模块并用 snod 命令打包）make -j4 snod # pack ota imagemake -j4 otapackage 硬件参数https://versus.com/en/mediatek-mt6735-vs-mediatek-mt6737 MTK67374 x 1.3GHz 28nmLTE supportedGPU: MailT720 Check SDK Version123456789vi build/core/version_defaults.mk PLATFORM_VERSION := 6.0 PLATFORM_SDK_VERSION := 23 #Android6.0 vi kernel/MakefileVERSION = 3PATCHLEVEL = 18SUBLEVEL = 19 编译中碰到的问题clang 问题1234clang: error: linker command failed with exit code 1 (use -v to see invocation)build/core/host_shared_library_internal.mk:51: recipe for target &apos;out/host/linux-x86/obj/lib/libart.so&apos; failedmake: *** [out/host/linux-x86/obj/lib/libart.so] Error 1 解决方法：代码 art/build/Android.common_build.mk 中123 # By default, host builds use clang for better warnings.-- ART_HOST_CLANG := true++ ART_HOST_CLANG := false STATIC_LIBRARIES SHARED_LIBRARIES 类型的问题比如下面这些123make: *** No rule to make target &apos;out/target/product/bd6737m_35g_b_m0/obj/STATIC_LIBRARIES/libcam.halmemory_intermediates/export_includes&apos;, needed by &apos;out/target/product/bd6737m_35g_b_m0/obj/SHARED_LIBRARIES/libcam_platform_intermediates/import_includes&apos;。 停止。make: *** 正在等待未完成的任务....target thumb C++: libcam.device3.base &lt;= vendor/mediatek/proprietary/hardware/mtkcam/legacy/v3/device/Cam3DeviceFactory.cpp 123make: *** No rule to make target &apos;out/target/product/bd6737m_35g_b_m0/obj/STATIC_LIBRARIES/libcam.halmemory_intermediates/export_includes&apos;, needed by &apos;out/target/product/bd6737m_35g_b_m0/obj/SHARED_LIBRARIES/libcam_platform_intermediates/import_includes&apos;。 停止。make: *** 正在等待未完成的任务....target StaticLib: libcam.device3.base (out/target/product/bd6737m_35g_b_m0/obj/STATIC_LIBRARIES/libcam.device3.base_intermediates/libcam.device3.base.a) 可以参考 安装编译环境依赖包 进行安装必要的包 烧录Linux 下的烧录工具为 SP_Flash_Tool_v5.1644_Linux.zip使用方法：http://spflashtools.com/linux/sp-flash-tool-v5-1644-linux","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"},{"name":"MediaTek","slug":"MediaTek","permalink":"http://iyounix.com/tags/MediaTek/"}]},{"title":"Android7.1 RK3399 使用 ramoops 机制查看开机 Kernel Log","slug":"Android_Driver/Driver/[Android7.1][RK3399] 使用 ramoops 机制查看开机 Kernel Log","date":"2018-03-03T15:33:05.000Z","updated":"2018-11-08T02:46:01.266Z","comments":true,"path":"2018/03/03/Android_Driver/Driver/[Android7.1][RK3399] 使用 ramoops 机制查看开机 Kernel Log/","link":"","permalink":"http://iyounix.com/2018/03/03/Android_Driver/Driver/[Android7.1][RK3399] 使用 ramoops 机制查看开机 Kernel Log/","excerpt":"","text":"Platform: RK3399OS: Android 7.1Kernel: v4.4.83 [TOC] 基本概念pstore pstore是persistent storage的缩写。内核发生异常时如果能将日志等信息保存下来不丢失，那么就可以通过这些信息来定位问题。不同的平台可以提供的存储位置不同，例如有些平台支持硬盘，有些不支持。除了平台差异，异常类型也决定了在发生异常时该存储位置是否还可用。pstore 的目标是提供一套通用的接口用来存储异常信息。pstore以文件系统的形式提供用户空间接口，可以通过mount命令挂载到指定目录下边，如xxx\\pstore，那么保存的信息将以文件的形式出现在该目录下，可以使用文件读操作获取调试信息，通过删除操作清除调试信息。 在内核中使用pstore前需要首先初始化一个pstore_info类型的结构体变量，然后调用int pstore_register(struct pstore_info * )注册。pstore_info结构体中有些变量可以不需要赋值，但是读写，删除用到的函数指针需要赋值。pstore在内核中的开关是CONFIG_PSTORE，在2.6.39版本中第一次合入主线，3.10.40中的ramoops使用的就是pstore机制。pstore提供的是一套可扩展的机制，目前提供的类型包括以下四种：PSTORE_TYPE_DMESG表示内核日志，PSTORE_TYPE_MCE表示硬件错误，PSTORE_TYPE_CONSOLE表示控制台输出，PSTORE_TYPE_FTRACE表示函数调用序列。 ramoops ramoops 指的是采用ram保存oops信息的一个功能，这个功能最开始不是基于pstore实现的，在3.10.40中，它已经采用pstore机制实现了，在内核开关中用3个开关控制：PSTORE_CONSOLE控制是否保存控制台输出，PSTORE_FTRACE控制是否保存函数调用序列，PSTORE_RAM控制是否保存panic/oops信息。 使用ramoops功能也很简单，只要打开开关，注册一个名字ramoops的platform_device就可以了,platform_data要指向一个类型为ramoops_platform_data的变量地址。ramoops_platform_data结构体中mem_size表示总共的ram大小为多大，mem_address表示ram的起始物理地址，record_size表示记录oops/panic单次记录的buffer大小，console_size表示控制台输出buffer的大小，ftrace_size表示函数调用序列buffer的大小，所有这些buffer都是整个mem_size的一部分，首先预留console_size和ftrace_size，剩下的空间能放几个record_size就保存几次的oops/panic记录，在产生oops/panic时后边的记录会冲掉前边的记录，这个和console/ftrace都是一样的，都是保留最新的。dump_oops为1表示oops和panic都记录，为0表示仅记录panic。 控制台日志位于 pstore 目录下的console-ramoops文件中，因为采用console机制，该文件中的日志信息也受printk level控制，并不一定是全的。oops/panic日志位于 pstore 目录下的dmesg-ramoops-x文件中，根据缓冲区大小可以有多个文件，x从0开始。函数调用序列日志位于 pstore 目录下的ftrace-ramoops文件中。 在kernel3.10.40中，pstore和ramoops的代码都位于/kernel/fs/pstore/目录。ramoops初始化函数位于ram.c中:postcore_initcall(ramoops_init);使用postcore_initcall的好处是更早，这样可以更早的记录异常。 RK 平台中的 ramoops由 defconfig 中的宏来控制 (默认开启)CONFIG_PSTORECONFIG_PSTORE_CONSOLECONFIG_PSTORE_PMSGCONFIG_PSTORE_RAM Kerneldefconfig1234CONFIG_PSTORE=yCONFIG_PSTORE_CONSOLE=yCONFIG_PSTORE_PMSG=yCONFIG_PSTORE_RAM=y driver1kernel/fs/pstore dts配置内存地址12345678910111213ramoops_mem: ramoops_mem &#123; reg = &lt;0x0 0x110000 0x0 0xf0000&gt;; reg-names = &quot;ramoops_mem&quot;;&#125;;ramoops &#123; compatible = &quot;ramoops&quot;; record-size = &lt;0x0 0x20000&gt;; console-size = &lt;0x0 0x80000&gt;; ftrace-size = &lt;0x0 0x00000&gt;; pmsg-size = &lt;0x0 0x50000&gt;; memory-region = &lt;&amp;ramoops_mem&gt;;&#125;; 12345678910- compatible: must be &quot;ramoops&quot;- memory-region: phandle to a region of memory that is preserved between rebootsOptional properties:- ecc-size: enables ECC support and specifies ECC buffer size in bytes (defaults to no ECC)- record-size: maximum size in bytes of each dump done on oops/panic (defaults to 0)- console-size: size in bytes of log buffer reserved for kernel messages (defaults to 0)- ftrace-size: size in bytes of log buffer reserved for function tracing and profiling (defaults to 0)- pmsg-size: size in bytes of log buffer reserved for userspace messages (defaults to 0)- unbuffered: if present, use unbuffered mappings to map the reserved region (defaults to buffered mappings)- no-dump-oops: if present, only dump panics (defaults to panics and oops) mount when bootsystem/core/rootdir/init.rc123456# pstore/ramoops previous console logmount pstore pstore /sys/fs/pstorechown system log /sys/fs/pstore/console-ramoopschmod 0440 /sys/fs/pstore/console-ramoopschown system log /sys/fs/pstore/pmsg-ramoops-0chmod 0440 /sys/fs/pstore/pmsg-ramoops-0","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android7.1 RK3399 WiFi 吞吐率周期性变差问题(扫描机制)","slug":"Android_Driver/Debug/[Android7.1][RK3399] WiFi 吞吐率周期性变差问题(扫描机制)","date":"2018-01-31T15:33:05.000Z","updated":"2018-11-08T02:52:50.945Z","comments":true,"path":"2018/01/31/Android_Driver/Debug/[Android7.1][RK3399] WiFi 吞吐率周期性变差问题(扫描机制)/","link":"","permalink":"http://iyounix.com/2018/01/31/Android_Driver/Debug/[Android7.1][RK3399] WiFi 吞吐率周期性变差问题(扫描机制)/","excerpt":"","text":"Platform: RK3399OS: Android 7.1Kernel: v4.4.83 [TOC] 参考文章:Android wifi扫描机制(Android O): https://blog.csdn.net/h784707460/article/details/79658950Android wifi PNO扫描流程(Andriod O) :https://blog.csdn.net/h784707460/article/details/79702275 四种场景亮屏情况： 在WiFi Settings界面，无论WiFi是否有连接，固定扫描时间间隔为10s。 在非WiFi Settings界面，无论WiFi是否有连接，固定扫描时间间隔以2的倍数慢慢拉大扫描周期，最小为20s，最大为160s. 二进制指数退避扫描, 退避算法:interval*(2^n) . 灭屏情况：有保存网络 , 已经连接 , 不扫描.有保存网络 , 没有连接 , PNO 扫描 (只扫描已经保存的网络) , 间隔 min=20s max=160s 其他情况：当没有保存网络的时候，固定扫描时间间隔为 5min。 亮屏情况WiFi Setting界面进入WiFi Setting界面时，会调用对应Activity的onResume()。 12345678910onResume -&gt; WifiSettings.java mWifiTracker.startTracking -&gt; startTracking -&gt; WifiTracker.java resumeScanning -&gt; mScanner.resume -&gt; resume-&gt; sendEmptyMessage(MSG_SCAN); -&gt; handleMessage -&gt; //Scanner类 mWifiManager.startScan -&gt; //调用WiFi Service开始扫描。 sendEmptyMessageDelayed(0, WIFI_RESCAN_INTERVAL_MS); //发送下次扫描时间间隔 WIFI_RESCAN_INTERVAL_MS默认定义为10秒。12// Combo scans can take 5-6s to complete - set to 10s.private static final int WIFI_RESCAN_INTERVAL_MS = 10 * 1000; WiFi Setting和非Settings界面的扫描是同时不干预并存工作的.其中35秒和75秒是非WiFi界面的周期扫描，间隔40秒，说明是第二次(20 x 2)扫描了。其他的是在WiFi Settings界面扫描，每10秒一次。 非WiFi Setting界面123456789// Start a connectivity scan. The scan method is chosen according to// the current screen state and WiFi state.startConnectivityScan -&gt; startPeriodicScan -&gt; //mScreenOn为true mPeriodicSingleScanInterval = PERIODIC_SCAN_INTERVAL_MS; //设置扫描间隔为20s startPeriodicSingleScan -&gt; mPeriodicSingleScanInterval *= 2; //每扫描一次，时间拉长一倍，最大不能超过MAX_PERIODIC_SCAN_INTERVAL_MS即160s startSingleScan -&gt; mScanner.startScan //开始扫描 灭屏情况123456789startConnectivityScan -&gt; startConnectedPnoScan -&gt; //screenOff以及WiFi已经有连接的情况 scanSettings.periodInMs = CONNECTED_PNO_SCAN_INTERVAL_MS; //设置扫描周期为160S mScanner.startConnectedPnoScan -&gt; startPnoScan startDisconnectedPnoScan -&gt; //screenOff以及WiFi没有连接但有保存的情况 scanSettings.periodInMs = DISCONNECTED_PNO_SCAN_INTERVAL_MS; //设置扫描周期为20S mScanner.startDisconnectedPnoScan -&gt; startPnoScan 没有保存网络情况12345678910111213class DisconnectedState extends State &#123; /** * If we have no networks saved, the supplicant stops doing the periodic scan. * The scans are useful to notify the user of the presence of an open network. * Note that these are not wake up scans. */ if (mNoNetworksPeriodicScan != 0 &amp;&amp; !mP2pConnected.get() &amp;&amp; mWifiConfigManager.getSavedNetworks().size() == 0) &#123; sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN, ++mPeriodicScanToken, 0), mNoNetworksPeriodicScan); &#125;&#125; mNoNetworksPeriodicScan的值被定义在 frameworks/base/core/res/res/values/config.xml中1&lt;integer translatable=&quot;false&quot; name=&quot;config_wifi_framework_scan_interval&quot;&gt;300000&lt;/integer&gt;1 可以看到为 5min","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android7.1 RK3399 RK reboot 机制驱动分析","slug":"Android_Driver/Driver/[Android7.1][RK3399] RK reboot 机制驱动分析","date":"2018-01-31T15:33:05.000Z","updated":"2018-11-08T02:46:27.178Z","comments":true,"path":"2018/01/31/Android_Driver/Driver/[Android7.1][RK3399] RK reboot 机制驱动分析/","link":"","permalink":"http://iyounix.com/2018/01/31/Android_Driver/Driver/[Android7.1][RK3399] RK reboot 机制驱动分析/","excerpt":"","text":"Platform: RK3399OS: Android 7.1Kernel: v4.4.83 基本概念kernel/Documentation/devicetree/bindings/power/reset/syscon-reboot.txt1234567891011121314151617181920212223Generic SYSCON mapped register reset driverThis is a generic reset driver using syscon to map the reset register.The reset is generally performed with a write to the reset registerdefined by the register map pointed by syscon reference plus the offsetwith the mask defined in the reboot node.Required properties:- compatible: should contain &quot;syscon-reboot&quot;- regmap: this is phandle to the register map node- offset: offset in the register map for the reboot register (in bytes)- mask: the reset value written to the reboot register (32 bit access)Default will be little endian mode, 32 bit access only.Examples: reboot &#123; compatible = &quot;syscon-reboot&quot;; regmap = &lt;&amp;regmapnode&gt;; offset = &lt;0x0&gt;; mask = &lt;0x1&gt;; &#125;; 这个是使用 syscon 去映射重启寄存器的驱动.通过 syscon 基地址加上偏移地址 (这个在 reboot 节点中有定义) kernel/Documentation/devicetree/bindings/power/reset/reboot-mode.txt123456789101112131415161718192021222324Generic reboot mode core map driverThis driver get reboot mode arguments and call the writeinterface to stores the magic value in special registeror ram . Then the bootloader can read it and take differentaction according the argument stored.All mode properties are vendor specific, it is a indication to tellthe bootloder what to do when the system reboot, and should be namedas mode-xxx = &lt;magic&gt; (xxx is mode name).- mode-normal: Normal reboot mode, system reboot with command &quot;reboot&quot;.- mode-recovery: Android Recovery mode, it is a mode to format the device or update a new image.- mode-bootloader: Android fastboot mode, it&apos;s a mode to re-flash partitions on the Android based device.- mode-loader: A bootloader mode, it&apos;s a mode used to download image on Rockchip platform, usually used in development.Example: reboot-mode &#123; mode-normal = &lt;BOOT_NORMAL&gt;; mode-recovery = &lt;BOOT_RECOVERY&gt;; mode-bootloader = &lt;BOOT_FASTBOOT&gt;; mode-loader = &lt;BOOT_LOADER&gt;; &#125; 这个驱动获取 reboot mode 的参数, 并且调用写接口在特定的寄存器或者ram中存储魔数 , 然后 bootloader 可以获取魔数并采取相应的动作.所有的 property 都是由 vendor 确定的, 这些 property 会告诉 bootloader 在重启时进行怎样的操作, 这些 property 的格式是mode-xxx = &lt;magic&gt; , 比如 recovery 模式是 mode-recovery = &lt;BOOT_RECOVERY&gt; 代码分析DTS1234567891011reboot-mode &#123; compatible = &quot;syscon-reboot-mode&quot;; offset = &lt;0x300&gt;; mode-bootloader = &lt;BOOT_BL_DOWNLOAD&gt;; mode-charge = &lt;BOOT_CHARGING&gt;; mode-fastboot = &lt;BOOT_FASTBOOT&gt;; mode-loader = &lt;BOOT_BL_DOWNLOAD&gt;; mode-normal = &lt;BOOT_NORMAL&gt;; mode-recovery = &lt;BOOT_RECOVERY&gt;; mode-ums = &lt;BOOT_UMS&gt;; &#125;; Driver代码在 kernel/drivers/power/reset由 defconfig 中的CONFIG_SYSCON_REBOOT_MODE控制1obj-$(CONFIG_SYSCON_REBOOT_MODE) += syscon-reboot-mode.o 代码流程reboot mode 注册:1234syscon_reboot_mode_probe -&gt; reboot_mode_register -&gt; register_reboot_notifier -&gt; //reboot_notifier的callback是reboot_mode_notify blocking_notifier_chain_register //list是reboot_notifier_list reboot 调用:1234567891011kernel_restart -&gt; kernel_restart_prepare -&gt; blocking_notifier_call_chain -&gt; __blocking_notifier_call_chain -&gt; notifier_call_chain -&gt; nb-&gt;notifier_call -&gt; //reboot_notifier_list被调用到 reboot_mode_notify -&gt; reboot-mode.c get_reboot_mode_magic -&gt; //获取参数对应的magic reboot-&gt;write -&gt; syscon_reboot_mode_write -&gt; regmap_update_bits //使用regmap mmio更新到寄存器中 重启开机判断是在 uboot 中完成的:12345678910111213141516171819202122static void fbt_handle_reboot(const char *cmdbuf)&#123; if (!strcmp(&amp;cmdbuf[6], &quot;-bootloader&quot;)) &#123; FBTDBG(&quot;%s\\n&quot;, cmdbuf); board_fbt_set_reboot_type(FASTBOOT_REBOOT_BOOTLOADER); &#125; if (!strcmp(&amp;cmdbuf[6], &quot;-recovery&quot;)) &#123; FBTDBG(&quot;%s\\n&quot;, cmdbuf); board_fbt_set_reboot_type(FASTBOOT_REBOOT_RECOVERY); &#125; if (!strcmp(&amp;cmdbuf[6], &quot;-recovery:wipe_data&quot;)) &#123; FBTDBG(&quot;%s\\n&quot;, cmdbuf); board_fbt_set_reboot_type(FASTBOOT_REBOOT_RECOVERY_WIPE_DATA); &#125; strcpy(priv.response, &quot;OKAY&quot;); priv.flag |= FASTBOOT_FLAG_RESPONSE; fbt_handle_response(); udelay(1000000); /* 1 sec */ do_reset(NULL, 0, 0, NULL);&#125;","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android7.1 RK3399 插上 TypeC 为 USB_FLOATING_CHARGER 模式","slug":"Android_Driver/Debug/[Android7.1][RK3399] 插上 TypeC 为 USB_FLOATING_CHARGER 模式","date":"2018-01-31T15:33:05.000Z","updated":"2018-11-08T02:53:40.181Z","comments":true,"path":"2018/01/31/Android_Driver/Debug/[Android7.1][RK3399] 插上 TypeC 为 USB_FLOATING_CHARGER 模式/","link":"","permalink":"http://iyounix.com/2018/01/31/Android_Driver/Debug/[Android7.1][RK3399] 插上 TypeC 为 USB_FLOATING_CHARGER 模式/","excerpt":"","text":"Author: Kris_FeiPlatform: RK3399OS: Android 7.1Kernel: v4.4.83 [TOC] 问题描述插上 TypeC 后 log 显示为 USB_FLOATING_CHARGER , 正常的应该是 USB_SDP_CHARGER 123456[ 35.192416] rk818-charger: pmic: plug in[ 35.679779] phy phy-ff770000.syscon:usb2-phy@e450.1: charger = USB_FLOATING_CHARGER[ 35.688995] rk818-charger: receive type-c notifier event: AC...[ 35.700366] rk818-charger: ac=1 usb=0 dc=0 otg=0 v=4350 chrg=3000 input=3000 virt=0[ 35.702589] healthd: battery l=46 v=3825 t=18.8 h=2 st=2 c=-30 chg=a[ 35.727454] healthd: battery l=46 v=3825 t=18.8 h=2 st=2 c=-30 chg=a 解决方案由于usb 3.0的type-c接口需要支持不同电压的外设(5V, 12V等)，如果不做控制，那么设置12V接5V的外设将会出问题。fusb302可以实现此控制，根据不同的外设电压来调整电流。 FUSB302 框图: 参考设计: 其中要注意的是INT_N引脚，此pin会接到processor端的gpio，当有usb插拔时，INT_N pin会被拉低，以通知cpu通过I2C去读取USB状态信息，如果dts中gpio配置得不对，usb也将无法被识别。 调试的时候可以看下/proc/interrupts中有没有fusb302的中断信息，或者直接在驱动(drivers/mfd/fusb302.c)中加Log。 rk3399-mid-818-android.dts：12345678910111213141516 fusb0: fusb30x@22 &#123; compatible = &quot;fairchild,fusb302&quot;; reg = &lt;0x22&gt;; pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;fusb0_int&gt;; int-n-gpios = &lt;&amp;gpio1 1 GPIO_ACTIVE_HIGH&gt;; //我用的是gpio1 A1, RK参考设计为 gpio1 A2 status = &quot;okay&quot;; &#125;; //这里也要一起修改 fusb30x &#123; fusb0_int: fusb0-int &#123; rockchip,pins = &lt;1 1 RK_FUNC_GPIO &amp;pcfg_pull_up&gt;; &#125;; &#125;; 正常 Log 如下:12345678910111213[ 3479.628913] fusb302 4-0022: CC connected in 0 as UFP[ 3479.635870] cdn-dp fec00000.dp: [drm:cdn_dp_pd_event_work] Not connected. Disabling cdn[ 3479.728151] rk818-charger: pmic: plug in[ 3479.797379] phy phy-ff770000.syscon:usb2-phy@e450.1: charger = USB_SDP_CHARGER[ 3479.799540] rockchip-dwc3 usb@fe800000: USB peripheral connected[ 3479.805475] rk818-charger: receive type-c notifier event: USB...[ 3479.807465] rk818-charger: ac=0 usb=1 dc=0 otg=0 v=4350 chrg=3000 input=450 virt=0[ 3479.819669] healthd: battery l=45 v=3801 t=18.8 h=2 st=2 c=-4 chg=u[ 3479.834338] healthd: battery l=45 v=3801 t=18.8 h=2 st=2 c=-4 chg=u[ 3479.993106] type=1400 audit(1358504472.310:17): avc: denied &#123; read &#125; for pid=313 comm=&quot;AudioOut_D&quot; name=&quot;audioformat&quot; dev=&quot;sysfs&quot; ino=19061 scontext=u:r:audioserver:s0 tcontext=u:object_r:sysfs:s0 tclass=file permissive=1[ 3479.993605] type=1400 audit(1358504472.310:18): avc: denied &#123; open &#125; for pid=313 comm=&quot;AudioOut_D&quot; path=&quot;/sys/devices/platform/display-subsystem/drm/card0/card0-HDMI-A-1/audioformat&quot; dev=&quot;sysfs&quot; ino=19061 scontext=u:r:audioserver:s0 tcontext=u:object_r:sysfs:s0 tclass=file permissive=1[ 3479.993759] type=1400 audit(1358504472.310:19): avc: denied &#123; getattr &#125; for pid=313 comm=&quot;AudioOut_D&quot; path=&quot;/sys/devices/platform/display-subsystem/drm/card0/card0-HDMI-A-1/audioformat&quot; dev=&quot;sysfs&quot; ino=19061 scontext=u:r:audioserver:s0 tcontext=u:object_r:sysfs:s0 tclass=file permissive=1[ 3480.096724] android_work: sent uevent USB_STATE=CONNECTED","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android7.1 RK3399 添加对 USB Camera 动态热插拔的支持.md","slug":"Android_Driver/Debug/[Android7.1][RK3399] 添加对 Camera 动态热插拔的支持","date":"2018-01-31T15:33:05.000Z","updated":"2018-11-08T02:54:06.228Z","comments":true,"path":"2018/01/31/Android_Driver/Debug/[Android7.1][RK3399] 添加对 Camera 动态热插拔的支持/","link":"","permalink":"http://iyounix.com/2018/01/31/Android_Driver/Debug/[Android7.1][RK3399] 添加对 Camera 动态热插拔的支持/","excerpt":"","text":"Platform: RK3399OS: Android 7.1Kernel: v4.4.83 [TOC] 思路原生Google代码只在开机的时候加载一次Camera 的配置, 当开机之后再去插USB Camera, 虽然USB模块能枚举成功USB Camera,但是Camera HAL 和 Camera Service是无法得知此事件的．因此解决思路就是在每次APP初始化获取Camera信息的时候重新加载初始化一次Camera. 解决方案Android6.0CameraService.cpp:1234567891011121314151617int32_t CameraService::getNumberOfCameras(int type) &#123; ATRACE_CALL(); switch (type) &#123; case CAMERA_TYPE_BACKWARD_COMPATIBLE: + if(mNumberOfNormalCameras == 0) &#123; + ALOGE(&quot;no camera be found ! check again...&quot;); + onFirstRef(); + &#125; return mNumberOfNormalCameras; case CAMERA_TYPE_ALL: return mNumberOfCameras; default: ALOGW(&quot;%s: Unknown camera type %d, returning 0&quot;, __FUNCTION__, type); return 0; &#125;&#125; Android7.1HAL 层CameraHal/CameraHal_Module.cpp123456789101112131415161718192021diff --git a/CameraHal/CameraHal_Module.cpp b/CameraHal/CameraHal_Module.cppindex 01afa0d..07380f2 100755--- a/CameraHal/CameraHal_Module.cpp+++ b/CameraHal/CameraHal_Module.cpp@@ -712,6 +712,7 @@ int camera_get_number_of_cameras(void) int cam_cnt=0,fd=-1,rk29_cam[CAMERAS_SUPPORT_MAX]; struct v4l2_capability capability; rk_cam_info_t camInfoTmp[CAMERAS_SUPPORT_MAX];+ char usbcameraPlug[PROPERTY_VALUE_MAX]; char *ptr,**ptrr; char version[PROPERTY_VALUE_MAX]; char property[PROPERTY_VALUE_MAX];@@ -722,7 +723,10 @@ int camera_get_number_of_cameras(void) struct timeval t0, t1; ::gettimeofday(&amp;t0, NULL);- if (gCamerasNumber &gt; 0)+ property_get(&quot;persist.sys.usbcamera.status&quot;, usbcameraPlug, &quot;&quot;);+ bool plugstate = (strcmp(usbcameraPlug, &quot;add&quot;) == 0)+ || (strcmp(usbcameraPlug, &quot;remove&quot;) == 0);+ if (gCamerasNumber &gt; 0 &amp;&amp; !plugstate) native 部分12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758diff --git a/media/libmedia/MediaProfiles.cpp b/media/libmedia/MediaProfiles.cppindex fe0126a..99a5d48 100755--- a/media/libmedia/MediaProfiles.cpp+++ b/media/libmedia/MediaProfiles.cpp@@ -718,7 +718,7 @@ MediaProfiles::getInstance() &#125; CHECK(sInstance != NULL); sInstance-&gt;checkAndAddRequiredProfilesIfNecessary();- sIsInitialized = true;+// sIsInitialized = true; &#125; return sInstance;diff --git a/services/camera/libcameraservice/CameraService.cpp b/services/camera/libcameraservice/CameraService.cppindex 28018df..737ab8f 100755--- a/services/camera/libcameraservice/CameraService.cpp+++ b/services/camera/libcameraservice/CameraService.cpp@@ -41,6 +41,7 @@ #include &lt;media/AudioSystem.h&gt; #include &lt;media/IMediaHTTPService.h&gt; #include &lt;media/mediaplayer.h&gt;+#include &lt;media/MediaProfiles.h&gt; #include &lt;mediautils/BatteryNotifier.h&gt; #include &lt;utils/Errors.h&gt; #include &lt;utils/Log.h&gt;@@ -428,15 +428,30 @@ void CameraService::onTorchStatusChangedLocked(const String8&amp; cameraId, Status CameraService::getNumberOfCameras(int32_t type, int32_t* numCameras) &#123; ATRACE_CALL();+ char value[PROPERTY_VALUE_MAX]; switch (type) &#123; case CAMERA_TYPE_BACKWARD_COMPATIBLE: if(0 == mNumberOfNormalCameras) &#123; ALOGE(&quot;No camera be found ! check again...&quot;); onFirstRef(); &#125;+ property_get(&quot;persist.sys.usbcamera.status&quot;, value, &quot;&quot;);+ if((strcmp(value, &quot;add&quot;) == 0)||(strcmp(value, &quot;remove&quot;) == 0))&#123;+ mNumberOfCameras = mModule-&gt;getNumberOfCameras();+ mNumberOfNormalCameras = mNumberOfCameras;+ ALOGI(&quot;CameraService::getNumberOfCameras() = %d&quot;,mNumberOfCameras);+ onFirstRef();+ MediaProfiles::getInstance();+ &#125; *numCameras = mNumberOfNormalCameras; break; case CAMERA_TYPE_ALL:+ property_get(&quot;persist.sys.usbcamera.status&quot;, value, &quot;&quot;);+ if((strcmp(value, &quot;add&quot;) == 0)||(strcmp(value, &quot;remove&quot;) == 0))&#123;+ mNumberOfCameras = mModule-&gt;getNumberOfCameras();+ mNumberOfNormalCameras = mNumberOfCameras;+ ALOGI(&quot;CameraService::getNumberOfCameras() = %d&quot;,mNumberOfCameras);+ onFirstRef();+ MediaProfiles::getInstance();+ &#125; *numCameras = mNumberOfCameras; break; default: framework部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102diff --git a/core/java/android/content/Intent.java b/core/java/android/content/Intent.javaindex d08a471..a25335d 100644--- a/core/java/android/content/Intent.java+++ b/core/java/android/content/Intent.java@@ -4227,6 +4227,18 @@ public class Intent implements Parcelable, Cloneable &#123; | Intent.FLAG_GRANT_WRITE_URI_PERMISSION)) != 0; &#125;+ /**+ *for Action_USB_CAMRA,remove and add action+ */+ /**&#123;@hide&#125;*/+ public static final int FLAG_USB_CAMERA_REMOVE = 0x00008001;+ /**&#123;@hide&#125;*/+ public static final int FLAG_USB_CAMERA_ADD = 0x00008002;+ + //add this action intent for usb remove /add+ /** &#123;@hide&#125; */+ public static final String ACTION_USB_CAMERA = &quot;android.intent.action.USB_CAMERA&quot;;+ /** * If set, the recipient of this Intent will be granted permission to * perform read operations on the URI in the Intent&apos;s data and any URIsdiff --git a/services/usb/java/com/android/server/usb/UsbDeviceManager.java b/services/usb/java/com/android/server/usb/UsbDeviceManager.javaindex 8eb0feb..5b32399 100644--- a/services/usb/java/com/android/server/usb/UsbDeviceManager.java+++ b/services/usb/java/com/android/server/usb/UsbDeviceManager.java@@ -103,6 +103,10 @@ public class UsbDeviceManager &#123; &quot;/sys/class/android_usb/android0/f_audio_source/pcm&quot;; private static final String MIDI_ALSA_PATH = &quot;/sys/class/android_usb/android0/f_midi/alsa&quot;;+ private static final String USB_CAMERA_MATCH =+ &quot;DEVPATH=/devices&quot;; private static final int MSG_UPDATE_STATE = 0; private static final int MSG_ENABLE_ADB = 1;@@ -152,6 +156,9 @@ public class UsbDeviceManager &#123; private UsbDebuggingManager mDebuggingManager; private final UsbAlsaManager mUsbAlsaManager; private Intent mBroadcastedIntent;+ + private long mLastUsbEvent = 0;+ private String mLastUsbAction = &quot;&quot;; private boolean mCharging=false; private class AdbSettingsObserver extends ContentObserver &#123;@@ -172,7 +179,44 @@ public class UsbDeviceManager &#123; private final UEventObserver mUEventObserver = new UEventObserver() &#123; @Override public void onUEvent(UEventObserver.UEvent event) &#123;- if (DEBUG) Slog.v(TAG, &quot;USB UEVENT: &quot; + event.toString());+ if (true) Slog.v(TAG, &quot;USB UEVENT: &quot; + event.toString());++ String subSystem = event.get(&quot;SUBSYSTEM&quot;);+ String devPath = event.get(&quot;DEVPATH&quot;);+ Slog.d(TAG, &quot;subSystem:&quot; + subSystem + &quot;,devPath:&quot; + devPath);+ if (devPath != null &amp;&amp; devPath.contains(&quot;/devices&quot;)) &#123;+ if (&quot;video4linux&quot;.equals(subSystem)) &#123;+ Slog.i(TAG, &quot;USB UEVENT: &quot; + event.toString());+ Intent intent = new Intent(Intent.ACTION_USB_CAMERA);+ String action = event.get(&quot;ACTION&quot;);+ try &#123;+ if (mLastUsbAction != null &amp;&amp; mLastUsbAction.equals(action) + &amp;&amp; SystemClock.uptimeMillis() - mLastUsbEvent &lt; 1200) &#123;+ Slog.i(TAG, &quot;USB UEVENT send double, ignore this!&quot;);+ return;+ &#125;+ &#125; catch (Exception e) &#123;+ e.printStackTrace();+ &#125;+ mLastUsbAction = action;+ mLastUsbEvent = SystemClock.uptimeMillis();+ if (&quot;remove&quot;.equals(action))&#123;+ Slog.d(TAG,&quot;usb camera remove=====&quot;);+ intent.setFlags(Intent.FLAG_USB_CAMERA_REMOVE);+ SystemProperties.set(&quot;persist.sys.usbcamera.status&quot;,&quot;remove&quot;);+ SystemProperties.set(&quot;sys.usbcam.status.forvideo&quot;,&quot;removed&quot;);+ &#125; else if (&quot;add&quot;.equals(action)) &#123;+ Slog.d(TAG,&quot;usb camera add=====&quot;);+ intent.setFlags(Intent.FLAG_USB_CAMERA_ADD);+ SystemProperties.set(&quot;persist.sys.usbcamera.status&quot;,&quot;add&quot;);+ SystemProperties.set(&quot;sys.usbcam.status.forvideo&quot;,&quot;added&quot;);+ &#125;++ int num = android.hardware.Camera.getNumberOfCameras();+ mContext.sendBroadcastAsUser(intent,UserHandle.ALL);+ SystemProperties.set(&quot;persist.sys.usbcamera.status&quot;,&quot;&quot;);+ Slog.d(TAG,&quot;usb camera num&quot;+num);+ &#125;+ &#125; String state = event.get(&quot;USB_STATE&quot;); String accessory = event.get(&quot;ACCESSORY&quot;);@@ -379,6 +423,8 @@ public class UsbDeviceManager &#123; // Watch for USB configuration changes mUEventObserver.startObserving(USB_STATE_MATCH); mUEventObserver.startObserving(ACCESSORY_START_MATCH);++ mUEventObserver.startObserving(USB_CAMERA_MATCH); &#125; catch (Exception e) &#123; Slog.e(TAG, &quot;Error initializing UsbHandler&quot;, e); &#125;","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android7.1 RK3399 Codec rt5640 移植.md","slug":"Android_Driver/Driver/[Android7.1][RK3399] Codec rt5640 移植","date":"2018-01-31T15:33:05.000Z","updated":"2018-11-08T02:47:52.125Z","comments":true,"path":"2018/01/31/Android_Driver/Driver/[Android7.1][RK3399] Codec rt5640 移植/","link":"","permalink":"http://iyounix.com/2018/01/31/Android_Driver/Driver/[Android7.1][RK3399] Codec rt5640 移植/","excerpt":"","text":"Platform: RK3399OS: Android 7.1Kernel: v4.4.83 [TOC] 硬件原理图 数据走I2S1通道 控制走I2C1通道 输出走HPOUTL/HPOUTR DTS 修改./rk3399-excavator-sapphire.dtsi参考 rt5651-sound 的配置:1234567891011121314151617181920rt5651-sound &#123; compatible = &quot;simple-audio-card&quot;; simple-audio-card,format = &quot;i2s&quot;; simple-audio-card,name = &quot;realtek,rt5651-codec&quot;; simple-audio-card,mclk-fs = &lt;256&gt;; simple-audio-card,widgets = &quot;Microphone&quot;, &quot;Mic Jack&quot;, &quot;Headphone&quot;, &quot;Headphone Jack&quot;; simple-audio-card,routing = &quot;Mic Jack&quot;, &quot;MICBIAS1&quot;, &quot;IN1P&quot;, &quot;Mic Jack&quot;, &quot;Headphone Jack&quot;, &quot;HPOL&quot;, &quot;Headphone Jack&quot;, &quot;HPOR&quot;; simple-audio-card,cpu &#123; sound-dai = &lt;&amp;i2s0&gt;; &#125;; simple-audio-card,codec &#123; sound-dai = &lt;&amp;rt5651&gt;; &#125;; &#125;; 完成 rt5640 DTS 的配置:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 rt5640-sound &#123; compatible = &quot;simple-audio-card&quot;; simple-audio-card,format = &quot;i2s&quot;; simple-audio-card,name = &quot;rockchip,rt5640-codec&quot;; simple-audio-card,mclk-fs = &lt;256&gt;; simple-audio-card,widgets = &quot;Microphone&quot;, &quot;Mic Jack&quot;, &quot;Headphone&quot;, &quot;Headphone Jack&quot;; simple-audio-card,routing = &quot;Mic Jack&quot;, &quot;MICBIAS1&quot;, &quot;IN1P&quot;, &quot;Mic Jack&quot;, &quot;Headphone Jack&quot;, &quot;HPOL&quot;, &quot;Headphone Jack&quot;, &quot;HPOR&quot;; simple-audio-card,cpu &#123; sound-dai = &lt;&amp;i2s1&gt;; &#125;; simple-audio-card,codec &#123; sound-dai = &lt;&amp;rt5640&gt;; &#125;; &#125;; &amp;i2s1 &#123; status = &quot;okay&quot;; rockchip,i2s-broken-burst-len; rockchip,playback-channels = &lt;8&gt;; rockchip,capture-channels = &lt;8&gt;; #sound-dai-cells = &lt;0&gt;;&#125;;&amp;i2c1 &#123; status = &quot;okay&quot;; i2c-scl-rising-time-ns = &lt;140&gt;; i2c-scl-falling-time-ns = &lt;30&gt;; rt5640: rt5640@1c &#123; #sound-dai-cells = &lt;0&gt;; compatible = &quot;realtek,rt5640&quot;; reg = &lt;0x1c&gt;; clocks = &lt;&amp;cru SCLK_I2S_8CH_OUT&gt;; clock-names = &quot;mclk&quot;; realtek,in1-differential; pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;rt5640_hpcon &amp;i2s_8ch_mclk&gt;; io-channels = &lt;&amp;saradc 4&gt;; hp-det-adc-value = &lt;500&gt;; status = &quot;okay&quot;; &#125;;&#125;; Driver 修改clock 的 driver 部分对应进行修改:rk3399.dtsi123456789101112diff --git a/arch/arm64/boot/dts/rockchip/rk3399.dtsi b/arch/arm64/boot/dts/rockchip/rk3399.dtsiindex d3f0f76..1759a91 100644--- a/arch/arm64/boot/dts/rockchip/rk3399.dtsi+++ b/arch/arm64/boot/dts/rockchip/rk3399.dtsi@@ -1692,6 +1692,9 @@ dma-names = &quot;tx&quot;, &quot;rx&quot;; clock-names = &quot;i2s_clk&quot;, &quot;i2s_hclk&quot;; clocks = &lt;&amp;cru SCLK_I2S1_8CH&gt;, &lt;&amp;cru HCLK_I2S1_8CH&gt;;+ assigned-clocks = &lt;&amp;cru SCLK_I2S_8CH&gt;;+ assigned-clock-parents = &lt;&amp;cru SCLK_I2S1_8CH&gt;; pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;i2s1_2ch_bus&gt;; clk-rk3399.c123456789101112131415diff --git a/drivers/clk/rockchip/clk-rk3399.c b/drivers/clk/rockchip/clk-rk3399.cindex b0e4daa..e2d872f 100644--- a/drivers/clk/rockchip/clk-rk3399.c+++ b/drivers/clk/rockchip/clk-rk3399.c@@ -711,8 +711,9 @@ static struct rockchip_clk_branch rk3399_clk_branches[] __initdata = &#123; &amp;rk3399_i2s2_fracmux), GATE(SCLK_I2S2_8CH, &quot;clk_i2s2&quot;, &quot;clk_i2s2_mux&quot;, CLK_SET_RATE_PARENT, RK3399_CLKGATE_CON(8), 11, GFLAGS),-- MUX(0, &quot;clk_i2sout_src&quot;, mux_i2sch_p, CLK_SET_RATE_PARENT,+ //MUX(0, &quot;clk_i2sout_src&quot;, mux_i2sch_p, CLK_SET_RATE_PARENT,+ MUX(SCLK_I2S_8CH, &quot;clk_i2sout_src&quot;, mux_i2sch_p, CLK_SET_RATE_PARENT, RK3399_CLKSEL_CON(31), 0, 2, MFLAGS), COMPOSITE_NODIV(SCLK_I2S_8CH_OUT, &quot;clk_i2sout&quot;, mux_i2sout_p, CLK_SET_RATE_PARENT, RK3399_CLKSEL_CON(30), 8, 2, MFLAGS, pl330.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189diff --git a/drivers/dma/pl330.c b/drivers/dma/pl330.cindex 1e5c79b..08179f5 100644--- a/drivers/dma/pl330.c+++ b/drivers/dma/pl330.c@@ -1169,6 +1169,16 @@ static inline int _ldst_devtomem(struct pl330_dmac *pl330, unsigned dry_run, off += _emit_WFP(dry_run, &amp;buf[off], cond, pxs-&gt;desc-&gt;peri); off += _emit_LDP(dry_run, &amp;buf[off], cond, pxs-&gt;desc-&gt;peri); off += _emit_ST(dry_run, &amp;buf[off], ALWAYS);+#ifdef CONFIG_ARCH_ROCKCHIP+ /*+ * Make suree dma has finish transmission, or later flush may+ * cause dma second transmission,and fifo is overrun.+ */+ off += _emit_WMB(dry_run, &amp;buf[off]);+ off += _emit_NOP(dry_run, &amp;buf[off]);+ off += _emit_WMB(dry_run, &amp;buf[off]);+ off += _emit_NOP(dry_run, &amp;buf[off]);+#endif if (!(pl330-&gt;quirks &amp; PL330_QUIRK_BROKEN_NO_FLUSHP)) off += _emit_FLUSHP(dry_run, &amp;buf[off],@@ -1189,6 +1199,16 @@ static inline int _ldst_memtodev(struct pl330_dmac *pl330, off += _emit_WFP(dry_run, &amp;buf[off], cond, pxs-&gt;desc-&gt;peri); off += _emit_LD(dry_run, &amp;buf[off], ALWAYS); off += _emit_STP(dry_run, &amp;buf[off], cond, pxs-&gt;desc-&gt;peri);+#ifdef CONFIG_ARCH_ROCKCHIP+ /*+ * Make suree dma has finish transmission, or later flush may+ * cause dma second transmission,and fifo is overrun.+ */+ off += _emit_WMB(dry_run, &amp;buf[off]);+ off += _emit_NOP(dry_run, &amp;buf[off]);+ off += _emit_WMB(dry_run, &amp;buf[off]);+ off += _emit_NOP(dry_run, &amp;buf[off]);+#endif if (!(pl330-&gt;quirks &amp; PL330_QUIRK_BROKEN_NO_FLUSHP)) off += _emit_FLUSHP(dry_run, &amp;buf[off],@@ -1327,7 +1347,11 @@ static inline int _loop_cyclic(struct pl330_dmac *pl330, unsigned dry_run, /* forever loop */ off += _emit_MOV(dry_run, &amp;buf[off], SAR, x-&gt;src_addr); off += _emit_MOV(dry_run, &amp;buf[off], DAR, x-&gt;dst_addr);-+#ifdef CONFIG_ARCH_ROCKCHIP+ if (!(pl330-&gt;quirks &amp; PL330_QUIRK_BROKEN_NO_FLUSHP))+ off += _emit_FLUSHP(dry_run, &amp;buf[off],+ pxs-&gt;desc-&gt;peri);+#endif /* loop0 */ off += _emit_LP(dry_run, &amp;buf[off], 0, lcnt0); ljmp0 = off;@@ -1366,7 +1390,7 @@ static inline int _loop_cyclic(struct pl330_dmac *pl330, unsigned dry_run, ccr &amp;= ~(0xf &lt;&lt; CC_SRCBRSTLEN_SHFT); ccr &amp;= ~(0xf &lt;&lt; CC_DSTBRSTLEN_SHFT); off += _emit_MOV(dry_run, &amp;buf[off], CCR, ccr);- off += _emit_LP(dry_run, &amp;buf[off], 1, c - 1);+ off += _emit_LP(dry_run, &amp;buf[off], 1, c); ljmp1 = off; off += _bursts(pl330, dry_run, &amp;buf[off], pxs, 1); lpend.cond = ALWAYS;@@ -1403,7 +1427,11 @@ static inline int _setup_loops(struct pl330_dmac *pl330, u32 ccr = pxs-&gt;ccr; unsigned long c, bursts = BYTE_TO_BURST(x-&gt;bytes, ccr); int off = 0;-+#ifdef CONFIG_ARCH_ROCKCHIP+ if (!(pl330-&gt;quirks &amp; PL330_QUIRK_BROKEN_NO_FLUSHP))+ off += _emit_FLUSHP(dry_run, &amp;buf[off],+ pxs-&gt;desc-&gt;peri);+#endif while (bursts) &#123; c = bursts; off += _loop(pl330, dry_run, &amp;buf[off], &amp;c, pxs);@@ -1757,16 +1785,17 @@ static int pl330_update(struct pl330_dmac *pl330) /* Detach the req */ descdone = thrd-&gt;req[active].desc;+ if (descdone) &#123;+ if (!descdone-&gt;cyclic) &#123;+ thrd-&gt;req[active].desc = NULL;+ thrd-&gt;req_running = -1;+ /* Get going again ASAP */+ _start(thrd);+ &#125;- if (!descdone-&gt;cyclic) &#123;- thrd-&gt;req[active].desc = NULL;- thrd-&gt;req_running = -1;- /* Get going again ASAP */- _start(thrd);+ /* For now, just make a list of callbacks to be done */+ list_add_tail(&amp;descdone-&gt;rqd, &amp;pl330-&gt;req_done); &#125;-- /* For now, just make a list of callbacks to be done */- list_add_tail(&amp;descdone-&gt;rqd, &amp;pl330-&gt;req_done); &#125; &#125;@@ -1817,7 +1846,6 @@ static bool _chan_ns(const struct pl330_dmac *pl330, int i) static struct pl330_thread *pl330_request_channel(struct pl330_dmac *pl330) &#123; struct pl330_thread *thrd = NULL;- unsigned long flags; int chans, i; if (pl330-&gt;state == DYING)@@ -1825,8 +1853,6 @@ static struct pl330_thread *pl330_request_channel(struct pl330_dmac *pl330) chans = pl330-&gt;pcfg.num_chan;- spin_lock_irqsave(&amp;pl330-&gt;lock, flags);- for (i = 0; i &lt; chans; i++) &#123; thrd = &amp;pl330-&gt;channels[i]; if ((thrd-&gt;free) &amp;&amp; (!_manager_ns(thrd) ||@@ -1844,8 +1870,6 @@ static struct pl330_thread *pl330_request_channel(struct pl330_dmac *pl330) thrd = NULL; &#125;- spin_unlock_irqrestore(&amp;pl330-&gt;lock, flags);- return thrd; &#125;@@ -1863,7 +1887,6 @@ static inline void _free_event(struct pl330_thread *thrd, int ev) static void pl330_release_channel(struct pl330_thread *thrd) &#123; struct pl330_dmac *pl330;- unsigned long flags; if (!thrd || thrd-&gt;free) return;@@ -1875,10 +1898,8 @@ static void pl330_release_channel(struct pl330_thread *thrd) pl330 = thrd-&gt;dmac;- spin_lock_irqsave(&amp;pl330-&gt;lock, flags); _free_event(thrd, thrd-&gt;ev); thrd-&gt;free = true;- spin_unlock_irqrestore(&amp;pl330-&gt;lock, flags); &#125; /* Initialize the structure for PL330 configuration, that can be used@@ -2248,19 +2269,19 @@ static int pl330_alloc_chan_resources(struct dma_chan *chan) struct pl330_dmac *pl330 = pch-&gt;dmac; unsigned long flags;- spin_lock_irqsave(&amp;pch-&gt;lock, flags);+ spin_lock_irqsave(&amp;pl330-&gt;lock, flags); dma_cookie_init(chan); pch-&gt;thread = pl330_request_channel(pl330); if (!pch-&gt;thread) &#123;- spin_unlock_irqrestore(&amp;pch-&gt;lock, flags);+ spin_unlock_irqrestore(&amp;pl330-&gt;lock, flags); return -ENOMEM; &#125; tasklet_init(&amp;pch-&gt;task, pl330_tasklet, (unsigned long) pch);- spin_unlock_irqrestore(&amp;pch-&gt;lock, flags);+ spin_unlock_irqrestore(&amp;pl330-&gt;lock, flags); return 1; &#125;@@ -2363,19 +2384,20 @@ static int pl330_pause(struct dma_chan *chan) static void pl330_free_chan_resources(struct dma_chan *chan) &#123; struct dma_pl330_chan *pch = to_pchan(chan);+ struct pl330_dmac *pl330 = pch-&gt;dmac; unsigned long flags; tasklet_kill(&amp;pch-&gt;task); pm_runtime_get_sync(pch-&gt;dmac-&gt;ddma.dev);- spin_lock_irqsave(&amp;pch-&gt;lock, flags);+ spin_lock_irqsave(&amp;pl330-&gt;lock, flags); pl330_release_channel(pch-&gt;thread); pch-&gt;thread = NULL; list_splice_tail_init(&amp;pch-&gt;work_list, &amp;pch-&gt;dmac-&gt;desc_pool);- spin_unlock_irqrestore(&amp;pch-&gt;lock, flags);+ spin_unlock_irqrestore(&amp;pl330-&gt;lock, flags); pm_runtime_mark_last_busy(pch-&gt;dmac-&gt;ddma.dev); pm_runtime_put_autosuspend(pch-&gt;dmac-&gt;ddma.dev); rk3399-cru.h12345678910111213diff --git a/include/dt-bindings/clock/rk3399-cru.h b/include/dt-bindings/clock/rk3399-cru.hindex 37e665f..54ac812 100644--- a/include/dt-bindings/clock/rk3399-cru.h+++ b/include/dt-bindings/clock/rk3399-cru.h@@ -226,6 +226,9 @@ #define ACLK_GIC_PRE 262 #define ACLK_VOP0_PRE 263 #define ACLK_VOP1_PRE 264+#define SCLK_I2S_8CH 265+ /* pclk gates */ #define PCLK_PERIHP 320 遇到问题","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android7.1 RK3399 只保留 USB Camera (去掉对 Mipi DVP Camera 的支持)","slug":"Android_Driver/Debug/[Android7.1][RK3399] 只保留 USB Camera (去掉对 Mipi DVP Camera 的支持)","date":"2018-01-31T15:33:05.000Z","updated":"2018-11-08T02:53:19.989Z","comments":true,"path":"2018/01/31/Android_Driver/Debug/[Android7.1][RK3399] 只保留 USB Camera (去掉对 Mipi DVP Camera 的支持)/","link":"","permalink":"http://iyounix.com/2018/01/31/Android_Driver/Debug/[Android7.1][RK3399] 只保留 USB Camera (去掉对 Mipi DVP Camera 的支持)/","excerpt":"","text":"Platform: RK3399OS: Android 7.1Kernel: v4.4.83 [TOC] 应用场景rk3399平台可以支持多种不同接口的Camera,如MIPI, DVP, UVC camera。对于DVP,MIPI的Camera,对应的配置是放在cam_board.xml的。因此如果只使用UVC Camera，那么只要移除此文件就可以了。 解决方案12345678--- a/Config/rk32xx_camera.mk+++ b/Config/rk32xx_camera.mk hardware/rockchip/camera/SiliconImage/isi/drv/GS8604/calib/GS8604_lens_9569A2.xml:system/etc/GS8604_lens_9569A2.xml \\ hardware/rockchip/camera/SiliconImage/isi/drv/GS8604/calib/GS8604_lens_40100A.xml:system/etc/GS8604_lens_40100A.xml \\ hardware/rockchip/camera/SiliconImage/isi/drv/OV2680/calib/OV2680.xml:system/etc/OV2680.xml \\- hardware/rockchip/camera/SiliconImage/isi/drv/HM5040/calib/HM5040.xml:system/etc/HM5040.xml \\- hardware/rockchip/camera/Config/cam_board_rk3399.xml:system/etc/cam_board.xml+ hardware/rockchip/camera/SiliconImage/isi/drv/HM5040/calib/HM5040.xml:system/etc/HM5040.xml+ #hardware/rockchip/camera/Config/cam_board_rk3399.xml:system/etc/cam_board.xml 改动之后，camera_get_number_of_cameras()中的读取cam_board.xml的代码就会失效，相关代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int camera_get_number_of_cameras(void)&#123;.... profiles = camera_board_profiles::getInstance(); nCamDev = profiles-&gt;mDevieVector.size(); LOGD(&quot;board profiles cam num %d\\n&quot;, nCamDev); //由于读取不到配置，所以nCamDev为0. if (nCamDev&gt;0)&#123; camera_board_profiles::LoadSensor(profiles); char sensor_ver[32]; for (i=0; (i&lt;nCamDev); i++) &#123; LOGE(&quot;load sensor name(%s) connect %d\\n&quot;, profiles-&gt;mDevieVector[i]-&gt;mHardInfo.mSensorInfo.mSensorName, profiles-&gt;mDevieVector[i]-&gt;mIsConnect); if(profiles-&gt;mDevieVector[i]-&gt;mIsConnect==1)&#123; rk_sensor_info *pSensorInfo = &amp;(profiles-&gt;mDevieVector[i]-&gt;mHardInfo.mSensorInfo); camInfoTmp[cam_cnt&amp;0x01].pcam_total_info = profiles-&gt;mDevieVector[i]; strncpy(camInfoTmp[cam_cnt&amp;0x01].device_path, pSensorInfo-&gt;mCamsysDevPath, sizeof(camInfoTmp[cam_cnt&amp;0x01].device_path)); strncpy(camInfoTmp[cam_cnt&amp;0x01].driver, pSensorInfo-&gt;mSensorDriver, sizeof(camInfoTmp[cam_cnt&amp;0x01].driver)); unsigned int SensorDrvVersion = profiles-&gt;mDevieVector[i]-&gt;mLoadSensorInfo.mpI2cInfo-&gt;sensor_drv_version; memset(version,0x00,sizeof(version)); sprintf(version,&quot;%d.%d.%d&quot;,((SensorDrvVersion&amp;0xff0000)&gt;&gt;16), ((SensorDrvVersion&amp;0xff00)&gt;&gt;8),SensorDrvVersion&amp;0xff); if(pSensorInfo-&gt;mFacing == RK_CAM_FACING_FRONT)&#123; camInfoTmp[cam_cnt&amp;0x01].facing_info.facing = CAMERA_FACING_FRONT; &#125; else &#123; camInfoTmp[cam_cnt&amp;0x01].facing_info.facing = CAMERA_FACING_BACK; &#125; memset(sensor_ver,0x00,sizeof(sensor_ver)); if (strlen(pSensorInfo-&gt;mSensorName) &lt; (sizeof(sensor_ver)-16)) sprintf(sensor_ver,&quot;%s%s%s&quot;,&quot;sys_graphic.&quot;,pSensorInfo-&gt;mSensorName,&quot;.ver&quot;); else sprintf(sensor_ver,&quot;%s&quot;,pSensorInfo-&gt;mSensorName); property_set(sensor_ver, version); camInfoTmp[cam_cnt&amp;0x01].facing_info.orientation = pSensorInfo-&gt;mOrientation; cam_cnt++; unsigned int CamsysDrvVersion = profiles-&gt;mDevieVector[i]-&gt;mCamsysVersion.drv_ver; memset(version,0x00,sizeof(version)); sprintf(version,&quot;%d.%d.%d&quot;,((CamsysDrvVersion&amp;0xff0000)&gt;&gt;16), ((CamsysDrvVersion&amp;0xff00)&gt;&gt;8),CamsysDrvVersion&amp;0xff); property_set(CAMERAHAL_CAMSYS_VERSION_PROPERTY_KEY,version); &#125; &#125; &#125; ...&#125;","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android7.1 RK3399 添加对三路以上 Camera 同时预览的支持","slug":"Android_Driver/Debug/[Android7.1][RK3399] 添加对三路以上 Camera 同时预览的支持","date":"2018-01-31T15:33:05.000Z","updated":"2018-11-08T02:54:28.428Z","comments":true,"path":"2018/01/31/Android_Driver/Debug/[Android7.1][RK3399] 添加对三路以上 Camera 同时预览的支持/","link":"","permalink":"http://iyounix.com/2018/01/31/Android_Driver/Debug/[Android7.1][RK3399] 添加对三路以上 Camera 同时预览的支持/","excerpt":"","text":"Platform: RK3399OS: Android 7.1Kernel: v4.4.83 [TOC] 思路系统默认只支持两路Camera,只要将CameraHal中的数量限制改掉就可以了。 (由 2 改为 10)另外，有些地方直接用0和1表示Camera通道，也要做相应修改。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283diff --git a/CameraHal/CameraHal_Module.cpp b/CameraHal/CameraHal_Module.cppindex 01afa0d..07380f2 100755--- a/CameraHal/CameraHal_Module.cpp+++ b/CameraHal/CameraHal_Module.cpp@@ -835,7 +839,7 @@ int camera_get_number_of_cameras(void) fd = open(cam_path, O_RDONLY); if (fd &lt; 0) &#123; LOGE(&quot;Open %s failed! strr: %s&quot;,cam_path,strerror(errno));- break;+ continue; &#125; LOGD(&quot;Open %s success!&quot;,cam_path);@@ -849,13 +853,13 @@ int camera_get_number_of_cameras(void) LOGD(&quot;Video device(%s): video capture not supported.\\n&quot;,cam_path); &#125; else &#123; rk_cam_total_info* pNewCamInfo = new rk_cam_total_info();- memset(camInfoTmp[cam_cnt&amp;0x01].device_path,0x00, sizeof(camInfoTmp[cam_cnt&amp;0x01].device_path));- strcat(camInfoTmp[cam_cnt&amp;0x01].device_path,cam_path);- memset(camInfoTmp[cam_cnt&amp;0x01].fival_list,0x00, sizeof(camInfoTmp[cam_cnt&amp;0x01].fival_list));- memcpy(camInfoTmp[cam_cnt&amp;0x01].driver,capability.driver, sizeof(camInfoTmp[cam_cnt&amp;0x01].driver));- camInfoTmp[cam_cnt&amp;0x01].version = capability.version;+ memset(camInfoTmp[cam_cnt].device_path,0x00, sizeof(camInfoTmp[cam_cnt].device_path));+ strcat(camInfoTmp[cam_cnt].device_path,cam_path);+ memset(camInfoTmp[cam_cnt].fival_list,0x00, sizeof(camInfoTmp[cam_cnt].fival_list));+ memcpy(camInfoTmp[cam_cnt].driver,capability.driver, sizeof(camInfoTmp[cam_cnt].driver));+ camInfoTmp[cam_cnt].version = capability.version; if (strstr((char*)&amp;capability.card[0], &quot;front&quot;) != NULL) &#123;- camInfoTmp[cam_cnt&amp;0x01].facing_info.facing = CAMERA_FACING_FRONT;+ camInfoTmp[cam_cnt].facing_info.facing = CAMERA_FACING_FRONT; #ifdef LAPTOP &#125; else if (strstr((char*)&amp;capability.card[0], &quot;HP HD&quot;) != NULL || strstr((char*)&amp;capability.card[0], &quot;HP IR&quot;)) &#123;@@ -866,14 +870,14 @@ int camera_get_number_of_cameras(void) LOGD(&quot;Camera %d name: %s&quot;, (cam_cnt&amp;0x01), gUsbCameraNames[cam_cnt&amp;0x01].string()); #endif &#125; else &#123;- camInfoTmp[cam_cnt&amp;0x01].facing_info.facing = CAMERA_FACING_BACK;+ camInfoTmp[cam_cnt].facing_info.facing = CAMERA_FACING_BACK; &#125; ptr = strstr((char*)&amp;capability.card[0],&quot;-&quot;); if (ptr != NULL) &#123; ptr++;- camInfoTmp[cam_cnt&amp;0x01].facing_info.orientation = atoi(ptr);+ camInfoTmp[cam_cnt].facing_info.orientation = atoi(ptr); &#125; else &#123;- camInfoTmp[cam_cnt&amp;0x01].facing_info.orientation = 0;+ camInfoTmp[cam_cnt].facing_info.orientation = 0; &#125; memset(version,0x00,sizeof(version));@@ -1207,8 +1211,11 @@ int camera_get_number_of_cameras(void) &#125; #endif- memcpy(&amp;gCamInfos[0], &amp;camInfoTmp[0], sizeof(rk_cam_info_t));- memcpy(&amp;gCamInfos[1], &amp;camInfoTmp[1], sizeof(rk_cam_info_t));+ for (int i = 0; i &lt; gCamerasNumber; i++) &#123;+ memcpy(&amp;gCamInfos[i], &amp;camInfoTmp[i], sizeof(rk_cam_info_t));+ &#125; property_get(&quot;ro.sf.hwrotation&quot;, property, &quot;0&quot;); diff --git a/CameraHal/CameraHal_Module.h b/CameraHal/CameraHal_Module.hindex 45c81ec..69be491 100755--- a/CameraHal/CameraHal_Module.h+++ b/CameraHal/CameraHal_Module.h@@ -11,11 +11,11 @@ using namespace android; #define CAMERA_DEFAULT_PREVIEW_FPS_MIN 8000 //8 fps #define CAMERA_DEFAULT_PREVIEW_FPS_MAX 15000 #endif-#define CAMERAS_SUPPORT_MAX 2+#define CAMERAS_SUPPORT_MAX 10 #if defined(TARGET_RK3399)- #define CAMERAS_SUPPORTED_SIMUL_MAX 2+ #define CAMERAS_SUPPORTED_SIMUL_MAX 10 #else- #define CAMERAS_SUPPORTED_SIMUL_MAX 1+ #define CAMERAS_SUPPORTED_SIMUL_MAX 10 #endif #define CAMERA_DEVICE_NAME &quot;/dev/video&quot; #define CAMERA_MODULE_NAME &quot;RK29_ICS_CameraHal_Module&quot; 注意因为Android只定义了Front和Back两种Camera属性，所以不能使用默认的APK测试。","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 启动流程分析之二init分析","slug":"Android_Sys/[Android6.0] 启动流程分析之二init分析","date":"2017-12-31T15:33:06.000Z","updated":"2018-11-08T02:21:45.876Z","comments":true,"path":"2017/12/31/Android_Sys/[Android6.0] 启动流程分析之二init分析/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_Sys/[Android6.0] 启动流程分析之二init分析/","excerpt":"","text":"init 进程解析 init.rc 并启动 Zygote 进程system/core/rootdir/init.rc1import /init.$&#123;ro.zygote&#125;.rc system/core/rootdir/init.zygote32.rc12345678service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server class main socket zygote stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart media onrestart restart netd writepid /dev/cpuset/foreground/tasks 可以看到 zygote 实际上对应的是 app_process 进程 启动 app_process 进程（Zygote）frameworks/base/cmds/app_process/app_main.cpp可以看到上面的传参有 –zygote, –start-system-server 根据 zygote 参数： 将 app_process 更名为 zygote 执行 AppRuntime 的 start() 方法（实际上为其父类 AndroidRuntime 的 start() 的方法） 利用 start() 方法启动 ZygoteInit 类的 main()123if(zygote)&#123; runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote);&#125;else&#123;...&#125; 根据 start-system-server 参数：123if (startSystemServer) &#123; args.add(String8(&quot;start-system-server&quot;));&#125; 将此参数传入 args，并作为参数传入 ZygoteInit 类的 main()那么start() 具体是如何启动 ZygoteInit 类的呢？我们研究一下它的 start() 方法 AppRuntime 中的 start 方法实际上调用的是其父类 AndroidRuntime 的方法 start() AndroidRuntime 类中的 start 方法framework/base/core/jni/AndroidRuntime.cpp 在 start() 里面 创建了 Java 虚拟机（startVm(&amp;mJavaVM, &amp;env, zygote)） 注册了 JNI 的函数（startReg(env)） 返回 ZygoteInit 的 main() （ env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);） 1void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote) 注意参数中className 是 com.android.internal.os.ZygoteInitoptions 中有 start-system-server 这个选项设置 strArray：123jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string());env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr);... 查找 startClass，获得 startMeth。//找到类 ZygoteInit，获得 类中“main”方法的 ID startMeth并执行 main。123 jclass startClass = env-&gt;FindClass(slashClassName);jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, \"main\",\"([Ljava/lang/String;)V\"); env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray); 启动了 ZygoteInit 类中的 main()至此，进入了 Java 的世界。 ZygoteInit 类中的 main 与 startSystemServerframeworks/base/core/java/com/android/internal/os/ZygoteInit.java12345678910111213141516171819202122232425262728public static void main(String argv[]) &#123; try &#123; ... String socketName = \"zygote\"; ... //注册server socket zygoteServer.registerZygoteSocket(socketName); ... //预加载 1. 常用系统资源 2. 图形相关的（OpenGL） 3. 必要的库（SharedLibraries）4... //Zygote 进程预先加载这些类和资源，在以后 fork 子进程的时候，仅需做复制就可以（根据 fork 的 copy-on-write 机制，有些类不做改变的话，甚至不用复制，子进程和父进程共享数据，可以达到省内存的目的） preload(); ... if (startSystemServer) &#123; //启动system server startSystemServer(abiList, socketName, zygoteServer); &#125; //zygote进程进入无限循环，处理请求 zygoteServer.runSelectLoop(abiList); zygoteServer.closeServerSocket(); &#125; catch (Zygote.MethodAndArgsCaller caller) &#123; //通过反射调用新进程函数的地方 //后续介绍新进程启动时，再介绍 caller.run(); &#125; catch (RuntimeException ex) &#123; closeServerSocket(); throw ex; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243 private static boolean startSystemServer(String abiList, String socketName) &#123; //准备capabilities参数 ........ String args[] = &#123; \"--setuid=1000\", \"--setgid=1000\", \"--setgroups=.........\", \"--capabilities=\" + capabilities + \",\" + capabilities, \"--nice-name=system_server\", \"--runtime-args\", \"com.android.server.SystemServer\", &#125;; ZygoteConnection.Arguments parsedArgs = null; int pid; try &#123; //将上面准备的参数，按照 ZygoteConnection 的风格进行封装 parsedArgs = new ZygoteConnection.Arguments(args); ........... //通过fork\"分裂\"出system server，具体的过程在介绍system server时再分析 /* Request to fork the system server process */ pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); &#125; catch (IllegalArgumentException ex) &#123; throw new RuntimeException(ex); &#125; if (pid == 0) &#123; ............ //pid = 0, 在进程 system server中 //system server 进程处理自己的工作 handleSystemServerProcess(parsedArgs); &#125; return true;&#125; 至此，启动了 SystemServer 类中的 main 参考文章：Android6.0 SystemServer 类 http://blog.csdn.net/gaugamela/article/details/52261075 SystemServer 类framework/base/services/java/com/android/server/SystemServer.cpp12","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 实现耳机和喇叭自动切换功能","slug":"Android_Driver/Driver/[Android6.0][RK3399] 实现耳机和喇叭自动切换功能","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T02:43:18.120Z","comments":true,"path":"2017/12/31/Android_Driver/Driver/[Android6.0][RK3399] 实现耳机和喇叭自动切换功能/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_Driver/Driver/[Android6.0][RK3399] 实现耳机和喇叭自动切换功能/","excerpt":"","text":"Platform: RK3399OS: Android 6.0Kernel: Linux4.4Version: v2017.03 [TOC] 需求分析RK 默认的声卡 RT5651（Card 0）是从耳机（device 0）输出。但是我们的产品上同时具有 Speaker 和 Headphone，两者无法切换。所以需要实现默认从喇叭输出，插上耳机的情况下从耳机输出的功能。 实现方式查阅原理图HP_DET_H 为耳机状态检测脚。 SPK_CTL_H 为控制 Speaker 使能管脚。 所以整个的逻辑很简单即 HP_DET_H 检测耳机状态————&gt; 为高 耳机插入，拉底 SPK_CTL_H 禁能喇叭————&gt; 为低 耳机拔出，拉高 SPK_CTL_H 使能喇叭 进行编码dts 中添加相应 GPIO，并打开声卡驱动123456789101112131415161718192021diff --git a/arch/arm64/boot/dts/rockchip/rk3399-orangepi.dts b/arch/arm64/boot/dts/rockchip/rk3399-orangepi.dtsindex b9002f7..039c95a 100644--- a/arch/arm64/boot/dts/rockchip/rk3399-orangepi.dts+++ b/arch/arm64/boot/dts/rockchip/rk3399-orangepi.dts@@ -63,6 +63,8 @@ compatible = &quot;rockchip,rockchip-rt5651-tc358749x-sound&quot;; rockchip,cpu = &lt;&amp;i2s0 &amp;i2s0&gt;; rockchip,codec = &lt;&amp;rt5651 &amp;rt5651 &amp;tc358749x&gt;;+ spk-con-gpio = &lt;&amp;gpio0 11 GPIO_ACTIVE_HIGH&gt;;+ hp-det-gpio = &lt;&amp;gpio4 28 GPIO_ACTIVE_HIGH&gt;; status = &quot;okay&quot;; &#125;; @@ -147,7 +149,7 @@ int-gpios = &lt;&amp;gpio2 12 GPIO_ACTIVE_HIGH&gt;; pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;hdmiin_gpios&gt;;- status = &quot;disabled&quot;;+ status = &quot;okay&quot;; &#125;; &#125;; 修改 snd_soc_card 结构体添加相关成员变量123456789101112131415161718192021diff --git a/include/sound/soc.h b/include/sound/soc.hindex fb955e6..e6b3ac7 100644--- a/include/sound/soc.h+++ b/include/sound/soc.h@@ -1080,8 +1080,16 @@ struct snd_soc_card &#123; struct mutex mutex; struct mutex dapm_mutex; + int debounce_time;+ int hp_det_invert;+ struct delayed_work work;+ bool spk_active_level;+ bool hp_inserted;+ bool instantiated; + int spk_ctl_gpio;+ int hp_det_gpio; int (*probe)(struct snd_soc_card *card); int (*late_probe)(struct snd_soc_card *card); int (*remove)(struct snd_soc_card *card); 添加驱动代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131diff --git a/sound/soc/rockchip/rockchip_rt5651_tc358749x.c b/sound/soc/rockchip/rockchip_rt5651_tc358749x.cindex 21f8ee2..14acebd 100644--- a/sound/soc/rockchip/rockchip_rt5651_tc358749x.c+++ b/sound/soc/rockchip/rockchip_rt5651_tc358749x.c@@ -18,12 +18,18 @@ #include &lt;linux/module.h&gt; #include &lt;sound/soc.h&gt; +#include &lt;linux/gpio.h&gt;+#include &lt;linux/of_gpio.h&gt;+#include &lt;linux/clk.h&gt;+ #include &quot;rockchip_i2s.h&quot; #include &quot;../codecs/rt5651.h&quot; #include &quot;../codecs/tc358749x.h&quot; #define DRV_NAME &quot;rk3399-rt5651-tc358749x&quot; +#define INVALID_GPIO -1+ static const struct snd_soc_dapm_widget rockchip_dapm_widgets[] = &#123; SND_SOC_DAPM_HP(&quot;Headphones&quot;, NULL), SND_SOC_DAPM_SPK(&quot;Lineout&quot;, NULL),@@ -184,11 +190,58 @@ static struct snd_soc_card rockchip_sound_card = &#123; .num_controls = ARRAY_SIZE(rockchip_controls), &#125;; +static irqreturn_t rt5651_irq_handler(int irq, void *data)+&#123;+ struct snd_soc_card *card = data;+ queue_delayed_work(system_power_efficient_wq, &amp;card-&gt;work,+ msecs_to_jiffies(card-&gt;debounce_time));++ return IRQ_HANDLED;+&#125;++static void rt5651_enable_spk(struct snd_soc_card *card, bool enable)+&#123;+ bool level;++ level = enable ? card-&gt;spk_active_level : !card-&gt;spk_active_level;+ gpio_set_value(card-&gt;spk_ctl_gpio, level);+&#125;++static void hp_work(struct work_struct *work)+&#123;+ struct snd_soc_card *card;+ int enable;++ card = container_of(work, struct snd_soc_card, work.work);+ enable = gpio_get_value(card-&gt;hp_det_gpio);+ if(card-&gt;hp_det_invert)+ enable = !enable;++ card-&gt;hp_inserted = enable ? true : false;+ if(card-&gt;hp_inserted)&#123;+ //printk(&quot;hp_work rt5651_enable_spk false\\n&quot;);+ rt5651_enable_spk(card, false);+ &#125; else &#123;+ //printk(&quot;hp_work rt5651_enable_spk true\\n&quot;);+ rt5651_enable_spk(card,true);+ &#125;+&#125;+ static int rockchip_sound_probe(struct platform_device *pdev) &#123; struct snd_soc_card *card = &amp;rockchip_sound_card; struct device_node *cpu_node;- int i, ret;+ int i;+ int ret = -1;++ int hp_irq;+ enum of_gpio_flags flags;++ card-&gt;debounce_time = 200;+ card-&gt;hp_det_invert = 0;+ card-&gt;hp_inserted = false;+ card-&gt;spk_ctl_gpio = INVALID_GPIO;+ card-&gt;hp_det_gpio = INVALID_GPIO; dev_info(&amp;pdev-&gt;dev, &quot;%s\\n&quot;, __func__); @@ -213,6 +266,47 @@ static int rockchip_sound_probe(struct platform_device *pdev) &#125; &#125; + card-&gt;spk_ctl_gpio = of_get_named_gpio_flags(pdev-&gt;dev.of_node, &quot;spk-con-gpio&quot;, 0, &amp;flags);+ if(!gpio_is_valid(card-&gt;spk_ctl_gpio)) &#123;+ dev_err(&amp;pdev-&gt;dev,&quot;spk-ctl-gpio: %d is invalid\\n&quot;, card-&gt;spk_ctl_gpio);+ card-&gt;spk_ctl_gpio = INVALID_GPIO;+ &#125;else &#123;+ dev_info(&amp;pdev-&gt;dev,&quot;spk-ctl-gpio: %d is arrivable\\n&quot;, card-&gt;spk_ctl_gpio);+ card-&gt;spk_active_level = !(flags &amp; OF_GPIO_ACTIVE_LOW);+ ret = devm_gpio_request_one(&amp;pdev-&gt;dev, card-&gt;spk_ctl_gpio,+ GPIOF_DIR_OUT,NULL);+ if(ret) &#123;+ dev_err(&amp;pdev-&gt;dev,&quot;spk_ctl_gpio: request failed!\\n&quot;);+ &#125;+ rt5651_enable_spk(card, true);+ &#125;++ card-&gt;hp_det_gpio = of_get_named_gpio_flags(pdev-&gt;dev.of_node,&quot;hp-det-gpio&quot;, 0, &amp;flags);+ if(!gpio_is_valid(card-&gt;hp_det_gpio)) &#123;+ printk(&quot;hp-det-gpio: %d is invalid\\n&quot;,card-&gt;hp_det_gpio);+ card-&gt;hp_det_gpio = INVALID_GPIO;+ &#125;else &#123;+ INIT_DELAYED_WORK(&amp;card-&gt;work, hp_work);+ card-&gt;hp_det_invert = !!(flags &amp; OF_GPIO_ACTIVE_LOW);+ ret = devm_gpio_request_one (&amp;pdev-&gt;dev, card-&gt;hp_det_gpio,GPIOF_IN,&quot;hp det&quot;);+ if( ret &lt; 0)+ return ret;+ hp_irq = gpio_to_irq(card-&gt;hp_det_gpio);+ ret = devm_request_threaded_irq(&amp;pdev-&gt;dev, hp_irq, NULL,+ rt5651_irq_handler,+ IRQF_TRIGGER_FALLING |+ IRQF_TRIGGER_RISING |+ IRQF_ONESHOT,+ &quot;rt5651_interrupt&quot;, card);+ if( ret &lt; 0) &#123;+ dev_err(&amp;pdev-&gt;dev, &quot;request_irq: failed %d\\n&quot;, ret);+ return ret;+ &#125;++ schedule_delayed_work(&amp;card-&gt;work,+ msecs_to_jiffies(card-&gt;debounce_time));+ &#125;+ card-&gt;dev = &amp;pdev-&gt;dev; platform_set_drvdata(pdev, card); ret = devm_snd_soc_register_card(&amp;pdev-&gt;dev, card);","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 出厂预置可卸载 APK","slug":"Android_App/[Android6.0][RK3399] 出厂预置可卸载 APK","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T03:29:12.289Z","comments":true,"path":"2017/12/31/Android_App/[Android6.0][RK3399] 出厂预置可卸载 APK/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_App/[Android6.0][RK3399] 出厂预置可卸载 APK/","excerpt":"","text":"Platform: RK3399OS: Android 6.0Kernel: 4.4Version: v2017.04 [TOC] 官方文档中的方法12mkdir device/rockchip/rk3399/preinstallcp test.apk device/rockchip/rk3399/preinstall/ 重新编译即可 编译后会在 out/target/product/rk3399/system/ 下生成 preinstall 文件夹，其中包含了预置的第三方 APK。烧录后系统将自动安装应用到 data/app 目录，所以他们是可以卸载的。 不过即使卸载后，恢复出厂设置后，这些 APP 还是会存在的。希望卸载后，恢复出厂设置时，这些 APP 不存在的话，将上述文件夹名字改为 preinstall_del 即可。 出现问题我的 out/target/product/rk3399/system/ 并没有生成 preinstall 文件夹 解决思路应该会有某个 mk 对 preinstall 进行操作。123456789101112131415$ grep preinstall ./device/rockchip/ -nir./common/device.mk:21: $(shell python device/rockchip/common/auto_generator.py $(TARGET_DEVICE_DIR) preinstall)./common/device.mk:22: $(shell python device/rockchip/common/auto_generator.py $(TARGET_DEVICE_DIR) preinstall_del)./common/device.mk:23: -include $(TARGET_DEVICE_DIR)/preinstall/preinstall.mk./common/device.mk:24: -include $(TARGET_DEVICE_DIR)/preinstall_del/preinstall.mk./common/device.mk:422:# for preinstall./common/device.mk:424: $(LOCAL_PATH)/preinstall_cleanup.sh:system/bin/preinstall_cleanup.sh./common/preinstall_cleanup.sh:2:log -t PackageManager &quot;Start to clean up /system/preinstall_del/&quot;./common/preinstall_cleanup.sh:4:rm system/preinstall_del/*.*./common/auto_generator.py:19: preinstall_dir = os.path.dirname(argv[0])./common/auto_generator.py:20: preinstall_dir = os.path.join(preinstall_dir, &apos;../../../&apos; + argv[1] + &apos;/&apos; + argv[2])./common/auto_generator.py:21: if os.path.exists(preinstall_dir):./common/auto_generator.py:23: makefile_path = preinstall_dir + &apos;/Android.mk&apos;./common/auto_generator.py:25: include_path = preinstall_dir + &apos;/preinstall.mk&apos;./common/auto_generator.py:36: for root, dirs, files in os.walk(preinstall_dir): 看起来 device.mk 中有点相关1vi common/device.mk +21 12345678917 # Prebuild apps18 ifneq ($(strip $(TARGET_PRODUCT)), )19 TARGET_DEVICE_DIR=$(shell test -d device &amp;&amp; find device -maxdepth 4 -path '*/$(TARGET_PRODUCT)/Boa rdConfig.mk')20 TARGET_DEVICE_DIR := $(patsubst %/,%,$(dir $(TARGET_DEVICE_DIR)))21 $(shell python device/rockchip/common/auto_generator.py $(TARGET_DEVICE_DIR) preinstall)22 $(shell python device/rockchip/common/auto_generator.py $(TARGET_DEVICE_DIR) preinstall_del)23 -include $(TARGET_DEVICE_DIR)/preinstall/preinstall.mk24 -include $(TARGET_DEVICE_DIR)/preinstall_del/preinstall.mk25 endif 哦，原来他是会去找 TARGET_DEVICE_DIR 目录下的 preinstall 啊所以对于我的 TARGET_DEVICE_DIR 路径应该是 device/rockchip/rk3399/rk3399_64/preinstall重新按官方方法添加 APK 后验证成功。 另外在上面 mk 中也可以看到 在找到了 preinstall 或者 preinstall_del 后会调用 device/rockchip/common/auto_generator.py 这个脚本来生成一些 mk 文件（Android.mk 和 preinstall.mk） 实际上最终处理 preinstall 文件夹下 Apk 的逻辑是在生成的 preinstall.mk 中的重新编译后我们可以看到1vi device/rockchip/rk3399/rk3399_64/preinstall/preinstall.mk preinstall.mk 中有1PRODUCT_PACKAGES += MyAPK","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 修改默认按键 KEY-PAD","slug":"Android_Driver/Driver/[Android6.0][RK3399] 修改默认按键 KEY-PAD","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T02:41:24.053Z","comments":true,"path":"2017/12/31/Android_Driver/Driver/[Android6.0][RK3399] 修改默认按键 KEY-PAD/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_Driver/Driver/[Android6.0][RK3399] 修改默认按键 KEY-PAD/","excerpt":"","text":"Platform: RK3399OS: Android 6.0Kernel: 4.4Version: v2017.04 需求需求是将 Menu 键修改为 Home 键。 Key-Pad 原理按键部分原理图如下 可以看到不同按键串联的电阻值也不同。所以按下不同按键时 ADKEY_IN 的检测电压也会不同（不同阻值分压不同），平台端设计好接收不同电压时对应的功能，就实现了功能按键。 实现getevent 看是否获得按键上报12adb shellgetevent 可以看到我们的 key pad 设备 按下我们需要修改的按键（现在的 MENU 键） 获得键值 0x003b，即 10 进制的 59 在 SDK/device/rockchip/common/rk29-keypad.kl 修改123456789101112vi SDK/device/rockchip/common/rk29-keypad.kl-key 59 MENU+key 59 HOME-key 102 HOME+key 102 MENUkey 114 VOLUME_DOWNkey 115 VOLUME_UPkey 116 POWER WAKEkey 143 NOTIFICATION WAKEkey 158 BACKkey 212 CAMERAkey 217 SEARCH 我们把 key 59 的功能改为 MENU 验证按键生效。 后话另外 adb pull /system/usr/keylayout/rk29-keypad.kl修改后直接 push 进去也可以完成任务。","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 Wifi Card 驱动流程分析","slug":"Android_Driver/Driver/[Android6.0][RK3399] Wifi Card 驱动流程分析","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T02:41:07.489Z","comments":true,"path":"2017/12/31/Android_Driver/Driver/[Android6.0][RK3399] Wifi Card 驱动流程分析/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_Driver/Driver/[Android6.0][RK3399] Wifi Card 驱动流程分析/","excerpt":"","text":"Platform: RockChipOS: Android 6.0Kernel: 4.4WiFi/BT/FM 模组: AP6354 前面的基本概念搜罗于网络;后面的驱动流程分析是根据 RockChip 3399 的 Kernel 部分来进行分析的。 [TOC] 基本概念Wifiwifi 英文全称是 WIreless-FIdelity，翻译成中文就是无线保真，英文简称WiFi。 WLANwlan 英文全名：Wireless Local Area Networks， 无线局域网络。 关系wifi 是实现 wlan 的一种技术。 STA 模式 和 AP 模式AP模式: Access Point，提供无线接入服务，允许其它无线设备接入，提供数据访问，一般的无线路由/网桥工作在该模式下。AP和AP之间允许相互连接。Sta模式: Station, 类似于无线终端，sta本身并不接受无线的接入，它可以连接到AP，一般无线网卡即工作在该模式。 无线接入过程的三个阶段 STA（工作站）启动初始化、开始正式使用AP传送数据帧前，要经过三个阶段才能够接入（802.11MAC层负责客户端与AP之间的通讯，功能包括扫描、接入、认证、加密、漫游和同步等功能）：1）扫描阶段（SCAN）2）认证阶段 (Authentication)3）关联（Association） 更详细的 wifi 相关介绍可以参考这篇文章 WiFi基础知识解析 后面介绍 Wifi 的接口 SDIO 的基本概念。 SD 和 MMCSD (Secure Digital) 与 MMC (Multimedia Card)MMC 是较早的一种记忆卡标准，目前已经被 SD 标准取代。SD 是一种 flash memory card 的标准,也就是一般常见的 SD 记忆卡。 SDIO（Secure Digital I/O）SDIO 就是 SD 的 I/O 接口的意思。更具体的说，SD 本来是记忆卡的标准,但是现在也可以把 SD 拿来插上一些外围接口使用,这样的技术便是 SDIO。 SDIO 通过 SD 的 I/O 管脚来连接外部的外围 device 并传输数据。这些外围设备，我们称为 SDIO 卡，常见的有： Wi-Fi card(无线网络卡) CMOS sensor card(照相模块) GPS card GSM/GPRS modem card Bluetooth card Radio/TV card SDIO 卡 和 SD 卡 的区别SD卡使用的是SD卡协议，而SDIO卡使用的是SDIO协议！协议不一样，初始化/读写方式也不一样！ SDIO-Wifi 模块SDIO-Wifi 模块是基于 SDIO 接口的符合 wifi 无线网络标准的嵌入式模块，内置无线网络协议IEEE802.11协议栈以及TCP/IP协议栈，能够实现用户主平台数据通过SDIO口到无线网络之间的转换。SDIO 具有传输数据快，兼容SD、MMC接口等特点。 对于SDIO接口的wifi，首先，它是一个sdio的卡的设备，然后具备了wifi的功能。所以，注册的时候还是先以sdio的卡的设备去注册的。然后检测到卡之后就要驱动他的wifi功能。 SDIO 总线SDIO总线 和 USB总线 类似，SDIO也有两端，其中一端是HOST端，另一端是device端。所有的通信都是由HOST端 发送 命令 开始的，Device端只要能解析命令，就可以相互通信。CLK信号：HOST给DEVICE的 时钟信号，每个时钟周期传输一个命令。CMD信号：双向 的信号，用于传送 命令 和 反应。DAT0-DAT3 信号：四条用于传送的数据线。VDD信号：电源信号。VSS1，VSS2：电源地信号。 SDIO 命令SDIO总线上都是HOST端发起请求，然后DEVICE端回应请求。SDIO 命令由6个字节组成。 a – Command:用于开始传输的命令，是由HOST端发往DEVICE端的。其中命令是通过CMD信号线传送的。b – Response:回应是DEVICE返回的HOST的命令，作为Command的回应。也是通过CMD线传送的。c – Data:数据是双向的传送的。可以设置为1线模式，也可以设置为4线模式。数据是通过DAT0-DAT3信号线传输的。 SDIO的每次操作都是由HOST在CMD线上发起一个CMD，对于有的CMD，DEVICE需要返回Response，有的则不需要。对于读命令，首先HOST会向DEVICE发送命令，紧接着DEVICE会返回一个握手信号，此时，当HOST收到回应的握手信号后，会将数据放在4位的数据线上，在传送数据的同时会跟随着CRC校验码。当整个读传送完毕后，HOST会再次发送一个命令，通知DEVICE操作完毕，DEVICE同时会返回一个响应。对于写命令，首先HOST会向DEVICE发送命令，紧接着DEVICE会返回一个握手信号，此时，当HOST收到回应的握手信号后，会将数据放在4位的数据线上，在传送数据的同时会跟随着CRC校验码。当整个写传送完毕后，HOST会再次发送一个命令，通知DEVICE操作完毕，DEVICE同时会返回一个响应。 WIFI 模块解析和启动流程对于 Wifi 模组的 Android 上层的分析，这篇文章讲的非常不错：http://blog.csdn.net/ylyuanlu/article/details/7711433这篇文章将下图蓝色的和绿色的部分讲的非常详细。 我这个板子上所采用的 WiFi 模组是 AP6354, 它是一个 Wifi / BT4.0 / FM 三合一模组。接口是 SDIO。本文主要分析 Kernel Driver 部分。所以先从 SDIO 接口的驱动来切入。 SDIO 接口驱动SDIO 接口的 wifi，首先，它是一个 sdio 卡 设备，然后具备了 wifi 的功能，所以 SDIO 接口的 WiFi 驱动就是在 wifi 驱动 外面套上了一个 SDIO 驱动 的外壳。 SDIO 驱动部分代码结构如下 drivers/mmc 下有 mmc卡、sd卡、sdio 卡驱动。 SDIO驱动仍然符合设备驱动的分层与分离思想。 设备驱动层（wifi 设备）: |核心层（向上向下提供接口） |主机驱动层（实现 SDIO 驱动） 我们主要关心 core 目录（CORE 层），其中是媒体卡的通用代码。包括 core.c host.c stdio.c。CORE 层完成了 不同协议和规范的实现 为 HOST 层的驱动提供了接口函数 完成了 SDIO 总线注册 对应 ops 操作 以及支持 mmc 的代码 host 目录（HOST 层）是根据不通平台而编写的 host 驱动。 WIFI 驱动流程分析rockchip_wifi_init_module_rkwifi //创建了一个内核线程 wifi_init_thread wifi_init_thread //-&gt; dhd_module_init dhd_wifi_platform_register_drv // 查找设备，注册 wifi 驱动，注册成功调用后面的 bcmdhd_wifi_plat_dev_drv_probe wifi_ctrlfunc_register_drv | bus_find_device //查找 wifi 设备 | platform_driver_register(&amp;wifi_platform_dev_driver) //注册 wifi 驱动 bcmdhd_wifi_plat_dev_drv_probe //-&gt; dhd_wifi_platform_load //两个操作 wl_android_init //1. wlan 初始化 dhd_wifi_platform_load_sdio //2. 根据 接口类型 usb、sdio、pcie 选择不同的操作 dhd_bus_register // 注册成功就调用 dhd_sdio.dhdsdio_probe bcmsdh_register(&amp;dhd_sdio) | bcmsdh_register_client_driver | sdio_register_driver(&amp;bcmsdh_sdmmc_driver) //注册成功就调用 bcmsdh_sdmmc_driver.bcmsdh_sdmmc_probe | bcmsdh_sdmmc_probe //-&gt; | sdioh_probe dhdsdio_probe 参考文章在全志平台调试博通的wifi驱动（类似ap6212）wifi 详解(三) 调试问题调试步骤1.确保配置无误 dts文件的配置wifi部分是在net/rfkill-wlan.c中进行配置；先通过内核启动日志确认相关配置是否有正常解析，如果解析过程出现异常，确认是所配置的gpio是否存在冲突； 2.检查供电是否正常确认wifi的供电控制是否受控 Echo 0 &gt; /sys/class/rkwifi/power //对wifi模块掉电 Echo 1 &gt; /sys/class/rkwifi/power//对wifi模块上电如果执行上面命令对模块进行上下电，而 实际测量对应管脚不受控，可以通过io 命令读取对应的寄存器，确认是否写入，如果正确写入但是实际测量不受控请检查硬件部分； 3. 扫描模块初始化模块检查内核中是否配置CONFIG_WIFI_LOAD_DRIVER_WHEN_KERNEL_BOOTUP=y；调测wifi时请把该宏配置为 n；执行 echo 1 &gt; /sys/class/rkwifi/driver 命令会调用模块的驱动的初始化操作，初始化成功后看到wlan0 节点； 如何判断是否识别到模块 Usb接口的模块：出现如下 log SDIO 接口的模块对于sdio接口的模块，执行” echo 1 &gt; /sys/class/rkwifi/driver”命令 ，正常情况下 sdio_clk 和sdio_cmd 能够测量到相关波形，内核打印上能够看到如下打印，如果没有测量到波形也没有看到如下打印，根据配置文档检查是否正确配置sdio; Wifi驱动会根据扫描到的sdio模块的vid pid 进行驱动匹配，rtl的驱动会根据读取到的vid，pid进行驱动匹配；其中正基系列的模块会根据后面从data数据线上读取到F1 function 读取的数值进行 驱动与固件匹配（正基目前的驱动兼容所有sdio接口正基模块，根据F1 function 读取的值 匹配固件）；如果能够扫描模块但是初始化过程看到data fifo error,检查下 sdio接口电平是否一致；方法如下： echo 1 &gt; /sys/class/rkwifi/power测量 VDDIO sdio_clk sdio_cmd sdio_data0~sdio_data3 的电压；正常情况下 sdio_clk 为 0V，sdio其他五根线与vddio电压一致；如果电压不一致：312x平台确认下 sdio接口的内部上下拉是否禁掉，参看文档RK Kernel 3.10平台WiFi BT不工作异常排查.pdf Part C；其他平台考虑加外部上拉(注clk绝对不要加外部上拉)；同时测量执行echo 1 &gt; /sys/class/rkwifi/driver 时 外部晶体是否有起振，如果扫描时没有起振检查下硬件；同时建议测量外部晶体频偏，频偏比较大情况下，会出现能扫描到模块但是初始化失败；除检查晶振外，正基系列还需要外部32k，测量32k的峰峰值（峰峰值&gt;=0.7VDDIO &amp;&amp; 峰峰值 &lt;= 1VDDIO）；【注：频偏和峰峰值一定要测量检查，频偏过大峰峰值不对会影响wifi（扫描连接热点）和蓝牙（扫描连接设备））】电压一致情况下，晶振频偏和32k的峰峰值没有问题（正基系列的要考虑晶振频偏与32k峰峰值，具体结合自己电路实际情况）但是初始化依然出问题；考虑降低sdio_clk ，重新测试；如果降低clk可以，考虑硬件上走线；如果降低clk依然不行，考虑使用sdio单线模式方法如下12345&amp;sdio &#123; ... bus-width = &lt;1&gt;; ...&#125;; 使用 sdio 单线模式。如果单线模式可以而使用4线模式不行，检查硬件上sdio_data0~sdio_data3 四根线的线序是否弄错；如果降低clk，使用单线模式均不可以检查下是否是使用最新的sdk代码和最新的wifi驱动（ftp服务器上有相关patch）； 上述检查均无结果，check 图纸 是否周围器件有贴错器件； 4.检查模块能否处于工作状态 netcfg wlan0 up 或busybox ifconfig wlan0 up //执行完成后检查 wlan0 是否处于up状态；如果没有处于up状态;做如下检查确认 1 确认相关固件是否存在(正基系列，通过看内核日志可以看到)，固件不存在考虑到ftp下载固件；此时如果还报其他错误从两个方面排查1 上电时序，2检查sdio部分走线； 2 尝试使用原始最新的sdk代码做测试；（有客户出现过，上层做了相关修改导致wifi初始化成功，但是执行netcfg wlan0 up 报告无法识别 ioctl 命令等奇怪错误，原生sdk生成的sysytem.img 没有问题） 执行iwlist wlan0 scanning ，测试扫描热点是否正常（3368平台下执行iwlist 命令有问题，忽略此步骤） 5. 确认Android层是否能够打开述检查各个步骤可以工作，而通过上层settings界面打开失败；以下几个方面排查 1 dts中的wifi_type配置是否正确;cat /sys/class/rkwifi/chip 确认 下 打印的结果和你的模块是否匹配 2 确认 wpa_supplicant 相关服务是否生成，libhardware_leacy 启动的wpa服务是否正确； 3 抓取logcat 日志上传readmine 吞吐率问题 pcb检查，一定要让模块原厂检查确认 pcb是否存在问题 RF指标确认是否ok 天线是否做过匹配 Sdio 接口的可以考虑 提到sdio的clk 启用sdio3.0【前提 平台支持 sdio3.0 ,模块支持sdio3.0】其他问题无法连接热点1.无法连接热点，正基系列模块检查确认晶振频偏和32k峰峰值；rtl模块考虑驱动配置是否正确，是否匹配；2.检查确认p2p wlan0 的mac地址是否一致如果检查是否有调用rockchip_wifi_mac_addr读取mac地址，如果有考虑直接在该函数中return -1；3.检查确认是否有做RF指标测试以及天线匹配测试4.上述检查没有问题，做如下测试 （首先用给手机连接所测试的热点做确认）1 连接无加密热点 2 连接加密热点 测试能否连接成功，并记录对应的logcat 日志与内核日志（开机到打开wifi以及连接热点的整个过程）softap 无法打开（正基系列的）1.查看打开热点时的内核日志，确认下 下载固件是否正确 ，正基系列的模块 softap 下载的固件一般是带ap后缀结尾的；2.固件下载没有问题 ，考虑使用原始的sdk代码做测试P2P 问题P2p 无法打开：确认是否有p2p节点，有p2p节点的检查确认mac地址是否与wlan0 一样，如果一样按照热点问题中的step 2 处理；第一次开机能够打开，重启后无法打开：考虑检查上电时序，目前遇到都是rtl的模块出现过，问题在于chipen 脚不受控，建议做成受控，在重启时对chipen脚下电；可以通过如下方法实现net/rfkill-wlan.c中的rfkill_wlan_driver 中增加shutdown函数 在该函数中对chip_en 下电；休眠唤醒出现wifi无法打开：1 对比检查休眠唤醒前后 sdio 的iomux 是否发生变更2 对比 休眠前后以及休眠中 wifi的外围供电是否发生变更 sdio_pwrseq123456789101112131415sdio_pwrseq: sdio-pwrseq &#123; compatible = \"mmc-pwrseq-simple\"; clocks = &lt;&amp;rk808 1&gt;; clock-names = \"ext_clock\"; pinctrl-names = \"default\"; pinctrl-0 = &lt;&amp;wifi_enable_h&gt;; /* * On the module itself this is one of these (depending * on the actual card populated): * - SDIO_RESET_L_WL_REG_ON * - PDN (power down when low) */ reset-gpios = &lt;&amp;gpio0 10 GPIO_ACTIVE_LOW&gt;; /* GPIO0_B2 */ &#125;; 根据 compatible 匹配到 mmc_pwrseq_simple_alloc1234567891011121314struct mmc_pwrseq_match &#123; const char *compatible; struct mmc_pwrseq *(*alloc)(struct mmc_host *host, struct device *dev);&#125;;static struct mmc_pwrseq_match pwrseq_match[] = &#123; &#123; .compatible = &quot;mmc-pwrseq-simple&quot;, .alloc = mmc_pwrseq_simple_alloc, &#125;, &#123; .compatible = &quot;mmc-pwrseq-emmc&quot;, .alloc = mmc_pwrseq_emmc_alloc, &#125;,&#125;; 逻辑在 drivers/mmc/core/pwrseq.c 的 mmc_pwrseq_alloc 中1int mmc_pwrseq_alloc(struct mmc_host *host) 在其中调用 match-&gt;alloc(host, &amp;pdev-&gt;dev) 即 mmc_pwrseq_simple_alloc注册 mmc_pwrseq_simple_ops 并返回 pwrseq123456static struct mmc_pwrseq_ops mmc_pwrseq_simple_ops = &#123; .pre_power_on = mmc_pwrseq_simple_pre_power_on, .post_power_on = mmc_pwrseq_simple_post_power_on, .power_off = mmc_pwrseq_simple_power_off, .free = mmc_pwrseq_simple_free,&#125;; wireless-wlankernel/net/rfkill/rfkill-wlan.c123456789101112131415161718static int rfkill_wlan_probe(struct platform_device *pdev)&#123; //解析 dts ret = wlan_platdata_parse_dt(&amp;pdev-&gt;dev, pdata); //rfkill 注册 GPIO poweren 和 reset ret = rfkill_rk_setup_gpio(&amp;pdata-&gt;power_n, wlan_name, &quot;wlan_poweren&quot;); ret = rfkill_rk_setup_gpio(&amp;pdata-&gt;reset_n, wlan_name, &quot;wlan_reset&quot;); //默认关掉 wifi if (gpio_is_valid(pdata-&gt;power_n.io)) &#123; gpio_direction_output(pdata-&gt;power_n.io, !pdata-&gt;power_n.enable); &#125; //最后调用 rockchip_wifi_power(1) ，这也是最重要的地方，我们在后面单独分析 if (pdata-&gt;wifi_power_remain) &#123; rockchip_wifi_power(1); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//1——&gt;on //0——&gt;offint rockchip_wifi_power(int on)&#123; struct rfkill_wlan_data *mrfkill = g_rfkill; // mrfkill 是一个开关 struct rksdmmc_gpio *poweron, *reset; // 两个 gpio（poweron 和 reset） struct regulator *ldo = NULL; int power = 0; bool toggle = false; //不管怎么样先 power off if (!on &amp;&amp; primary_sdio_host) mmc_pwrseq_power_off(primary_sdio_host); if (!rfkill_get_bt_power_state(&amp;power, &amp;toggle)) &#123; if (toggle == true &amp;&amp; power == 1) &#123; LOG(&quot;%s: wifi shouldn&apos;t control the power, it was enabled by BT!\\n&quot;, __func__); return 0; &#125; &#125; if (mrfkill-&gt;pdata-&gt;mregulator.power_ctrl_by_pmu) &#123; int ret = -1; char *ldostr; int level = mrfkill-&gt;pdata-&gt;mregulator.enable; ldostr = mrfkill-&gt;pdata-&gt;mregulator.pmu_regulator; if (ldostr == NULL) &#123; LOG(&quot;%s: wifi power set to be controled by pmic, but which one?\\n&quot;, __func__); return -1; &#125; ldo = regulator_get(NULL, ldostr); if (ldo == NULL || IS_ERR(ldo)) &#123; LOG(&quot;\\n\\n\\n%s get ldo error,please mod this\\n\\n\\n&quot;, __func__); return -1; &#125; else &#123; if (on == level) &#123; regulator_set_voltage(ldo, 3000000, 3000000); LOG(&quot;%s: %s enabled\\n&quot;, __func__, ldostr); ret = regulator_enable(ldo); wifi_power_state = 1; LOG(&quot;wifi turn on power.\\n&quot;); &#125; else &#123; LOG(&quot;%s: %s disabled\\n&quot;, __func__, ldostr); while (regulator_is_enabled(ldo) &gt; 0) &#123; ret = regulator_disable(ldo); &#125; wifi_power_state = 0; LOG(&quot;wifi shut off power.\\n&quot;); &#125; regulator_put(ldo); msleep(100); &#125; &#125; else &#123; poweron = &amp;mrfkill-&gt;pdata-&gt;power_n; reset = &amp;mrfkill-&gt;pdata-&gt;reset_n; if (on)&#123; if (gpio_is_valid(poweron-&gt;io)) &#123; gpio_set_value(poweron-&gt;io, poweron-&gt;enable); msleep(100); &#125; if (gpio_is_valid(reset-&gt;io)) &#123; gpio_set_value(reset-&gt;io, reset-&gt;enable); msleep(100); &#125; wifi_power_state = 1; LOG(&quot;wifi turn on power. %d\\n&quot;, poweron-&gt;io); &#125;else&#123; if (gpio_is_valid(poweron-&gt;io)) &#123; gpio_set_value(poweron-&gt;io, !(poweron-&gt;enable)); msleep(100); &#125; if (gpio_is_valid(reset-&gt;io)) &#123; gpio_set_value(reset-&gt;io, !(reset-&gt;enable)); &#125; wifi_power_state = 0; LOG(&quot;wifi shut off power.\\n&quot;); &#125; &#125; return 0;&#125;&#125; 老规矩，在 linux 下 make menuconfig，我们用的是 AP6354，搜 ap6xxx， 发现有[IMG] cd ~/3399/kernel/drivers/net/wireless/rockchip_wlan/rkwifi/Makefile 中可以看到[IMG] ~/3399/kernel/drivers/net/wireless/rockchip_wlan/rkwifi/rk_wifi_config.c中用来设置固件的路径在1int rkwifi_set_firmware(char *fw, cahr *nvram) 中，通过1extern int get_wifi_chip_type(void); 获取 chip 类型是 WIFI_AP6354设置 fw = “/system/etc/firmware/fw_bcm4354a1_ag.bin”设置 nvram = “/system/etc/firmware/nvram_ap6354.txt”","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 Uboot 编译规则","slug":"Android_Driver/Driver/[Android6.0][RK3399] Uboot 编译规则","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T02:40:50.565Z","comments":true,"path":"2017/12/31/Android_Driver/Driver/[Android6.0][RK3399] Uboot 编译规则/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_Driver/Driver/[Android6.0][RK3399] Uboot 编译规则/","excerpt":"","text":"Author: YounixPlatform: RK3399OS: Android 6.0Kernel: 4.4Version: v2017.07 [TOC] RK 的文档中有说到 其 Uboot 是给予 2014.10 官方版本进行开发的，同步更新了主分支的一些关键性更新。 一、Uboot 的编译编译 Uboot 我们所采用的命令如下：12make rk3399_defconfigmake ARCHV=aarch64 我们从编译命令入手，分析 Uboot。 Uboot 配置文件 ×_defconfigrk3399_defconfig 为 uboot 的配置文件，uboot 的配置文件都在 configs 中12➜ u-boot git:(fcfc325) ls configs/rk3399*configs/rk3399_box_defconfig configs/rk3399_defconfig configs/rk3399-fpga_defconfig 可以看到一共有三种形态，BOX、MID、FPGA。首先以 rk3399_defconfig 为例：12345678CONFIG_SYS_EXTRA_OPTIONS=&quot;RKCHIP_RK3399,PRODUCT_MID,NORMAL_WORLD,SECOND_LEVEL_BOOTLOADER,BAUDRATE=1500000&quot;# RKCHIP_RK3399 定义芯片类型# PRODUCT_MID 定义产品形态# NORMAL_WORLD 定义 Uboot 运行在 Normal World# SECOND_LEVEL_BOOTLOADER 定义 Uboot 为二级 loader 模式（采用 Nand Flash 的项目以安全框架驱动时，需要定义该选项。CONFIG_ARM=yCONFIG_ROCKCHIP_ARCH64=yCONFIG_PLAT_RK33XX=y 该选项内的配置会被优先编译成宏定义并在相关的项前面自动添加 CONFIG_,可以在U-BOOT 自动生成的配置文件 (include/config.h) 中看到生成的宏定义,会优先系统的配置文件,可以支配系统的配置文件。 什么意思呢，比如说 PRODUCT_MID ，他会被加上 CONFIG_ 成为 CONFIG_PRODUCT_MID 被定义。然后通过这个宏来控制一些功能的开关。正好，我们也可以对比看看 BOX 形态的产品的 configs：我们对比 BOX 和 MID 的 configs 可以发现12345➜ configs git:(fcfc325) diff rk3399_box_defconfig rk3399_defconfig 1c1&lt; CONFIG_SYS_EXTRA_OPTIONS=&quot;RKCHIP_RK3399,PRODUCT_BOX,NORMAL_WORLD,SECOND_LEVEL_BOOTLOADER,BAUDRATE=1500000&quot;---&gt; CONFIG_SYS_EXTRA_OPTIONS=&quot;RKCHIP_RK3399,PRODUCT_MID,NORMAL_WORLD,SECOND_LEVEL_BOOTLOADER,BAUDRATE=1500000&quot; 即在 CONFIG_SYS_EXTRA_OPTIONS 参数中的 PRODUCT_* 有差别全局搜索 PRODUCT_BOX 根据 PRODUCT_BOX、PRODUCT_MID 的差别会影响部分功能的开关。比如 ./include/configs/rk33plat.h:375 中12345/* if box product, undefine fg and battery */#ifndef CONFIG_PRODUCT_BOX#define CONFIG_POWER_FG#define CONFIG_POWER_BAT#endif /* CONFIG_PRODUCT_BOX */ 比如 ./include/configs/rk_default_config.h: 中，BOX 形态不需要电源管理系统，需要 HDMI 和 TVE123456789101112131415161718192021#ifndef CONFIG_PRODUCT_BOX/* rk pm management module */#define CONFIG_PM_SUBSYSTEM#endif#ifdef CONFIG_PRODUCT_BOX/* rk deviceinfo partition */#define CONFIG_RK_DEVICEINFO/* rk pwm remote ctrl */#define CONFIG_RK_PWM_REMOTE#endif#ifndef CONFIG_PRODUCT_BOX#define CONFIG_RK_PWM_BL#endif#ifdef CONFIG_PRODUCT_BOX#define CONFIG_RK_HDMI#define CONFIG_RK_TVE#endif Uboot 配置文件 rk33plat.h其中有关键性的系统配置12345678910111255 * define uboot loader addr.56 * notice: CONFIG_SYS_TEXT_BASE must be an immediate,57 * so if CONFIG_RAM_PHY_START is changed, also update CONFIG_SYS_TEXT_BASE define.58 *59 * Resersed 2M space(0 - 2M) for Runtime ARM Firmware bin, such as bl30/bl31/bl32 and so on.60 *61 */62 #ifdef CONFIG_SECOND_LEVEL_BOOTLOADER63 #define CONFIG_SYS_TEXT_BASE 0x00200000 /* Resersed 2M space Runtime Firmware bin. */64 #else65 #define CONFIG_SYS_TEXT_BASE 0x0000000066 #endif 交叉编译工具链ARCHV=aarch64 指明了 rk3399 的平台架构，在 Makefile 中会根据其指定编译工具链。交叉编译工具链的指定是由 CROSS_COMPILE 宏确定，可以在 make 的时候声明。12345678910111213141516171819202122232425262728293031ifeq ($(ARCHV),aarch64)ifneq ($(wildcard ../toolchain/aarch64-linux-android-4.9),)CROSS_COMPILE ?= $(shell pwd)/../toolchain/aarch64-linux-android-4.9/bin/aarch64-linux-android-endififneq ($(wildcard ../prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/bin),)CROSS_COMPILE ?= $(shell pwd)/../prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/bin/aarch64-linux-android-endifelseifneq ($(wildcard ../toolchain/arm-eabi-4.8),)CROSS_COMPILE ?= $(shell pwd)/../toolchain/arm-eabi-4.8/bin/arm-eabi-endififneq ($(wildcard ../toolchain/arm-eabi-4.7),)CROSS_COMPILE ?= $(shell pwd)/../toolchain/arm-eabi-4.7/bin/arm-eabi-endififneq ($(wildcard ../toolchain/arm-eabi-4.6),)CROSS_COMPILE ?= $(shell pwd)/../toolchain/arm-eabi-4.6/bin/arm-eabi-endififneq ($(wildcard ../prebuilts/gcc/linux-x86/arm/arm-eabi-4.8/bin),)CROSS_COMPILE ?= $(shell pwd)/../prebuilts/gcc/linux-x86/arm/arm-eabi-4.8/bin/arm-eabi-endififneq ($(wildcard ../prebuilts/gcc/linux-x86/arm/arm-eabi-4.7/bin),)CROSS_COMPILE ?= $(shell pwd)/../prebuilts/gcc/linux-x86/arm/arm-eabi-4.7/bin/arm-eabi-endififneq ($(wildcard ../prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin),)CROSS_COMPILE ?= $(shell pwd)/../prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-endifendif # ARCHV=aarch64 因为 RK3399 ARCHV==aarch64, 所以编译工具链为 4.9 版本123456ifneq ($(wildcard ../toolchain/aarch64-linux-android-4.9),)CROSS_COMPILE ?= $(shell pwd)/../toolchain/aarch64-linux-android-4.9/bin/aarch64-linux-android-endififneq ($(wildcard ../prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/bin),)CROSS_COMPILE ?= $(shell pwd)/../prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/bin/aarch64-linux-android-endif 二、Uboot 目录结构1234567891011121314151617include/configs/rk_default_config.h: rk平台公共配置，默认打开所有需要的功能include/configs/rk33plat.h: rk33xx系列平台配置，根据不同的芯片进行细节配置，比如内存地址、简配一些功能模块的配置arch/arm/include/asm/arch-rk33xx/: rk33xx系列平台架构头文件arch/arm/cpu/armv8/rk33xx/: rk33xx系列平台架构文件, 包括clock, irq, timer等实现。board/rockchip/rk33xx: 板级平台核心文件，主要是rk33xx.c，里面有熟悉的kernel要用的machine type.drivers: 各种接口驱动文件，如lcd, rtc, spi, i2c,usb等驱动。 三、RK 平台 Uboot 生成方式RK Uboot 有两种生成方式。参看 RK wiki。一种是 Uboot 作 first level bootloader，比如原来的 RK3288 平台，这种情况下，uboot 生成的固件为单独的 .bin 文件， RK3288UbootLoader_V2.30.10.bin 。另一种是 Uboot 作为 second level bootloader，比如 RK3399 平台，这种情况下，uboot 生成的固件为 .img，比如 uboot.img。 在 Uboot 的代码中，configs/rk3399_defconfig 中有定义1CONFIG_SYS_EXTRA_OPTIONS=&quot;RKCHIP_RK3399,PRODUCT_MID,NORMAL_WORLD,SECOND_LEVEL_BOOTLOADER,BAUDRATE=1500000&quot; 我们可以通过设置 CMDLINE 中的 CONFIG_SECOND_LEVEL_BOOTLOADER 宏来控制是否将其作为 second level bootloader。CONFIG_SECOND_LEVEL_BOOTLOADER 会打开 CONFIG_MERGER_MINILOADER 宏。它控制的功能是合并 MINIALL.ini 配置文件（tools/rk_tools/RKBOOT/RK3399MINIALL.ini ）与 miniloader.bin（tools/rk_tools/bin/rk33/rk3399_miniloader_v1.06.bin ），最终输出为 rk3399_loader_v1.08.106.bin。代码逻辑如下：123456789ifdef CONFIG_SECOND_LEVEL_BOOTLOADER $(if $(CONFIG_MERGER_MINILOADER), ./tools/boot_merger ./tools/rk_tools/RKBOOT/$(RKCHIP)MINIALL.ini &amp;&amp;) \\ $(if $(CONFIG_MERGER_TRUSTIMAGE), ./tools/trust_merger $(if $(CONFIG_RK_TRUSTOS), --subfix) \\ ./tools/rk_tools/RKTRUST/$(RKCHIP)TRUST.ini &amp;&amp;) \\ $(if $(CONFIG_MERGER_TRUSTOS), ./tools/loaderimage --pack --trustos $(RK_TOS_BIN) trust.img &amp;&amp;) \\ ./tools/loaderimage --pack --uboot u-boot.bin uboot.imgelse ./tools/boot_merger --subfix &quot;$(RK_SUBFIX)&quot; ./tools/rk_tools/RKBOOT/$(RKCHIP).iniendif # CONFIG_SECOND_LEVEL_BOOTLOADER","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 去掉鼠标移动唤醒功能","slug":"Android_App/[Android6.0][RK3399]去掉鼠标移动唤醒功能","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T03:31:03.197Z","comments":true,"path":"2017/12/31/Android_App/[Android6.0][RK3399]去掉鼠标移动唤醒功能/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_App/[Android6.0][RK3399]去掉鼠标移动唤醒功能/","excerpt":"","text":"[TOC] 需求去掉移动时唤醒系统功能 解决方法1234567891011a/frameworks/native/services/inputflinger/InputReader.cpp b/frameworks/native/services/inputflinger/InputReader.cppindex 10d35eb..730b733 100644--- a/frameworks/native/services/inputflinger/InputReader.cpp+++ b/frameworks/native/services/inputflinger/InputReader.cpp@@ -2579,7 +2579,7 @@ void CursorInputMapper::sync(nsecs_t when) &#123; // TODO: Use the input device configuration to control this behavior more finely. uint32_t policyFlags = 0; if ((buttonsPressed || moved || scrolled) &amp;&amp; getDevice()-&gt;isExternal()) &#123;- policyFlags |= POLICY_FLAG_WAKE;+ //policyFlags |= POLICY_FLAG_WAKE; &#125;","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 Uboot 代码分析","slug":"Android_Driver/Driver/[Android6.0][RK3399] Uboot 代码分析","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T02:39:42.550Z","comments":true,"path":"2017/12/31/Android_Driver/Driver/[Android6.0][RK3399] Uboot 代码分析/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_Driver/Driver/[Android6.0][RK3399] Uboot 代码分析/","excerpt":"","text":"Author: YounixPlatform: RK3399OS: Android 6.0Kernel: 4.4Version: v2017.07 [TOC] 之前曾分析过 展讯平台的 Uboot 流程：http://blog.csdn.net/dearsq/article/details/51063207也基于 RK3288 分析过 Android 启动流程：http://blog.csdn.net/dearsq/article/details/53647871 现在借着 RK3399 ，重新整体看一下 uboot 代码。 ##前一篇文章中我们了解到了make rk3399_defconfig 的原理，在 uboot 根目录会生成 .config 文件。然后我们执行 make 命令，下面是他的流程：Makefile 中默认执行 make all1815 all: $(ALL-y) ALL-y 需要生成四个目标文件12757 # Always append ALL so that arch config.mk&apos;s can add custom ones758 ALL-y += u-boot.srec u-boot.bin System.map binary_size_check 目标文件1 u-boot.srec12844 u-boot.hex u-boot.srec: u-boot FORCE845 $(call if_changed,objcopy) 目标文件2 u-boot.bin1234863 u-boot.bin: u-boot FORCE864 $(call if_changed,objcopy)865 $(call DO_STATIC_RELA,$&lt;,$@,$(CONFIG_SYS_TEXT_BASE))866 $(BOARD_SIZE_CHECK) 目标文件3 System.map121280 System.map: u-boot1281 @$(call SYSTEM_MAP,$&lt;) &gt; $@ 目标文件4 binary_size_check12345678910111213849 binary_size_check: u-boot.bin FORCE850 @file_size=$(shell wc -c u-boot.bin | awk &apos;&#123;print $$1&#125;&apos;) ; \\851 map_size=$(shell cat u-boot.map | \\852 awk &apos;/_image_copy_start/ &#123;start = $$1&#125; /_image_binary_end/ &#123;end = $$1&#125; END &#123;if (start != &quot;&quot; &amp;&amp; end != &quot;&quot;) print &quot;ibase=16; &quot; toupper(end) &quot; - &quot; toupper(start)&#125;&apos; \\853 | sed &apos;s/0X//g&apos; \\854 | bc); \\855 if [ &quot;&quot; != &quot;$$map_size&quot; ]; then \\856 if test $$map_size -ne $$file_size; then \\857 echo &quot;u-boot.map shows a binary size of $$map_size&quot; &gt;&amp;2 ; \\858 echo &quot; but u-boot.bin shows $$file_size&quot; &gt;&amp;2 ; \\859 exit 1; \\860 fi \\861 fi 所以可以看到，他们首先都需要 u-boot 这个 elf 文件。1234561128 u-boot: $(u-boot-init) $(u-boot-main) u-boot.lds1129 $(call if_changed,u-boot__)1130 ifeq ($(CONFIG_KALLSYMS),y)1131 $(call cmd,smap)1132 $(call cmd,u-boot__) common/system_map.o1133 endif 进一步分析 u-boot 依赖于三个参数 u-boot-init u-boot-main u-boot.lds第一个参数 u-boot-init 定义为12701 u-boot-init := $(head-y)630 head-y := $(CPUDIR)/start.o 第二个参数 u-boot-main定义为1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253702 u-boot-main := $(libs-y)# libs-y 为各种库和驱动，暂列一些比较关键的 636 libs-y += lib/ 637 libs-$(HAVE_VENDOR_COMMON_LIB) += board/$(VENDOR)/common/ 638 libs-y += $(CPUDIR)/ 639 ifdef SOC 640 libs-y += $(CPUDIR)/$(SOC)/ 641 endif 642 libs-$(CONFIG_OF_EMBED) += dts/ 643 libs-y += arch/$(ARCH)/lib/ 644 libs-y += fs/ 645 libs-y += net/ 646 libs-y += disk/ 647 libs-y += drivers/ 648 libs-y += drivers/dma/ 649 libs-y += drivers/gpio/ 650 libs-y += drivers/i2c/ 651 libs-y += drivers/mmc/ 652 libs-y += drivers/mtd/ 653 libs-$(CONFIG_CMD_NAND) += drivers/mtd/nand/ 654 libs-y += drivers/mtd/onenand/ 655 libs-$(CONFIG_CMD_UBI) += drivers/mtd/ubi/ 656 libs-y += drivers/mtd/spi/ 657 libs-y += drivers/net/ 658 libs-y += drivers/net/phy/ 659 libs-y += drivers/pci/ 660 libs-y += drivers/power/ \\ 661 drivers/power/fuel_gauge/ \\ 662 drivers/power/mfd/ \\ 663 drivers/power/pmic/ \\ 664 drivers/power/charge/ \\ 665 drivers/power/battery/ 666 libs-y += drivers/spi/ 667 libs-$(CONFIG_FMAN_ENET) += drivers/net/fm/ 668 libs-$(CONFIG_SYS_FSL_DDR) += drivers/ddr/fsl/ 669 libs-y += drivers/serial/ 670 libs-y += drivers/usb/eth/ 671 libs-y += drivers/usb/gadget/ 672 libs-y += drivers/usb/host/ 673 libs-y += drivers/usb/musb/ 674 libs-y += drivers/usb/musb-new/ 675 libs-y += drivers/usb/phy/ 676 libs-y += drivers/usb/ulpi/ 677 libs-y += common/ 678 libs-y += lib/libfdt/ 679 libs-$(CONFIG_API) += api/ 680 libs-$(CONFIG_HAS_POST) += post/ 681 libs-y += test/ 682 libs-y += test/dm/ 683 684 ifneq (,$(filter $(SOC), mx25 mx27 mx5 mx6 mx31 mx35 mxs vf610)) 685 libs-y += arch/$(ARCH)/imx-common/ 686 endif 值得注意的是，其中的 VENDOR、CPU、SOC、DIR、ARCH 宏是定义在 config.mk 。 第三个参数 u-boot.lds 定义为121245 u-boot.lds: $(LDSCRIPT) prepare FORCE1246 $(call if_changed_dep,cpp_lds) 123456789101112546 # If there is no specified link script, we look in a number of places for it547 ifndef LDSCRIPT548 ifeq ($(wildcard $(LDSCRIPT)),)549 LDSCRIPT := $(srctree)/board/$(BOARDDIR)/u-boot.lds550 endif551 ifeq ($(wildcard $(LDSCRIPT)),)552 LDSCRIPT := $(srctree)/$(CPUDIR)/u-boot.lds553 endif554 ifeq ($(wildcard $(LDSCRIPT)),)555 LDSCRIPT := $(srctree)/arch/$(ARCH)/cpu/u-boot.lds556 endif557 endif 对于上面三个 lds，优先级从前到后依次增加。 prepare 定义：","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 去掉顶部Google搜索栏","slug":"Android_App/[Android6.0][RK3399] 去掉顶部Google搜索栏","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T03:30:10.913Z","comments":true,"path":"2017/12/31/Android_App/[Android6.0][RK3399] 去掉顶部Google搜索栏/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_App/[Android6.0][RK3399] 去掉顶部Google搜索栏/","excerpt":"","text":"OS： Android6.0Hardware：RK3399 修改方法 搜索资料了解到，其为 QuickSearchBox。 代码在 packages/apps 中 测试了很多网上的修改 launcher3 源码的方式，都是不行的。 正确改法：在build/target/product/core.mk 去掉 QuickSearchBox","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 Reference-RIL 运行框架","slug":"Android_Sys/[Android6.0] Reference-RIL 运行框架","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T02:20:32.074Z","comments":true,"path":"2017/12/31/Android_Sys/[Android6.0] Reference-RIL 运行框架/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_Sys/[Android6.0] Reference-RIL 运行框架/","excerpt":"","text":"Reference-RIL 负责将 Solicited Request 请求转换成 AT 命令交给 Modem 执行。 将执行结果以 Solicited Response 消息方式反馈给 LibRIL。 负责接受 Modem 主动上报的消息。 Reference-RIL 运行机制1. RIL_init 初始化RIL_init 包括三个步骤： 记录 LibRIL 提供的 RIL_Env 指针，通过它可以调用 LibRIL 提供的相应函数。 启动基于 mainLoop 函数运行的子进程，mainLoop 主要负责监听和接受 Modem 主动上报的 UnSolicited 消息。 返回 Reference-RIL 提供的指向 RIL_RadioFunctions 的指针 s_callbacks。 2. onRequest 接受 LibRIL 请求调用通过查找 Reference-RIL 提供的 onRequest 函数 仅在 LibRIL 中被调用。LibRIL 接收到了 RILJ 发起的 RIL 请求后，通过 onRequest 函数调用，向 Reference-RIL 发起对应的 RIL 请求。它完成了两件事： 将 RIL 请求转化成 AT 命令，并发送给 Modem 调用 LibRIL 的 RIL_onRequestComplete 函数，完成 RIL 请求处理结果的返回。 AT 命令不同厂家的 AT 命令集不尽相同，我们这个案子采用的是 移远的 EC20。这个另开一帖单独介绍。 RIL 层运行框架和机制小结RIL 层分为三个部分，RILJ、LibRIL 、Reference-RIL：RILJ 以 RIL.java 代码为中心，负责接受 Telephony Frameworks 发起的 Telephony 相关查询或控制请求，转化成 RIL 请求发送给 LibRIL 进行处理。负责接受 LibRIL 发出的 Solicited Response 和 UnSolicited Response 消息，并将消息分发给 Telephony Frameworks。LibRIL 以 ril.cpp、ril_event.cpp 代码为中心，提供了 RILC 的 Runtime。负责接受 RILJ 发起的 RIL 请求，将 RIL 请求转化为 Reference-RIL 提供的 onRequest 函数调用，并将 RIL 请求结果反馈给 RILJ。同时，接受 Reference-RIL 发起的 Unsolicited 消息相关函数调用，并将 UnSolicited Response 消息发给 RILJ。Reference-RIL 以 reference-ril.cpp 代码为中心，负责 Modem 进行 AT 命令的交互。接受 LibRIL 的 onRequest 函数调用，根据 RIL 请求类型组合成 AT 命令，交给 Modem 执行; Modem 状态有任何变化发出 AT 命令，Reference-RIL 接受并执行，并且将 AT 命令转化为 UnSolicited 消息，发送给 LibRIL。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RILC 系统结构及 LibRIL 运行机制","slug":"Android_Sys/[Android6.0] RILC 系统结构及 LibRIL 运行机制","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T02:20:56.449Z","comments":true,"path":"2017/12/31/Android_Sys/[Android6.0] RILC 系统结构及 LibRIL 运行机制/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_Sys/[Android6.0] RILC 系统结构及 LibRIL 运行机制/","excerpt":"","text":"[TOC] RILC 代码结构12345678hardware/ril/ |- CleanSpec.mk // 编译文件 |- include // 关键头文件目录，包括 ril.h ril_cdma_sms.h |- libril // LibRIL Runtime 运行环境的源文件目录 |- mock-ril |- reference-cdma-sms // CDMA 短信相关代码 |- reference-ril // RIL Stub 实现源码文件目录 |- rild //守护进程源码文件目录 重点在于 libril、reference-ril 和 rild 三个目录中的 C/C++ 代码文件。mmm 模块编译的结果分别为 libril.so、libreference-ril.so、rild从编译 Log 中我们也可以看到123Instal:out/target/product/rk3399_mid/system/lib64/libril.soInstal:out/target/product/rk3399_mid/system/lib64/libreference-rilsoInstal:out/target/product/rk3399_mid/system/bin/rild RILC 运行机制RILC 运行在 UserLibraries 系统运行库中的 HAL 层，它使用 HAL Stub 运行结构。最关键的为 Runtime 对外提供 Proxy 代理接口，Stub 向 Runtime 提供 Operations 操作函数，Runtime 向 Stub 提供 Callback 函数。 RILC 运行机制主要围绕 LibRIL 与 Reference-RIL 相互调用，从而完成 Solicited 和 UnSolicited 消息处理，运行结构如下。包括两个过程：启动和运行。启动过程即 1.2.3. 是由 rild 完成的。运行过程的核心为 LibRIL 和 Reference-RIL 消息交互。 LibRIL 和 Reference-RIL 交互过程，符合 HAL层中基于 Stub 方式的运行机制。LibRIL 为 Runtime ，Reference-RIL 实现了 RIL 请求转换成 AT 命令，并执行 AT 命令逻辑。LibRIL 提供了 Reference-RIL 的 Proxy 代理接口。RILJ 基于 Socket 网络连接完成 Solicited 和 UnSolicited 消息 和 LibRIL 进行交互。最终交给 Reference-RIL 进行处理。Reference-RIL 和 Modem 之间通过串口通信，主要用于 AT 命令的执行。 1. RILC 启动过程1.1 RILC 加载入口device/rockchip/rk3399/init.rc123456565 service ril-daemon /system/bin/rild -l /system/lib/libreference-ril.so566 class main567 socket rild stream 660 root radio568 socket rild-debug stream 666 radio system569 user root570 group radio cache inet misc audio log Linux 在启动过程中，会加载此配置文件中配置的系统服务。所以 Android 在开机过程中，Linux Kernel 会运行 rild 可执行文件加载和启动 LibRIL。 从上面可以看出建立了两个 Socket 连接，端口号分别是 rild 和 rild-debug。 基于安全考虑，启动 ril-daemon 系统 service 服务的用户为 radio，进入控制台可以查看其进程信息12root@rk3399_mid:/ # ps | grep rild root 226 1 8416 2480 hrtimer_na 7fac161344 S /system/bin/rild 1.2 解析 RILC 加载方法hardware/ril/rild/rild.c关键函数是 RIL_startEventLoop、RIL_Init、RIL_register12345678910111213141516171819202122232425main()&#123;// 调用 ril.cpp 中的 RIL_startEventLoop，LibRIL 开始循环监听 Socket 事件// 即 可开始接受 RILJ 发起的 Socket 连接请求和 RIL Solicited 消息请求 RIL_startEventLoop();// 通过 referece-ril.so 动态链接库，获取指向 RIL_Init 函数的指针 rilInit rilInit = (const RIL_RadioFunctions *(*)(const struct RIL_Env *, int, char **)) dlsym(dlHandle, \"RIL_Init\");// 异常处理 if (rilInit == NULL) &#123; RLOGE(\"RIL_Init not defined or exported in %s\\n\", rilLibPath); exit(EXIT_FAILURE); &#125;// 调用 reference-ril.so 动态链接库的 RIL_Init 函数，传递 s_rilEnv 给 reference-ril.so// 首先，前面 dlsym 方法获取了指向 RIL_init 的指针// 其次，调用 RIL_init 完成 RIL Stub 的初始化，即 reference-ril.so 动态链接库// 其参数 s_rilEnv 即 Runtime,它的获取是在 rild.c 代码中的静态代码块中完成的// 其返回值 funcs 即 Functions funcs = rilInit(&amp;s_rilEnv, argc, rilArgv); RLOGD(\"RIL_Init rilInit completed\");// 调用 libril.so 的 RIL_register 函数，将 funcs 传递给 libril.so// 即提供其 Functions 给 LibRIL 调用。 RIL_register(funcs); RLOGD(\"RIL_Init RIL_register completed\");&#125; 上面的 main 函数整体负责启动 RILC。关键职责便是建立 LibRIL 和 Reference-RIL 的一种相互协调的能力。LibRIL 中有指向 Reference-RIL 中 funcs 结构体的指针。Reference-RIL 中有指向 LibRIL 中 s_rilEnv 结构体（Runtime） 的指针。建立关系后，两者就可以开始 RIL 消息的交互。 2. RILC 运行过程LibRIL 现在可以和 Reference-RIL 开始 RIL 消息的交互。根据消息流向分为两种类型：下行消息：LibRIL 接收到 RILJ 发起的 Solicited 消息后，LibRIL 适用 funcs 调用 Reference-RIL 的 onRequest、onStateRequest 等方法。上行消息：Modem 中相关通信的状态发生变化或者执行完 Solicited 请求消息后，Reference-RIL 可以通过 s_rilEnv 结构体指针调用 LibRIL 中的方法，完成上行消息的发送。 3. RILC Runtime LibRIL3.1 代码架构hardware/ril/libril├── Android.mk├── ril_commands.h // 定义了 LibRIL 接收到 RILJ发出的 Solicited 请求消息所对应的调用函数和返回调用函数├── ril.cpp // 建立 Runtime 框架├── ril_event.cpp // 实现基于 ril_event 双向链表操作函数 ，在 5 节中讲解├── ril_event.h // ril_event 事件的结构定义├── ril_ex.h├── RilSapSocket.cpp├── RilSapSocket.h├── RilSocket.cpp├── RilSocket.h├── rilSocketQueue.h└── ril_unsol_commands.h // 定义了 UnSolicited 消息返回调用的函数 LibRIL 以 ril.cpp 代码为核心，其他代码协助它完成 LibRIL Runtime 的启动和运行，LibRIL Runtime 的两个作用： 与 RILJ 基于 Socket 交互 与 Reference-RIL 基于函数调用的交互 3.2 结构体 RIL_Envhardware/ril/include/telephony/ril.hhardware/ril/reference-ril/ril.h这两个 ril.h 完全相同。RIL_Env 在 ril.h 中的定义如下12345678910111213141516171819202122232425262728293031323334353637383940struct RIL_Env &#123; /** * \"t\" is parameter passed in on previous call to RIL_Notification * routine. * If \"e\" != SUCCESS, then response can be null/is ignored * \"response\" is owned by caller, and should not be modified or * freed by callee * RIL_onRequestComplete will return as soon as possible */ //动态库完成一个请求后，通过 OnRequestComplete 通知处理结果，其中第一个参数标明是哪个请求的处理结果 void (*OnRequestComplete)(RIL_Token t, RIL_Errno e, void *response, size_t responselen);#if defined(ANDROID_MULTI_SIM) /** * \"unsolResponse\" is one of RIL_UNSOL_RESPONSE_* * \"data\" is pointer to data defined for that RIL_UNSOL_RESPONSE_* * \"data\" is owned by caller, and should not be modified or freed by callee */ void (*OnUnsolicitedResponse)(int unsolResponse, const void *data, size_t datalen, RIL_SOCKET_ID socket_id);#else /** * \"unsolResponse\" is one of RIL_UNSOL_RESPONSE_* * \"data\" is pointer to data defined for that RIL_UNSOL_RESPONSE_* * \"data\" is owned by caller, and should not be modified or freed by callee */ // 动态库用于进行unsolicited Response通知的函数 void (*OnUnsolicitedResponse)(int unsolResponse, const void *data, size_t datalen);#endif /** * Call user-specifed \"callback\" function on on the same thread that * RIL_RequestFunc is called. If \"relativeTime\" is specified, then it specifies * a relative time value at which the callback is invoked. If relativeTime is * NULL or points to a 0-filled structure, the callback will be invoked as * soon as possible */ // 给Rild提交一个超时任务 void (*RequestTimedCallback) (RIL_TimedCallback callback, void *param, const struct timeval *relativeTime);&#125;; 定义了三个指向函数的指针。其功能在上面注释中有说明。 3.3 结构体 RIL_RadioFunctions12345678typedef struct &#123; int version; /* set to RIL_VERSION */ //版本号 RIL_RequestFunc onRequest; RIL_RadioStateRequest onStateRequest; RIL_Supports supports; RIL_Cancel onCancel; RIL_GetVersion getVersion;&#125; RIL_RadioFunctions; 当 LibRIL 接收到 RILJ 发起的 Solicited 请求消息后，其他 5 个指向函数的指针会调用 Reference-RIL 提供的 funcs 中对应请求函数。 4. LibRIL Runtime 加载LibRIL Runtime 的加载体现在 RIL_startEventLoop 和 RIL_register 两个函数。 4.1 RIL_startEventLoopRILC 启动过程中，先调用 LibRIL 中的 RIL_startEventLoop 函数完成 LibRIL 运行环境的准备，然后开始循环监听 Socket 相关 RIL 事件。12345678910111213141516171819202122232425extern \"C\" void // 标识后此方法可以让 rild.c 调用RIL_startEventLoop(void) &#123; /* spin up eventLoop thread and wait for it to get started */ s_started = 0; // 启动标志 pthread_mutex_lock(&amp;s_startupMutex); // 增加 pthread 的同步锁 pthread_attr_t attr; pthread_attr_init(&amp;attr); // 初始化 pthread 参数 pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); // 创建基于 eventLoop 函数调用的子线程 int result = pthread_create(&amp;s_tid_dispatch, &amp;attr, eventLoop, NULL); if (result != 0) &#123; RLOGE(\"Failed to create dispatch thread: %s\", strerror(result)); goto done; &#125; while (s_started == 0) &#123; // pthread 启动标志，会在 eventLoop 方法中设置为 1 // 等待 s_startupCond 通知 pthread_cond_wait(&amp;s_startupCond, &amp;s_startupMutex); &#125;done: pthread_mutex_unlock(&amp;s_startupMutex); //释放锁&#125; eventLoop 函数 进入 ril.cpp 代码中的 eventLoop 函数，其处理逻辑如下：12345678910111213141516171819202122232425262728293031323334353637383940static void *eventLoop(void *param) &#123; int ret; int filedes[2]; ril_event_init(); // 初始化 ril_event 双向链表 pthread_mutex_lock(&amp;s_startupMutex); // 增加 pthread 同步锁 s_started = 1; // 修改启动状态为 1 pthread_cond_broadcast(&amp;s_startupCond); pthread_mutex_unlock(&amp;s_startupMutex); // 释放 thread 同步锁 ret = pipe(filedes); // 创建管道通信 if (ret &lt; 0) &#123; // 管道创建异常处理 RLOGE(\"Error in pipe() errno:%d\", errno); return NULL; // 直接返回 NULL &#125; s_fdWakeupRead = filedes[0]; // 输入文件描述符 s_fdWakeupWrite = filedes[1]; // 输出文件描述符 fcntl(s_fdWakeupRead, F_SETFL, O_NONBLOCK); // 设置新创建 RIL 事件的 ril_event 参数，关注 s_fdWakeupRead 文件描述符 以及 RIL 事件回调方法 processWakeupCallback ril_event_set (&amp;s_wakeupfd_event, s_fdWakeupRead, true, processWakeupCallback, NULL); // 增加 ril_event 节点，并激活 rilEventAddWakeup (&amp;s_wakeupfd_event); // Only returns on error 只在异常情况下才返回 // 调用 ril_event.cpp 中 ril_event_init 函数，开始循环监听和处理 ril_event 时间 ril_event_loop(); RLOGE (\"error in event_loop_base errno:%d\", errno); // kill self to restart on error 异常时自杀重启 kill(0, SIGKILL); return NULL;&#125; s_wakeupfd_event 的事件处理s_wakeupfd_event 事件处理主要分为三大块，如下： 创建管道获取其输入输出文件描述符 s_fdWakeupRead、s_fdWakeupWrite 使用 s_fdWakeupRead 和 processWakeupCallback 创建 s_wakeupfd_event 事件 增加并激活 s_wakeupfd_event 事件 ril_event 双向链表中此时仅有一个节点，那就是 s_wakeupfd_event。此节点的 fd 文件描述符为 s_fdWakeupRead，RIL 事件回调函数为 processWakeupCallback。 ril_event_loop 函数ril_event.cpp在 ril_event_loop 函数中，核心是 for(;;) 循环，只要循环中处理逻辑不变化，ril_event_loop 函数调用是不会返回的。 4.2 RIL_register 函数引入三方 RIL_RadioFunctionsRIL_register 函数其作用在于引入第三方 Reference-RIL（以封装后 so 动态链接库提供 libreference-ril.so）。关键代码在于对第三方 Reference-RIL 提供的 callbacks 参数（funcs）作 判空、版本号 等验证，验证过后，拷贝保存此指向 RIL_RadioFunctions 结构体指针。这样 LibRIL 中就可以调用第三方 Reference-RIL 提供的 RIL 请求相关函数。 5. ril_event 事件处理机制RIL 事件相关的数据均封装在 ril_event 结构体中，一个 RIL 事件会对应一个 ril_event 结构体。LibRIL 在启动完成后进入运行状态，将围绕 ril_event 结构体处理 RIL 相关事件。 5.1 ril_event 数据结构hardware/ril/libril/ril_event.h1234567891011121314// 定义指向 RIL 事件 Callback 回调函数的指针 ril_event_cbtypedef void (*ril_event_cb)(int fd, short events, void *userdata);struct ril_event &#123; struct ril_event *next; struct ril_event *prev; int fd; int index; // 当前 RIL 事件的索引 bool persist; // 保留当前 RIL 事件标志 struct timeval timeout; // RIL 事件超时设置 ril_event_cb func; // RIL 事件回调函数指针 void *param;&#125;; 5.2 RIL 事件生命周期控制的处理函数ril_event_init 双向链表初始化ril_event_set 设置新创建 ril_event 时间参数ril_event_add 增加 event 5.3 ril_event_loop 处理机制LibRIL 运行环境加载过程中，最后会调用 ril_event_loop 函数，开始监听 RIL 事件。分为两步：1）增加 pending_list 双向链表中的 RIL 事件节点。processTimeouts 和 processReadReadies 两个函数都是将对应 RIL 事件增加到 pending_list 双向链表。2）调用 firePending 函数遍历 pending_list 双向链表获取 ril_event ，调用其 func 回调函数，完成对应 RIL 事件的回调。 6. LibRIL 运行机制分为两个部分：1） RILJ 建立与 RIL 的 Socket 连接2） RILJ 向 RIL 发起 Solicited 消息的交互流程和处理机制。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 启动流程分析之一概述","slug":"Android_Sys/[Android6.0] 启动流程分析之一概述","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T02:21:27.553Z","comments":true,"path":"2017/12/31/Android_Sys/[Android6.0] 启动流程分析之一概述/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_Sys/[Android6.0] 启动流程分析之一概述/","excerpt":"","text":"[TOC] 概述总得来看有这样几个阶段： BootROM 上电 BootLoader 引导 Linux 内核 init 进程 Zygote 启动 展开一点来看 板子上电后运行固化在 ROM 中的代码，加载 Bootloader 到 RAM。 Bootloader 启动，引导进入 Linux 内核。 Kernel 启动 swapper 进程。即 idle 进程，pid = 0，系统初始化过程中的第一个进程，用于初始化 进程管理、内存管理、加载 Display、Camera Driver、Binder Driver 的工作。Kernel 启动 init 进程（用户进程的祖宗）。pid = 1，用来孵化用户空间的守护进程、HAL、开机动画等。Kernel 启动 threadd 进程（内核进程的祖宗）。pid = 2，创建内核工程线程 kworkder，软中断线程等。 init 进程 fork 出 Daemon 进程：孵化出ueventd、logd、healthd、installd、adbd、lmkd 等用户守护进程；init 进程启动servicemanager(binder服务管家)、bootanim(开机动画)等重要服务;init 进程孵化出Zygote进程，Zygote进程是Android系统的第一个Java进程，Zygote是所有Java进程的父进程（Android 应用程序的祖宗），Zygote进程本身是由 init 进程孵化而来的。 Zygote 孵化出 System Server 和 App。它是 Android 系统的核心进程，提供了应用程序生命周期管理，地理位置信息等各种 Service（这些 Service 同样需要注册到 Context Manager）。 下面我们具体的一个个的来分析。 一、BootROM按下电源后，引导芯片代码从预定义的地方（固化在 ROM）开始执行。加载引导程序到 RAM，然后执行引导程序（bootloader）。 二、Bootloader 引导程序Bootloader 有很多，最常见的就是 uboot。 按所执行的功能分为两个阶段： 检测外部的 RAM 以及加载对第二阶段有用的程序。 引导程序设置网络、内存等等。这些对于运行内核是必要的，为了达到特殊的目标，引导程序可以根据配置参数或者输入数据设置内核。 按代码来看分成两个部分： init.S 初始化堆栈，清零BSS段，调用main.c的_main() 函数。 main.c 初始化硬件（闹钟、主板、键盘、控制台），创建 linux 标签。 三、Linux 内核内核启动时，设置缓存、被保护存储器、计划列表，加载驱动。当内核完成系统设置，它首先在系统文件中寻找”init”文件，然后启动 root 进程或者系统的第一个进程。 kernel 的入口点是 stext，这是一个汇编函数。从stext开始kernel将会完成一系列通过汇编语言实现芯片级的初始化工作，并以静态定义的方式创建kernel的第一个kernel进程init_task，即 0号进程。然后跳转到kernel的第一个c语言函数start_kernel完成后续十分繁杂的kernel初始化工作（setup_arch，mm_init，sched_init，init_IRQ以及最为关键的rest_init等几个函数）在rest_init中创建了kernel的第二个kernel进程 kernel_init（1号进程）和第二个kernel进程kthreadd（2号进程），对于驱动工程来说，需要关注下kernel_init调用的do_basic_setup函数，其完成了系统驱动初始化工作。最后kernel_init通过调用run_init_process(“/init”)，开始执行init程序，并从kernel进程转化为第一个用户进程。 参考：Kernel 启动流程源码总结 四、init 进程init 进程是Linux系统中用户空间的第一个进程，进程号为1。它是 用户进程 的祖先。 关键路径init 进程 /system/core/initinit.rc 脚本 /system/core/rootdir/init.rcreadme.txt /system/core/init/readme.txt 作用 分析和运行所有的init.rc文件; //parser.ParseConfig(“/init.rc”); 生成设备驱动节点; （通过rc文件创建） 处理子进程的终止(signal方式); 提供属性服务。 //start_property_service() 创建 Zygote5.1 解析 init.zygote.rc //parse_service()5.2 启动 main 类型服务 //do_class_start()5.3 启动 zygote 服务 //service_start()5.4 创建 Zygote 进程 //fork()5.5 创建 Zygote Socket //create_socket() init.rc 中启动的 Action 和 Service ：on early-init：设置init进程以及它创建的子进程的优先级，设置init进程的安全环境on init：设置全局环境，为cpu accounting创建cgroup(资源控制)挂载点on fs：挂载mtd分区on post-fs：改变系统目录的访问权限on post-fs-data：改变/data目录以及它的子目录的访问权限on boot：基本网络的初始化，内存管理等等service servicemanager：启动系统管理器管理所有的本地服务，比如位置、音频、Shared preference等等…service zygote：启动zygote作为应用进程 参考：Android 的 Init 进程参考：Android系统启动-init篇 五、Zygote 创建与启动应用Zygote 是什么Zygote 顾名思义，是所有 Android 应用的祖先。 最开始，在 Java 中，不同的虚拟机实例可以为不同的应用分配不同的内存。但如果Android系统为每一个应用启动不同的 VM 实例，就会消耗大量的内存以及时间。因此，为了克服这个问题，Android系统创造了“Zygote”。 Zygote 让 VM 共享代码、低内存占用以及最小的启动时间成为可能。 Zygote 是一个虚拟机进程，正如我们在前一个步骤所说的在系统引导的时候启动。Zygote 预加载以及初始化核心库类。通常，这些核心类一般是只读的，也是 Android SDK 或者核心框架的一部分。在Java虚拟机中，每一个实例都有它自己的核心库类文件和堆对象的拷贝。 关键代码路径framework 层123456789App_main.main AndroidRuntime.start startVm startReg ZygoteInit.main registerZygoteSocket preload startSystemServer runSelectLoop 流程分析Zygote是由init进程通过解析init.zygote.rc文件而创建的，zygote所对应的可执行程序app_process，所对应的源文件是App_main.cpp，进程名为zygote。 创建虚拟机 //App_main.cpp 首先生成了一个 AppRuntime 对象，该类是继承自AndroidRuntime的，该类用来初始化并且运行 VM，为运行Android应用做好准备。//AndroidRuntime.start接受main 函数传递进来的参数，-Xzygote /system/bin –zygote –start-system-server 然后初始化虚拟机 startVM。调用 JNI_CreateJavaVM 创建虚拟机。 startReg。JNI 函数注册。 虚拟机初始化之后 //ZygoteInit.javaZygoteInit 代码流程： 绑定套接字。接受 Activity Manager 来的应用启动请求。 加载 Android Framework 中的 class、res（drawable、xml信息、strings）到内存。Android 通过在 Zygote 创建的时候加载资源，生成信息链接，再有应用启动，fork 子进程和父进程共享信息，不需要重新加载，同时也共享 VM。 启动 System Server。因为我们的应用启动需要这些 server 的参与，所以需要先启动 System Server。接下来启动 ServerThread 来执行 Android Framework 服务，并通过 JNI 向 Context Manager 注册。 Zygote 在轮询监听 Socket，当有请求到达，读取请求，fork 子进程，加载进程需要的类，执行所要执行程序的 Main。代码转给了 VM，App 也启动起来了。然后 Zygote 关闭套接字，删除请求描述符，防止重复启动。 参考 Android系统启动-zygote篇 六、SystemServerZygote启动过程中会调用startSystemServer()，可知startSystemServer()函数是system_server启动流程的起点， 启动流程图如下： system_server进程，从源码角度划分为引导服务、核心服务、其他服务3类。引导服务(7个)：ActivityManagerService、PowerManagerService、LightsService、DisplayManagerService、PackageManagerService、UserManagerService、SensorService；核心服务(3个)：BatteryService、UsageStatsService、WebViewUpdateService；其他服务(70个+)：AlarmManagerService、VibratorService等。 参考：http://gityuan.com/2016/02/14/android-system-server/ 七、引导结束System Servers 在内存中跑起来后，发送开机广播 “ACTION_BOOT_COMPLETED”。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 Mipi LCD NT35521 移植调试流程","slug":"Android_Driver/Driver/[Android6.0][RK3399] Mipi LCD NT35521 移植调试流程","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T02:36:26.572Z","comments":true,"path":"2017/12/31/Android_Driver/Driver/[Android6.0][RK3399] Mipi LCD NT35521 移植调试流程/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_Driver/Driver/[Android6.0][RK3399] Mipi LCD NT35521 移植调试流程/","excerpt":"","text":"根据 datasheet 和 硬件设计填写 dtsmipi_dsi_init1234567disp_mipi_init: mipi_dsi_init&#123; compatible = &quot;rockchip,mipi_dsi_init&quot;; rockchip,screen_init = &lt;1&gt;; rockchip,dsi_lane = &lt;4&gt;; rockchip,dsi_hs_clk = &lt;1000&gt;; rockchip,mipi_dsi_num = &lt;1&gt;; &#125;; GPIO 12345mipi_lcd_en:mipi_lcd_en &#123; compatible = &quot;rockchip,lcd_en&quot;; rockchip,gpios = &lt;&amp;gpio1 13 GPIO_ACTIVE_HIGH&gt;; rockchip,delay = &lt;20&gt;;&#125;; 12345mipi_lcd_rst:mipi_lcd_rst &#123; compatible = &quot;rockchip,lcd_rst&quot;; rockchip,gpios = &lt;&amp;gpio4 30 GPIO_ACTIVE_HIGH&gt;; rockchip,delay = &lt;100&gt;;&#125;; 1234567backlight: backlight &#123; status = &quot;disabled&quot;; compatible = &quot;pwm-backlight&quot;; pwms = &lt;&amp;pwm0 0 25000 0&gt;; brightness-levels = &lt; ... &gt;; Display Timing1234567891011121314151617181920212223242526 disp_timings: display-timings &#123; native-mode = &lt;&amp;timing0&gt;; compatible = &quot;rockchip,display-timings&quot;; timing0: timing0 &#123; screen-type = &lt;SCREEN_MIPI&gt;; lvds-format = &lt;LVDS_8BIT_2&gt;; out-face = &lt;OUT_P888&gt;; clock-frequency = &lt;76000000&gt;; hactive = &lt;800&gt;; vactive = &lt;1280&gt;; hback-porch = &lt;80&gt;; hfront-porch = &lt;80&gt;; vback-porch = &lt;23&gt;; vfront-porch = &lt;18&gt;; hsync-len = &lt;0&gt;; vsync-len = &lt;0&gt;; hsync-active = &lt;0&gt;; vsync-active = &lt;0&gt;; de-active = &lt;0&gt;; pixelclk-active = &lt;0&gt;; swap-rb = &lt;0&gt;; swap-rg = &lt;0&gt;; swap-gb = &lt;0&gt;; //screen-width = &lt;68&gt;; //screen-hight = &lt;120&gt;;&#125;; init cmd屏场给的 Init cmd 序列是 MTK 平台的。形如1234data_array[0]=0x00043902;data_array[1]=0x8983FFB9; dsi_set_cmdq(&amp;data_array, 2, 1); MDELAY(10); 转换规则在 http://blog.csdn.net/dearsq/article/details/52354593讲的很详细。不再赘述了。这个屏竟然有 112 条 inital cmd 。第一次碰到这么多 cmd 的屏。 进行调试","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 OTA差异包制作方法","slug":"Environment/Firefly-RK3399/[Android6.0][RK3399] OTA差异包制作方法","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T02:11:35.957Z","comments":true,"path":"2017/12/31/Environment/Firefly-RK3399/[Android6.0][RK3399] OTA差异包制作方法/","link":"","permalink":"http://iyounix.com/2017/12/31/Environment/Firefly-RK3399/[Android6.0][RK3399] OTA差异包制作方法/","excerpt":"","text":"Platform: RK3399OS: Android 6.0Version: v2016.08 [TOC] 一、全编12make -j32./mkimage.sh ota 二、生成原始的 OTA 完整包1make otapackage 会在 out/target/product/rk3399_disvr/ 下生成 rk3399_disvr-ota-user.younix.20161116.102654.zip 所生成的这个 rk3399_disvr-ota-user.younix.20161116.102654.zip 改名为 update.zip 即可用于固件升级 将这个改名为 ×-old.zip 用来作为后面差异 OTA 包的 target filerk3399_disvr-ota-user.younix.old.zip123mv ~/3399/out/target/product/rk3399_disvr/obj/PACKAGING/target_files_intermediates/rk3399_disvr-ota-user.younix.20161116.102654.zip~/3399/out/target/product/rk3399_disvr/obj/PACKAGING/target_files_intermediates/rk3399_disvr-ota-user.younix.old.zip 三、修改了一些内容… 四、生成 OTA 差异包生成差异包命令格式:ota_from_target_files–v –i 用于比较的前一个 target file–p host 主机编译环境‐k 打包密钥用于比较的后一个 target file最后生成的 ota 差异包123456789101112//1. 生成新的 ota 包make otapackage//生成了 rk3399_disvr-ota-user.younix.20161116.104037.zip//2. 生成差异包./build/tools/releasetools/ota_from_target_files ‐v –i ~/3399/out/target/product/rk3399_disvr/obj/PACKAGING/target_files_intermediates/rk3399_disvr-ota-user.younix.old.zip‐p out/host/linux‐x86 ‐k build/target/product/security/testkey ~/3399/out/target/product/rk3399_disvr/obj/PACKAGING/target_files_intermediates/rk3399_disvr-ota-user.younix.20161116.104037.zip~/3399/out/target/product/rk3399_disvr/rk3399_disvr-ota-user.younix.zip ~/3399/out/target/product/rk3399_disvr/rk3399_disvr-ota-user.younix.zip即为差异包","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Linux RK3399 基于 Firefly RK3399 Board 制作 Ubuntu Desktop 版本","slug":"Environment/Firefly-RK3399/[Linux][RK3399] 基于 Firefly RK3399 Board 制作 Ubuntu Desktop 版本","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T02:12:35.587Z","comments":true,"path":"2017/12/31/Environment/Firefly-RK3399/[Linux][RK3399] 基于 Firefly RK3399 Board 制作 Ubuntu Desktop 版本/","link":"","permalink":"http://iyounix.com/2017/12/31/Environment/Firefly-RK3399/[Linux][RK3399] 基于 Firefly RK3399 Board 制作 Ubuntu Desktop 版本/","excerpt":"","text":"Platform: RK3399OS: Android 6.0Kernel: 4.4Version: v2017.04 编译 u-boot123cd u-bootmake rk3399_defconfigmake ARCHV=aarch64 -j8 制作出来的文件包括uboot.imgtrust.imgRK3399MiniLoaderAll_V1.05.bin 编译 kernel123cd kernelmake ARCH=arm64 firefly_linux_defconfigmake ARCH=arm64 rk3399-firefly-mini-linux.img -j8 制作出来的文件包括kernel.imgresource.imgarch/arm64/boot/Image 整合内存盘 打包成 boot.img创建内存盘 Ramdisk12git clone -b for-kernel_4.4 https://github.com/TeeFirefly/initrd.gitmake -C initrd 会生成 initrd.img 打包内核和内存盘1mkbootimg --kernel arch/arm64/boot/Image --ramdisk initrd.img --second resource.img -o boot.img 会生成 boot.img 修改 parameter.txt 文件CMDLINE: console=tty0 console=ttyFIQ0 root=/dev/mmcblk1p5 rw rootwait rootfstype=ext4 init=/sbin/init mtdparts=rk29xxnand:0x00002000@0x00002000(uboot),0x00002000@0x00004000(trust),0x00010000@0x00006000(boot),0x00002000@0x00016000(backup),-@0x00018000(rootfs) 制作根文件系统下载和解压 ubuntu-basemkdir ubuntu-desktopsudo tar -xpf ubuntu-base-16.04.1-base-arm64.tar.gz -C ubuntu-desktop 修改配置及更新软件将本机网络配置拷贝到文件系统中sudo cp -b /etc/resolv.conf ubuntu-desktop/etc/resolv.conf #### 拷贝 qemusudo cp /usr/bin/qemu-aarch64-static ubuntu-desktop/usr/bin 进入根文件系统进行操作sudo chroot ubuntu-desktop如果产生报错 问题2 更新和安装apt updateapt upgradeapt install vim git #根据需求添加apt install xubuntu-desktop #这一步根据网速差别可能长达十几个小时，这也是 base 版本和 desktop 版本的区别所在 添加账户并设置密码useradd -s ‘/bin/bash’ -m -G adm,sudo orangepipasswd orangepi #给 orangepi 这个用户设置密码passwd root #给 root 用户设置密码 退出exit 开始制作 rootfs查看文件系统大小sudo du -sh ubuntu-desktop4.7G ubuntu-desktop分配 8GB，count 根据实际自己的大小进行修改dd if=/dev/zero of=rootfs.img bs=1M count=8096sudo mkfs.ext4 rootfs.imgmkdir -pv rootfs_mntsudo mount rootfs.img rootfs_mntsudo cp -rfp ubuntu-desktop/* rootfs_mnt/sudo umount -R rootfs_mnte2fsck -p -f rootfs.imgresize2fs -M rootfs.img rootfs.img 即为最终根文件系统的镜像文件 问题汇总问题2chroot: failed to run command ‘/usr/bin/bash’: No such file or directory手动指定 bash 路径sudo chroot ubuntu-desktop /bin/bash","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"Android6.0 RK3399 去掉滑动锁屏","slug":"Android_App/[Android6.0][RK3399] 去掉滑动锁屏(swipe lock)","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T03:29:48.165Z","comments":true,"path":"2017/12/31/Android_App/[Android6.0][RK3399] 去掉滑动锁屏(swipe lock)/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_App/[Android6.0][RK3399] 去掉滑动锁屏(swipe lock)/","excerpt":"","text":"Platform: RK3399OS: Android 6.0Version: v2017.03 解决方法（一）在 ~/rk_Project_3399/device/rockchip/rk3399/rk3399_YOUR_DEVICE下的 system.prop 中添加 1ro.lockscreen.disable.default=true 重新编译后，成功去掉锁屏，锁屏失效。 代码流程该属性 调用到一下两个地方：rk_Project_3399/frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java123456if (SystemProperties.getBoolean(&quot;ro.lockscreen.disable.default&quot;, false) == true) &#123; loadSetting(stmt, Settings.System.LOCKSCREEN_DISABLED, &quot;1&quot;); &#125; else &#123; loadBooleanSetting(stmt, Settings.System.LOCKSCREEN_DISABLED, R.bool.def_lockscreen_disabled); &#125; SystemProperties.getBoolean 的实现在 JNI 层，实际上是通过 property_get 获取 ro.lockscreen.disable.default 的值获取后如果等于 true 就设置 stmt 数据库中 key 为 Settings.System.LOCKSCREEN_DISABLED 的字段为 1如果没有获取到或者获取到为 false，则设置该字段为 R.bool.def_lockscreen_disabled，后者是在 default.xml 中定义的（所以我们也可以通过改 default.xml 的方式来完成属性的更改。见解决方法二。） rk_Project_3399/frameworks/base/services/core/java/com/android/server/LockSettingsService.java:12345678public void initialize(SQLiteDatabase db) &#123; // Get the lockscreen default from a system property, if available boolean lockScreenDisable = SystemProperties.getBoolean( &quot;ro.lockscreen.disable.default&quot;, false); if (lockScreenDisable) &#123; mStorage.writeKeyValue(db, LockPatternUtils.DISABLE_LOCKSCREEN_KEY, &quot;1&quot;, 0); &#125;&#125; 获取系统属性，如果获取到了就将数据库的 LockPatternUtils.DISABLE_LOCKSCREEN_KEY 字段设置为 1 完成后123rm out/target/product/rk3399/system/build.propmake -j4./mkimage 解决方法（二）frameworks/base/packages/SettingsProvider/res/values/defaults.xml1&lt;bool name=&quot;def_lockscreen_disabled&quot;&gt;false&lt;/bool&gt; 改为 true 即默认禁止锁屏 改完后12rm out/target/product/rk3399/system/framework/framework.jarrm out/target/product/rk3399/system/priv-app/SettingsProvider/SettingsProvider.apk mm 后 push 并恢复出厂设置或者 make -j4 再./mkimage","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Linux RK3399 DRM 框架及代码流程","slug":"Android_Driver/Driver/[Linux4.4][RK3399] DRM 框架及代码流程","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T02:45:07.055Z","comments":true,"path":"2017/12/31/Android_Driver/Driver/[Linux4.4][RK3399] DRM 框架及代码流程/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_Driver/Driver/[Linux4.4][RK3399] DRM 框架及代码流程/","excerpt":"","text":"RK3399OS: Android 6.0Kernel: 4.4Version: v2017.04 DRM 简介定义DRM: Direct Rendering Manager 它用于处理显卡（graphic cards embedding GPUs）KMS: Kernel Mode Setting 它是 DRM API 的一个子集由 渲染 及 模式设置 方式的差别有两种不同的 API (/dev/dri/renderX 和 /dev/dri/controlDX)KMS 提供了一种配置显卡的方式 对比Linux 中显示方式还有其他方式，比如 FBDEV 和 V4L2DRM 的优势在于：更新很活跃被广泛用于用户空间图形栈有一些高级的特性（overlays、hw cursor …） 架构 1）DRM 组件：Framebuffer显示信息存储在如下地方： 指向被用来存储显示内容的内存区域 一部分内存用于存储帧的格式 活跃的内存区域中的内容将被显示呈现 DRM 帧缓存是一个虚拟的对象（依赖于某一个具体的实现）帧缓存具体的实现取决于： 正在使用的内存管理器（GEM或TTM） 显示控制器功能：支持 DMA、IOMMUGEM对象的默认实现可以使用CMA（连续内存分配器）：drivers/gpu/drm/drm_fb_cma_helper.c其他的实现常常取决于显示控制器 Scatter Gather 的例子：drivers/gpu/drm/tegra IOMMU 的例子：drivers/gpu/drm/exynos pixel_format 描述内存缓存组织FOURCC 格式的编码支持的格式在如下头文件定义：include/drm/drm_fourcc.h这些 FOURCC 格式 不是标准化的，因此它们仅在 DRM/KMS 子系统中有效。 DRM/KMS 子系统中用到了三种类型的格式：RGB：每个像素以 RGB 元编码。YUV：每个像素以 YUV 元编码C8 ：使用转换表将值映射到RGB元 其中 YUV 支持不同的模式：封装：一部分内存区域存储所有组件（Y，U和V）semi-planar：一部分内存区域用来存储 Y 一部分用来存储 UVplane：用来存所有组件的内存区域 每一个用来存放帧元的内存区域被称作 plane 2）Planes3）CRTC4）Encoder5）Connector// TODO14/49http://events.linuxfoundation.org/sites/events/files/slides/brezillon-drm-kms.pdf","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"Android6.0 RK3399 SATA 设备调试笔记","slug":"Android_Driver/Driver/[Android6.0][RK3399] SATA 设备调试笔记","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T02:38:59.702Z","comments":true,"path":"2017/12/31/Android_Driver/Driver/[Android6.0][RK3399] SATA 设备调试笔记/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_Driver/Driver/[Android6.0][RK3399] SATA 设备调试笔记/","excerpt":"","text":"[TOC] SATA 基础知识Linux 世界中，I/O 设备被分为 字符设备、块设备、网络设备。SATA 这种存储设备属于块设备。块设备用来存储定长，且可随时访问的数据块，对块设备的操作都以块（block）为单位进行。在高性能系统的块设备（block devices）I/O 控制方式中，DMA 和 I/O通道方式比较常用。前者由 DMA 控制器接管 CPU 总线控制权，数据不经过 CPU 而直接在内存和 I/O 设备间进行块传输，进而提升系统的数据传输效率。后者可以获得 CPU 和外设间更好的并行能力。 SATA 是一种新型块设备（Serial ATA），这需要我们开发一种功能与性能更强的 I/O 控制器来发挥其高性能。着这控制器就是 ADMA 控制器，它采用一种新的 I/O 控制方式。 SATA 是一种串行架构。同 IDE/ATA、SCSI 接口的块设备相比，SATA 优点大大的。包括 1）pin 更少 2）速度更快，1.0 150MB/s 3.0 600MB/s 3）热插拔 4）拓展性好。5）成本低，就成本而言，远低于 SCSI 产品。 SATA 设备调试当有外置 USB 插入的时候，会产生 /proc/scsi/usb-storage 目录，并在其中产生数字文件（形如 1 2 3 4），此文件存储了设备相关信息。 相应的 /sys/class/scsi_device/ 目录中会有 scsi 设备的目录(ide 硬盘默认无子目录，sata硬盘默认有子目录)，以数字开头（形如 1:0:0:0 2:0:0:0）这个数字与前面 /proc/scsi/usb-storage目录中的相对应，子目录表示sata硬盘。 /sys/class/scsi_device/2:0:0:0/device/block 中有 sata 设备文件，其中有多个文件，我们关注 removeable 和 dev12345# cat dev8:0#cat removable0 dev 内容形如 8:0 ，就是 /proc/partitions 中设备的 maj:min 主设备号:次设备号。removable 可以为 0 或者 1 ，1 表示 U 盘，0 表示硬盘。 据此，先看usb-storage目录，再到/sys目录下找相应的removable和dev文件，再查partitions文件，就可以得到设备名、设备信息、可移动标记。 12345678910111213141516171819202122232425262728293031root@rk3399_mid:/sys/class/scsi_device/2:0:0:0/device/block/sda # mount rootfs / rootfs ro,seclabel,size=953876k,nr_inodes=238469 0 0tmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0devpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0proc /proc proc rw,relatime 0 0sysfs /sys sysfs rw,seclabel,relatime 0 0selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0none /acct cgroup rw,relatime,cpuacct 0 0none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0tmpfs /mnt tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0none /dev/cpuctl cgroup rw,relatime,cpu 0 0none /dev/cpuset cgroup rw,relatime,cpuset,noprefix,release_agent=/sbin/cpuset_release_agent 0 0pstore /sys/fs/pstore pstore rw,seclabel,relatime 0 0/dev/block/platform/fe330000.sdhci/by-name/system /system ext4 ro,seclabel,noatime,nodiratime,noauto_da_alloc,data=ordered 0 0/dev/block/platform/fe330000.sdhci/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,noatime,nodiratime,discard,noauto_da_alloc,data=ordered 0 0/dev/block/platform/fe330000.sdhci/by-name/metadata /metadata ext4 rw,seclabel,nosuid,nodev,noatime,nodiratime,discard,noauto_da_alloc,data=ordered 0 0tmpfs /storage tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0/sys/kernel/debug /sys/kernel/debug debugfs rw,seclabel,relatime,mode=755 0 0/sys/kernel/debug/tracing /sys/kernel/debug/tracing tracefs rw,seclabel,relatime,mode=755 0 0none /config configfs rw,relatime 0 0adb /dev/usb-ffs/adb functionfs rw,relatime 0 0/dev/block/dm-0 /data f2fs rw,seclabel,nosuid,nodev,noatime,nodiratime,background_gc=on,discard,user_xattr,inline_xattr,inline_data,extent_cache,active_logs=6 0 0/dev/fuse /mnt/runtime/default/emulated fuse rw,nosuid,nodev,noexec,noatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0/dev/fuse /storage/emulated fuse rw,nosuid,nodev,noexec,noatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0/dev/fuse /mnt/runtime/read/emulated fuse rw,nosuid,nodev,noexec,noatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0/dev/fuse /mnt/runtime/write/emulated fuse rw,nosuid,nodev,noexec,noatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0/dev/block/vold/public:8,1 /mnt/meDia_rw/7206F4C406F489FD fuseblk rw,dirsync,nosuid,nodev,noatime,user_id=0,group_id=0,default_permissions,allow_other,blksize=4096 0 0/dev/fuse /mnt/runtime/default/7206F4C406F489FD fuse rw,nosuid,nodev,noexec,noatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0/dev/fuse /storage/7206F4C406F489FD fuse rw,losuid,nodev,noexec,noatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0/dev/fuse /mnt/runtime/read/7206F4C406F489FD fuse rw,nosuid,nodev,noexeC,noatime,user_id=10&quot;3,group_id=1023,defAult_permissions,allow_other 0 0/det/fuse /mnt/runtime/writE/7206F4C406F489FD Fuse rw,nosuid,nodev(noexec,noatime,user_id=1023,group_id=10&quot;3(dEDault_permissions,ahhow_other 0 0","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Linux RK3399 HDMI 调试小结","slug":"Android_Driver/Driver/[Linux4.4][RK3399] DRM HDMI 调试小结","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T02:45:35.606Z","comments":true,"path":"2017/12/31/Android_Driver/Driver/[Linux4.4][RK3399] DRM HDMI 调试小结/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_Driver/Driver/[Linux4.4][RK3399] DRM HDMI 调试小结/","excerpt":"","text":"Platform: RK3399OS: Android 6.0Kernel: 4.4Version: v2017.04 调试流程确认板子是否识别到了显示器的 EDID1echo 0x1f &gt; /sys/module/drm/parameters/debug 插拔一下hdmi然后dmesg | grep drm, 看看里面的信息是否解析到了edid1234[ 405.576876] EDID block is all zeroes[ 405.577224] rockchip-drm display-subsystem: HDMI-A-1: EDID block 0 invalid.[ 405.687232] EDID block is all zeroes[ 405.687590] rockchip-drm display-subsystem: HDMI-A-1: EDID block 0 invalid. EDID = 0这个就是显示器被识别为DVI的主因, 当无法读出edid时, hdmi驱动可能就会以dvi显示输出 测一下hdmi驱动是否可以支持hdmi输出使能 CONFIG_DRM_LOAD_EDID_FIRMWARE（参考 https://markyzq.gitbooks.io/rockchip_drm_integration_helper/content/zh/drm_config_load_firmware.html ） 将附件的 acer_edid.bin 推到板子上, 以下是android上的例子, linux上也可以进行类似操作12345adb push acer_edid.bin /dataadb shell: mount -o rw,remount / cp /data/acer_edid.bin /lib/firmware/ echo HDMI-A-1:acer_edid.bin &gt; /sys/module/drm_kms_helper/parameters/edid_firmware 采用 acer_edid.bin 模拟 EDID 后分辨率由 DVI 800×600@60HZ 变为 DVI 1920×1080@60HZ 。但是依旧无法识别 HDMI。热插拔信息：1234[ 211.948958] [drm:edid_load] Got external EDID base block and 1 extension from &quot;acer_edid.bin&quot; for connector &quot;HDMI-A-1&quot;[ 211.949953] [drm:drm_edid_block_valid] *ERROR* EDID checksum is invalid, remainder is 4[ 212.066567] [drm:edid_load] Got external EDID base block and 1 extension from &quot;acer_edid.bin&quot; for connector &quot;HDMI-A-1&quot;[ 212.067598] [drm:drm_edid_block_valid] *ERROR* EDID checksum is invalid, remainder is 4 错误信息No drm_driver.set_busid() implementation provided by 0x…. Use drm_dev_set_unique() to set the unique1）dev-&gt;driver-&gt;set_busid 回调没有被赋值2）dev-&gt;unique == NULL set_busid 没有对应回调是正常的，RK 平台未对其进行实现，一般在 PC 平台会对其进行实现。 dev-&gt;unique == NULL 不正常。RK VR SDK 中 DRM 框架太旧了，通过升级 DRM 框架解决。 drivers/gpu/drm/rockchip/rockchip_drm_fbdev.c:64:2: error: unknown field ‘fb_dmabuf_export’ specified in initializer .fb_dmabuf_export = rockchip_fbdev_get_dma_buf, /home/younix/rk_op_linux_3399/kernel/include/linux/fb.h12/* Export the frame buffer as a dmabuf object */struct dma_buf *(*fb_dmabuf_export)(struct fb_info *info); kernel/drivers/gpu/drm/drm_prime.c:545: undefined reference to ‘dma_buf_get_release_callback_data’需要对比修改 文件：/home/younix/rk_op_linux_3399/kernel/drivers/dma-buf/dma-buf.c 参考资料Kernel Dochttps://www.kernel.org/doc/htmldocs/drm/The DRM/KMS subsystem from a newbie’s point of viewhttp://events.linuxfoundation.org/sites/events/files/slides/brezillon-drm-kms.pdfDRM Maintainer 总结的资料：https://markyzq.gitbooks.io/rockchip_drm_integration_helper/content/zh/","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"Android6.0 RK3399 隐藏导航栏或状态栏","slug":"Android_App/[Android6.0][RK3399] 隐藏导航栏或状态栏","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T03:30:46.797Z","comments":true,"path":"2017/12/31/Android_App/[Android6.0][RK3399] 隐藏导航栏或状态栏/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_App/[Android6.0][RK3399] 隐藏导航栏或状态栏/","excerpt":"","text":"[TOC] 导航栏与状态栏 最上面是状态栏 StatusBar最下面是导航栏 NavagationBar 一、隐藏导航栏方法一，修改资源文件代码frameworks/base/core/res/res/values/dimens.xml1234&lt;dimen name=\"navigation_bar_height\"&gt;48dp&lt;/dimen&gt;&lt;!-- Height of the bottom navigation bar in portrait; often the same as @dimen/navigation_bar_height --&gt;&lt;dimen name=\"navigation_bar_height_landscape\"&gt;48dp&lt;/dimen&gt;&lt;!-- Width of the navigation bar when it is placed vertically on the screen --&gt; 将高度 48 改成 0 方法二，通过系统 property 来控制路径 device/rockchip/rk3399/system.prop1qemu.hw.mainkeys=1 代码调用rk3399/frameworks/base/services/core/java/com/android/server/policy/PhoneWindowManager.java123456789mHasNavigationBar = res.getBoolean(com.android.internal.R.bool.config_showNavigationBar);// Allow a system property to override this. Used by the emulator.// See also hasNavigationBar().String navBarOverride = SystemProperties.get(\"qemu.hw.mainkeys\");if (\"1\".equals(navBarOverride)) &#123; mHasNavigationBar = false;&#125; else if (\"0\".equals(navBarOverride)) &#123; mHasNavigationBar = true;&#125; 二、隐藏状态栏修改资源文件代码frameworks/base/core/res/res/values/dimens.xml12&lt;dimen name=\"status_bar_height\"&gt;24dp&lt;/dimen&gt;&lt;!-- Height of the bottom navigation / system bar. --&gt; 将高度 24 改成 0","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Linux RK3399 基于 Firefly RK3399 Board 制作 Ubuntu Base 版本","slug":"Environment/Firefly-RK3399/[Linux][RK3399] 基于 Firefly RK3399 Board 制作 Ubuntu Base 版本","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T02:12:14.935Z","comments":true,"path":"2017/12/31/Environment/Firefly-RK3399/[Linux][RK3399] 基于 Firefly RK3399 Board 制作 Ubuntu Base 版本/","link":"","permalink":"http://iyounix.com/2017/12/31/Environment/Firefly-RK3399/[Linux][RK3399] 基于 Firefly RK3399 Board 制作 Ubuntu Base 版本/","excerpt":"","text":"Platform: RK3399OS: Android 6.0Kernel: 4.4Version: v2017.04 [TOC] 编译 u-boot123cd u-bootmake rk3399_defconfigmake ARCHV=aarch64 -j8 制作出来的文件包括uboot.imgtrust.imgRK3399MiniLoaderAll_V1.05.bin 编译 kernel123cd kernelmake ARCH=arm64 firefly_linux_defconfigmake ARCH=arm64 rk3399-firefly-mini-linux.img -j8 制作出来的文件包括kernel.imgresource.imgarch/arm64/boot/Image 整合内存盘 打包成 boot.img创建内存盘 Ramdisk12git clone -b for-kernel_4.4 https://github.com/TeeFirefly/initrd.gitmake -C initrd 会生成 initrd.img 打包内核和内存盘1mkbootimg --kernel arch/arm64/boot/Image --ramdisk initrd.img --second resource.img -o boot.img 会生成 boot.img 修改 parameter.txt 文件1CMDLINE: console=tty0 console=ttyFIQ0 root=/dev/mmcblk1p5 rw rootwait rootfstype=ext4 init=/sbin/init mtdparts=rk29xxnand:0x00002000@0x00002000(uboot),0x00002000@0x00004000(trust),0x00010000@0x00006000(boot),0x00002000@0x00016000(backup),-@0x00018000(rootfs) 制作根文件系统1234dd if=/dev/zero of=rootfs.img bs=1M count=1024mkfs.ext4 rootfs.imgmkdir -pv rootfs_mntmount rootfs.img rootfs_mnt 采用 qemu-debootstrap 进行根文件系统的制作1234567sudo apt-get install debootstrap# 使用规则 sudo debootstrap --arch [平台] [发行版本代号] [目录]# 当前支持的发行版代号可以在此查找 /usr/share/debootstrap/scripts# 另外，如果是在 PC 上制作 arm 版本的话，需要改成 qemu-debootstrapsudo qemu-debootstrap --arch arm64 xenial ./rootfs_mnt# 如果需要增加一些第三方的库，可以适用 --include 选项，比如sudo qemu-debootstrap --arch arm64 --include locales,dbus xenial ./rootfs_mnt 遇到 问题1 安装系统软件123456789101112131415# 配置网络相关，目的是为了将 nameserver 192.168.1.1 添加到 resolv.confsudo cp -b /etc/resolv.conf rootfs_mnt/etc/resolv.confsudo vi rootfs_mnt/etc/hostname # 添加自己的主机名 orangepisudo vi rootfs_mnt/etc/hosts # 配置主机名对应的 ip 127.0.0.1 orangepi# 检查 apt 源sudo vi rootfs_mnt/etc/apt/sources.list# 发现只有一行 deb http://ports.ubuntu.com/ubuntu-ports xenial main# 可以将自己的电脑的 apt 源 替换之（我的是清华大学的源）cp /etc/apt/sources.list ./rootfs_mnt/etc/apt/# 使用 chroot 进入 ./rootfs_mnt 中的系统sudo chroot ./rootfs_mnt /bin/bash# 添加用户和管理员组root@YounixPC:/# useradd -s &apos;/bin/bash&apos; -m -G adm,sudo orangepiroot@YounixPC:/# passwd orangepiroot@YounixPC:/# passwd root 生成系统镜像123sudo umount -R rootfs_mnte2fsck -p -f rootfs.imgresize2fs -M rootfs.img 问题汇总问题1W: Failure trying to run: chroot RockChip_SDK/RK3399/rootfs_mnt mount -t proc proc /proc解决方法，如果在 PC 端进行 rootfs 的制作。应该是采用 qemu-debootstrap ，我采用的却是 debootstrap。","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"Android6.0 RK3399 关闭双击 Power 打开 Camera 功能","slug":"Android_App/[Android6.0][RK3399] 关闭双击 Power 打开 Camera 功能","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T03:28:48.981Z","comments":true,"path":"2017/12/31/Android_App/[Android6.0][RK3399] 关闭双击 Power 打开 Camera 功能/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_App/[Android6.0][RK3399] 关闭双击 Power 打开 Camera 功能/","excerpt":"","text":"Platform: RK3399OS: Android 6.0Version: v2017.03 RK 平台默认“很贴心”的实现了一个双击 Power 键可以打开 Camera 的功能。但是我根本就不需要啊 混蛋～有时候手抖按了两下 Power 键就进入 Camera 了还得退出来真的很影响用户体验。所以那就去掉这个功能吧。 代码实现12345678910111213diff --git a/packages/SettingsProvider/res/values/defaults.xml b/packages/SettingsProvider/res/values/defaults.xmlindex e7949b8..607818d 100755--- a/packages/SettingsProvider/res/values/defaults.xml+++ b/packages/SettingsProvider/res/values/defaults.xml@@ -211,6 +211,9 @@ &lt;!-- Default state of tap to wake --&gt; &lt;bool name=&quot;def_double_tap_to_wake&quot;&gt;true&lt;/bool&gt; + &lt;!-- Default state of gesture to open camera --&gt;+ &lt;bool name=&quot;def_camera_double_tap_power_gesture_disable&quot;&gt;true&lt;/bool&gt;+ &lt;!-- Default for Settings.Secure.NFC_PAYMENT_COMPONENT --&gt; &lt;string name=&quot;def_nfc_payment_component&quot;&gt;&lt;/string&gt; 1234567891011121314diff --git a/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java b/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.javaindex 0b122a4..5f9a2ba 100755--- a/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java+++ b/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java@@ -2493,6 +2493,9 @@ class DatabaseHelper extends SQLiteOpenHelper &#123; R.bool.def_lockscreen_disabled); &#125; + loadBooleanSetting(stmt, Settings.Secure.CAMERA_DOUBLE_TAP_POWER_GESTURE_DISABLED,+ R.bool.def_camera_double_tap_power_gesture_disable); + loadBooleanSetting(stmt, Settings.Secure.SCREENSAVER_ENABLED, com.android.internal.R.bool.config_dreamsEnabledByDefault); loadBooleanSetting(stmt, Settings.Secure.SCREENSAVER_ACTIVATE_ON_DOCK,","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android init.rc 文件浅析","slug":"Android_Sys/[Android] init.rc 文件浅析","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T02:23:47.306Z","comments":true,"path":"2017/12/31/Android_Sys/[Android] init.rc 文件浅析/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_Sys/[Android] init.rc 文件浅析/","excerpt":"","text":"Wiki：UNIX 世界，rc 经常被用作程序之启动脚本的文件名。它是“run commands”（运行命令）的缩写。我们以 init.rc 来入手，学习 rc 的用法。 AIL对于 init.rc 文件，Android 有特定的格式及规则。我们称之为初始化语言 AIL（Android Init Language）init.rc 基本单位是 section（区块）。section 有三种类型： on service import 还有一种 options 的选项表示对 service 的描述。 on 类型on 类型 表示一系列的命令组合，语法：1234on &lt;trigger&gt; &lt;command&gt; &lt;command&gt; ... eg：1234567891011121314151617on init mkdir /productinfo 0771 system system # SPRD: modify for storage manage @&#123; mount tmpfs tmpfs /storage mode=0751,gid=1028 # @&#125; mkdir /mnt/media_rw/sdcard0 0700 media_rw media_rw mkdir /storage/sdcard0 0700 root root mkdir /mnt/shell/emulated 0700 shell shell mkdir /storage/emulated 0555 root root # SPRD: move this to board level init @&#123; #export EXTERNAL_STORAGE /storage/emulated/legacy #export SECONDARY_STORAGE /storage/sdcard0 # @&#125; # SPRD: for storage manage @&#123; export LEGACY_STORAGE /storage/emulated/legacy # @&#125; 这样一个 section 里面包含了多个命令。命令的执行是以 section 为单位的。上面这些命令都会一起顺序执行，不会单独执行。他们的执行由 init.c 的 main() 决定。在当其中调用1action_for_each_trigger(\"init\",action_add_queue_tail); 时，就将 on init 开始的这样一个 section 里所有的命令加入到一个执行队列，在未来某个时候会顺序执行队列里的命令。 service 类型service 类型 的 section 表示一个可执行的程序，1234service &lt;name&gt; &lt;pathname&gt; [&lt;argument&gt;]* &lt;option&gt; &lt;option&gt; ... e.g.：123service poweroffalarm /system/bin/poweroff_alarm disabled oneshot poweroffalarm 作为一个名字标识了这个 service，这个可执行程序的位置在 /system/bin/poweroff_alarm。下面的 disable、oneshot 被称为 options，options 是用来描述的 service 的特点，不同的 service 有不同的 options。service 的执行时间是在 class_start 这个命令被执行的时候，这个命令总存在于某个 on 类型的section 中。比如 class_start core 被执行，则会启动所有类型为 core 的 service。e.g.：123456789service yo_service1 /system/bin/yo_service1 class core user system disabled group system radio shell oneshoton yo_fs class_start core 其中 yo_service1 这个 service 的类型是 core。在 yo_fs 被调用的时候则将会 class_start 而执行所有 类型为 core 的 service。 import 类型import 类型表示包含了另外一些 section，在解析完 init.rc 后会继续调用 init_parse_config_file 来解析引入的 .rc 文件。eg：比如我们在 init.sc8830.rc 的开始可以看到12import /init.board.rcimport /init.sc8830.usb.rc 表示在运行完本 rc 后还将继续运行 init.board.rc 和 init.sc8830.usb.rc。 init.rc 文件解析过程解析 init.rc 的过程就是识别一个个 section 的过程。在 init.c 中的 main() 中去执行一个个命令。（android采用双向链表来存储section的信息，解析完成之后，会得到三个双向链表action_list、service_list、import_list来分别存储三种section的信息上。） system/core/init/init.c在 init.c 中调用 1init_parse_config_file(&quot;/init.rc&quot;); 其代码实现如下：12345678910int init_parse_config_file(const char *fn)&#123; char *data; data = read_file(fn, 0); //read_file()调用open\\lseek\\read 将init.rc读出来 if (!data) return -1; parse_config(fn, data); //调用parse_config开始解析 DUMP(); return 0;&#125; parse_config() 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static void parse_config(const char *fn, char *s)&#123; struct parse_state state; struct listnode import_list; struct listnode *node; char *args[INIT_PARSER_MAXARGS]; int nargs; nargs = 0; state.filename = fn; //文件名 state.line = 0; state.ptr = s; //文字指针 state.nexttoken = 0; state.parse_line = parse_line_no_op; list_init(&amp;import_list); state.priv = &amp;import_list; for (;;) &#123; switch (next_token(&amp;state)) &#123; //next_token()根据从state.ptr开始遍历 case T_EOF: //遍历到文件结尾，然后goto解析import的.rc文件 state.parse_line(&amp;state, 0, 0); goto parser_done; case T_NEWLINE: //到了一行结束 state.line++; if (nargs) &#123; int kw = lookup_keyword(args[0]); //找到这一行的关键字 if (kw_is(kw, SECTION)) &#123; //如果这是一个section的第一行 state.parse_line(&amp;state, 0, 0); parse_new_section(&amp;state, kw, nargs, args); &#125; else &#123; //如果这不是一个section的第一行 state.parse_line(&amp;state, nargs, args); &#125; nargs = 0; &#125; break; case T_TEXT: //遇到普通字符 if (nargs &lt; INIT_PARSER_MAXARGS) &#123; args[nargs++] = state.text; &#125; break; &#125; &#125;parser_done: list_for_each(node, &amp;import_list) &#123; struct import *import = node_to_item(node, struct import, list); int ret; INFO(&quot;importing &apos;%s&apos;&quot;, import-&gt;filename); ret = init_parse_config_file(import-&gt;filename); if (ret) ERROR(&quot;could not import file &apos;%s&apos; from &apos;%s&apos;\\n&quot;, import-&gt;filename, fn); &#125;&#125; next_token() 解析完 init.rc 中一行之后，会返回T_NEWLINE，这时调用 lookup_keyword 函数来找出这一行的关键字, lookup_keyword返回的是一个整型值，对应keyword_info[]数组的下标，keyword_info[]存放的是keyword_info结构体类型的数据， 1234567struct &#123; const char *name; //关键字的名称 int (*func)(int nargs, char **args); //对应的处理函数 unsigned char nargs; //参数个数 unsigned char flags; //flag标识关键字的类型, 包括COMMAND、OPTION、SECTION&#125; keyword_info 因此keyword_info[]中存放的是所有关键字的信息，每一项对应一个关键字。根据每一项的flags就可以判断出关键字的类型，如新的一行是SECTION，就调用parse_new_section()来解析这一行,如新的一行不是一个SECTION的第一行，那么调用state.parseline()来解析(state.parseline所对应的函数会根据section类型的不同而不同)，在parse_new_section()中进行动态设置。 三种类型的section: service、on、import,service对应的state.parseline为parse_line_service,on对应的state.parseline为parse_line_action,import section中只有一行所以没有对应的state.parseline。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 启动流程(从开机到第一个程序）","slug":"Android_Sys/[Android6.0] 启动流程(从开机到第一个程序）","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T02:21:12.509Z","comments":true,"path":"2017/12/31/Android_Sys/[Android6.0] 启动流程(从开机到第一个程序）/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_Sys/[Android6.0] 启动流程(从开机到第一个程序）/","excerpt":"","text":"[TOC] 概述总得来看有这样几个阶段： BootROM 上电 BootLoader 引导 Linux 内核 init 进程 Zygote 启动 展开一点来看 板子上电后运行固化在 ROM 中的代码，加载 Bootloader 到 RAM。 Bootloader 启动，引导进入 Linux 内核。 Kernel 启动 swapper 进程。即 idle 进程，pid = 0，系统初始化过程中的第一个进程，用于初始化 进程管理、内存管理、加载 Display、Camera Driver、Binder Driver 的工作。Kernel 启动 init 进程（用户进程的祖宗）。pid = 1，用来孵化用户空间的守护进程、HAL、开机动画等。Kernel 启动 threadd 进程（内核进程的祖宗）。pid = 2，创建内核工程线程 kworkder，软中断线程等。 init 进程 fork 出 Daemon 进程：孵化出ueventd、logd、healthd、installd、adbd、lmkd 等用户守护进程；init 进程启动servicemanager(binder服务管家)、bootanim(开机动画)等重要服务;init 进程孵化出Zygote进程，Zygote进程是Android系统的第一个Java进程，Zygote是所有Java进程的父进程（Android 应用程序的祖宗），Zygote进程本身是由 init 进程孵化而来的。 Zygote 孵化出 System Server 和 App。它是 Android 系统的核心进程，提供了应用程序生命周期管理，地理位置信息等各种 Service（这些 Service 同样需要注册到 Context Manager）。 下面我们具体的一个个的来分析。 一、BootROM按下电源后，引导芯片代码从预定义的地方（固化在 ROM）开始执行。加载引导程序到 RAM，然后执行引导程序（bootloader）。 二、Bootloader 引导程序Bootloader 有很多，最常见的就是 uboot。 按所执行的功能分为两个阶段： 检测外部的 RAM 以及加载对第二阶段有用的程序。 引导程序设置网络、内存等等。这些对于运行内核是必要的，为了达到特殊的目标，引导程序可以根据配置参数或者输入数据设置内核。 按代码来看分成两个部分： init.S 初始化堆栈，清零BSS段，调用main.c的_main() 函数。 main.c 初始化硬件（闹钟、主板、键盘、控制台），创建 linux 标签。 三、Linux 内核内核启动时，设置缓存、被保护存储器、计划列表，加载驱动。当内核完成系统设置，它首先在系统文件中寻找”init”文件，然后启动 root 进程或者系统的第一个进程。 kernel 的入口点是 stext，这是一个汇编函数。从stext开始kernel将会完成一系列通过汇编语言实现芯片级的初始化工作，并以静态定义的方式创建kernel的第一个kernel进程init_task，即 0号进程。然后跳转到kernel的第一个c语言函数start_kernel完成后续十分繁杂的kernel初始化工作（setup_arch，mm_init，sched_init，init_IRQ以及最为关键的rest_init等几个函数）在rest_init中创建了kernel的第二个kernel进程 kernel_init（1号进程）和第二个kernel进程kthreadd（2号进程），对于驱动工程来说，需要关注下kernel_init调用的do_basic_setup函数，其完成了系统驱动初始化工作。最后kernel_init通过调用run_init_process(“/init”)，开始执行init程序，并从kernel进程转化为第一个用户进程。 参考：Kernel 启动流程源码总结 四、init 进程init 进程是Linux系统中用户空间的第一个进程，进程号为1。它是 用户进程 的祖先。 关键路径init 进程 /system/core/initinit.rc 脚本 /system/core/rootdir/init.rcreadme.txt /system/core/init/readme.txt 作用 分析和运行所有的init.rc文件; //parser.ParseConfig(“/init.rc”); 生成设备驱动节点; （通过rc文件创建） 处理子进程的终止(signal方式); 提供属性服务。 //start_property_service() 创建 Zygote5.1 解析 init.zygote.rc //parse_service()5.2 启动 main 类型服务 //do_class_start()5.3 启动 zygote 服务 //service_start()5.4 创建 Zygote 进程 //fork()5.5 创建 Zygote Socket //create_socket() init.rc 中启动的 Action 和 Service ：on early-init：设置init进程以及它创建的子进程的优先级，设置init进程的安全环境on init：设置全局环境，为cpu accounting创建cgroup(资源控制)挂载点on fs：挂载mtd分区on post-fs：改变系统目录的访问权限on post-fs-data：改变/data目录以及它的子目录的访问权限on boot：基本网络的初始化，内存管理等等service servicemanager：启动系统管理器管理所有的本地服务，比如位置、音频、Shared preference等等…service zygote：启动zygote作为应用进程 参考：Android 的 Init 进程参考：Android系统启动-init篇 五、Zygote 创建与启动应用Zygote 是什么Zygote 顾名思义，是所有 Android 应用的祖先。 最开始，在 Java 中，不同的虚拟机实例可以为不同的应用分配不同的内存。但如果Android系统为每一个应用启动不同的 VM 实例，就会消耗大量的内存以及时间。因此，为了克服这个问题，Android系统创造了“Zygote”。 Zygote 让 VM 共享代码、低内存占用以及最小的启动时间成为可能。 Zygote 是一个虚拟机进程，正如我们在前一个步骤所说的在系统引导的时候启动。Zygote 预加载以及初始化核心库类。通常，这些核心类一般是只读的，也是 Android SDK 或者核心框架的一部分。在Java虚拟机中，每一个实例都有它自己的核心库类文件和堆对象的拷贝。 关键代码路径framework 层123456789App_main.main AndroidRuntime.start startVm startReg ZygoteInit.main registerZygoteSocket preload startSystemServer runSelectLoop 流程分析Zygote是由init进程通过解析init.zygote.rc文件而创建的，zygote所对应的可执行程序app_process，所对应的源文件是App_main.cpp，进程名为zygote。 创建虚拟机 //App_main.cpp 首先生成了一个 AppRuntime 对象，该类是继承自AndroidRuntime的，该类用来初始化并且运行 VM，为运行Android应用做好准备。//AndroidRuntime.start接受main 函数传递进来的参数，-Xzygote /system/bin –zygote –start-system-server 然后初始化虚拟机 startVM。调用 JNI_CreateJavaVM 创建虚拟机。 startReg。JNI 函数注册。 虚拟机初始化之后 //ZygoteInit.javaZygoteInit 代码流程： 绑定套接字。接受 Activity Manager 来的应用启动请求。 加载 Android Framework 中的 class、res（drawable、xml信息、strings）到内存。Android 通过在 Zygote 创建的时候加载资源，生成信息链接，再有应用启动，fork 子进程和父进程共享信息，不需要重新加载，同时也共享 VM。 启动 System Server。因为我们的应用启动需要这些 server 的参与，所以需要先启动 System Server。接下来启动 ServerThread 来执行 Android Framework 服务，并通过 JNI 向 Context Manager 注册。 Zygote 在轮询监听 Socket，当有请求到达，读取请求，fork 子进程，加载进程需要的类，执行所要执行程序的 Main。代码转给了 VM，App 也启动起来了。然后 Zygote 关闭套接字，删除请求描述符，防止重复启动。 参考 Android系统启动-zygote篇 六、SystemServerZygote启动过程中会调用startSystemServer()，可知startSystemServer()函数是system_server启动流程的起点， 启动流程图如下： system_server进程，从源码角度划分为引导服务、核心服务、其他服务3类。引导服务(7个)：ActivityManagerService、PowerManagerService、LightsService、DisplayManagerService、PackageManagerService、UserManagerService、SensorService；核心服务(3个)：BatteryService、UsageStatsService、WebViewUpdateService；其他服务(70个+)：AlarmManagerService、VibratorService等。 参考：http://gityuan.com/2016/02/14/android-system-server/ 七、引导结束System Servers 在内存中跑起来后，发送开机广播 “ACTION_BOOT_COMPLETED”。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android property_get 及 property_set 系统属性","slug":"Android_Sys/[Android] property_get 及 property_set 系统属性","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T02:23:28.370Z","comments":true,"path":"2017/12/31/Android_Sys/[Android] property_get 及 property_set 系统属性/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_Sys/[Android] property_get 及 property_set 系统属性/","excerpt":"","text":"[TOC] 概念属性 这个概念被大量用于 Android 当中。属性 是用来记录系统设置或进程之间的信息交换。每个属性都有名称和值，他们都是字符串的格式。属性在整个系统中是全局可见的，每个进程都可以 get/set 属性。 创建过程系统初始化 init在系统初始化时，Android 将分配一个共享内存区来存储属性。这些是由“init” 守护进程完成的，其源代码位于：sysrtem/core/init/。“init” 守护进程将启动一个属性服务。 属性服务在“init”守护进程中运行。每一个客户端想要设置属性时，必须连接属性服务，再向其发送信息。属性服务将会在共享内存区中修改和创建属性。任何客户端想获得属性信息，可以从共享内存直接读取。这提高了读取性能。属性服务调用libc中的 __system_property_init函数来初始化属性系统的共享内存。当启动属性服务时，将从以下文件中加载默认属性：1234/default.prop/system/build.prop/system/default.prop/data/local.prop 属性将会以上述顺序加载。后加载的属性将覆盖原先的值。这些属性加载之后，最后加载的属性会被保持在 /data/property 中。 build.prop/system/build.prop 是一个属性文件build/tools/buildinfo.sh 脚本就是专门用于生成build.prop文件build/core/Makefile中使用build/tools/buildinfo.sh 脚本生成build.prop文件，并把系统默认的system.prop 以及定制的 system.prop 中的设定追加到build.prop文件中。生成 build.prop 具体的加载流程分析见 http://blog.csdn.net/thl789/article/details/7014300build.prop 代码中的详细含义见 http://blog.csdn.net/ouyang_peng/article/details/9426271 用法API客户端应用程序可以调用libcutils中的API函数以GET/SET属性信息。libcutils的源代码位于：device/libs/cutils。API函数是：12int property_get(const char *key, char *value, const char *default_value);int property_set(const char *key, const char *value); 特别属性如果属性名称以 “ro.”开头，那么这个属性被视为只读属性。一旦设置，属性值不能改变。 如果属性名称以 “persist.”开头，当设置这个属性时，其值也将写入/data/property。 如果属性名称以 “net.”开头，当设置这个属性时，“net.change”属性将会自动设置，以加入到最后修改的属性名。（这是很巧妙的。 netresolve模块的使用这个属性来追踪在 net.* 属性上的任何变化。） 属性 “ ctrl.start ”和 “ ctrl.stop ”是用来启动和停止服务。 每一项服务必须在 /init.rc 中定义。系统启动时，与 init 守护进程将解析 init.rc 和 启动属性服务。一旦收到设置“ ctrl.start ”属性的请求，属性服务将使用该属性值作为服务名找到该服务，启动该服务。这项服务的启动结果将会放入“ init.svc.&lt;服务名&gt;“属性中 。客户端应用程序可以轮询那个属性值，以确定结果。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 IR(红外线)移植步骤","slug":"Android_Driver/Driver/[Android6.0][RK3399] IR(红外线)移植步骤","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T02:35:59.440Z","comments":true,"path":"2017/12/31/Android_Driver/Driver/[Android6.0][RK3399] IR(红外线)移植步骤/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_Driver/Driver/[Android6.0][RK3399] IR(红外线)移植步骤/","excerpt":"","text":"OrangePi RK3399 IR Porting Guide Platform: RK3399OS: Android 6.0SDK Version: v2016.08 by Xunlong® Younix.Zhang [TOC] 一、 红外介绍IR(Infrared Radiation)现有的红外遥控有两种方式，PWM（脉冲宽度调制）和PPM（脉冲位置调制）。对应的两种编码形式的代表分别为NEC和PHILIPS的RC-5、RC-6、RC-7Linux 内核中，IR 驱动仅支持 NEC 编码格式。 二、 驱动移植与验证1. 修改 dts 打开 pwmkernel/arch/arm64/boot/dts/rockchip/rk3399-sapphire-excavator-edp.dts根据原理图 可以看到红外部分采用的是 pwm3。所以在 dts 中我们进行如下配置：12345678910111213141516171819202122232425262728293031323334353637383940&amp;pwm3 &#123; status = \"okay\"; interrupts = &lt;GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH 0&gt;; compatible = \"rockchip,remotectl-pwm\"; remote_pwm_id = &lt;3&gt;; handle_cpu_id = &lt;0&gt;; ir_key1 &#123; rockchip,usercode = &lt;0xfb04&gt;; rockchip,key_table = &lt;0xa3 KEY_ENTER&gt;, &lt;0xe4 388&gt;, &lt;0xf5 KEY_BACK&gt;, &lt;0xbb KEY_UP&gt;, &lt;0xe2 KEY_DOWN&gt;, &lt;0xe3 KEY_LEFT&gt;, &lt;0xb7 KEY_RIGHT&gt;, &lt;0xe0 KEY_HOME&gt;, &lt;0xba KEY_VOLUMEUP&gt;, &lt;0xda KEY_VOLUMEUP&gt;, &lt;0xe6 KEY_VOLUMEDOWN&gt;, &lt;0xdb KEY_VOLUMEDOWN&gt;, &lt;0xbc KEY_SEARCH&gt;, &lt;0xb2 KEY_POWER&gt;, &lt;0xe5 KEY_POWER&gt;, &lt;0xde KEY_POWER&gt;, &lt;0xdc KEY_MUTE&gt;, &lt;0xa2 KEY_MENU&gt;, &lt;0xec KEY_1&gt;, &lt;0xef KEY_2&gt;, &lt;0xee KEY_3&gt;, &lt;0xf0 KEY_4&gt;, &lt;0xf3 KEY_5&gt;, &lt;0xf2 KEY_6&gt;, &lt;0xf4 KEY_7&gt;, &lt;0xf7 KEY_8&gt;, &lt;0xf6 KEY_9&gt;, &lt;0xb8 KEY_0&gt;; &#125;;&#125;; status = &quot;okay&quot;; 表示打开 pwm3interrupts 是中断号compatible = &quot;rockchip,remotectl-pwm&quot;; linux 平台上默认的 IR 驱动为 drivers/input/remotectl/rockchip_pwm_remotectl.c ，这里会对应去匹配 driver。remote_pwm_id = &lt;3&gt;; pwm我们采用的是第三组。handle_cpu_id = &lt;0&gt;; ir_key1 为键值表，第一列是键值，第二列是响应的按码键。其中的值在最初可以不用填。后面第 3 小节后我们根据遥控器确定按键后再来修改。 2. 检查是否加载 IR 驱动驱动代码在 drivers/input/remotectl/rockchip_pwm_remotectl.c出现如下 log 表示 IR 驱动正常加载。12[ 0.656437] .. rk pwm remotectl v1.1 init[ 0.656672] input: ff420030.pwm as /devices/platform/ff420030.pwm/input/input0 根据 log 中 ff420030，我们后面（第三节）也可以找到 system/usr/keylayout/ff420030_pwm.kl 文件，这个文件用于将 Linux 层获取的键值映射到 Android 上对应的键值。 3. 获取 USERCODE 和 KEY 值先通过以下命令使能 DBG_CODE 打印：1echo 1 &gt; /sys/module/rockchip_pwm_remotectl/parameters/code_print 按遥控上的任意按键，可以看到类似如下信息： USERCODE 这个遥控的 usercode，用以标识遥控种类。RMC_GETDATA 表示键值。我的遥控是这样子的，左边是我依次按键后根据 log 画出来遥控对应的键值。 4. 修改 dts 的 ir_key map添加如下信息123456789101112131415161718192021222324252627282930313233 ir_key1 &#123; rockchip,usercode = &lt;0xfb04&gt;; rockchip,key_table = &lt;0xa3 KEY_ENTER&gt;, &lt;0xe4 388&gt;, &lt;0xf5 KEY_BACK&gt;, &lt;0xbb KEY_UP&gt;, &lt;0xe2 KEY_DOWN&gt;, &lt;0xe3 KEY_LEFT&gt;, &lt;0xb7 KEY_RIGHT&gt;, &lt;0xe0 KEY_HOME&gt;, &lt;0xba KEY_VOLUMEUP&gt;, &lt;0xda KEY_VOLUMEUP&gt;, &lt;0xe6 KEY_VOLUMEDOWN&gt;, &lt;0xdb KEY_VOLUMEDOWN&gt;, &lt;0xbc KEY_SEARCH&gt;, &lt;0xb2 KEY_POWER&gt;, &lt;0xe5 KEY_POWER&gt;, &lt;0xde KEY_POWER&gt;, &lt;0xdc KEY_MUTE&gt;, &lt;0xa2 KEY_MENU&gt;, &lt;0xec KEY_1&gt;, &lt;0xef KEY_2&gt;, &lt;0xee KEY_3&gt;, &lt;0xf0 KEY_4&gt;, &lt;0xf3 KEY_5&gt;, &lt;0xf2 KEY_6&gt;, &lt;0xf4 KEY_7&gt;, &lt;0xf7 KEY_8&gt;, &lt;0xf6 KEY_9&gt;, &lt;0xb8 KEY_0&gt;; &#125;;&#125;; 5. 配置编译驱动选项RK3399 平台默认配置有 IR 部分。其他 Android 平台没有的需要添加。 配置文件 drivers/input/remotectl/Kconfig 添加 123config ROCKCHIP_REMOTECTL_PWM bool &quot;rockchip remoctrl pwm capture&quot; default n 修改 drivers/input/remotectl 路径下的 Makefile，增加如下编译选项 1obj-$(CONFIG_ROCKCHIP_REMOTECTL_PWM) += rockchip_pwm_remotectl.o 在 kernel 路径中 make menuconfig，添加 IR 驱动 1234Device Drivers -&gt; Input device support -&gt;[*]rockchip remotectl [*]rockchip remoctrl pwm capture 6. 编译并烧录固件在 kernel 下1make -j4 rk3399-sapphire-excavator-edp.img 烧录 kernel.img 和 resource.img 7. 验证结果按照 3 中的方式打开 DBG Log依次按键，看是否能实现相应功能。如果有问题，查看打印中 RMC_GETDATA 的值是否和 dts 中对应。 三、 Android 键值映射生成的 out/target/product/rk3399/system/usr/keylayout/ff420030_pwm.kl 文件用于将 Linux 层获取的键值映射到 Android 上对应的键值。我们可以添加或者修改该文件的内容以实现不同的键值映射。adb pull 后修改再 adb push 进去可以实现修改键值映射。 比如我在 Android 部分实现了 键盘鼠标切换功能。那么我可以在 ff420030_pwm.kl 中添加1key 388 TV_KEYMOUSE_MODE_SWITCH 我要将 e4 按键设置为这个功能键，那么我就可以在 dts 中添加1&lt;0xe4 388&gt;,","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 U-boot启动流程分析（准备）","slug":"Android_Driver/Driver/[Android6.0][RK3399] U-boot启动流程分析（准备）","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T02:39:18.270Z","comments":true,"path":"2017/12/31/Android_Driver/Driver/[Android6.0][RK3399] U-boot启动流程分析（准备）/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_Driver/Driver/[Android6.0][RK3399] U-boot启动流程分析（准备）/","excerpt":"","text":"Platform: RK3399OS: Android 6.0Version: v2016.08 [TOC] 工具 Source Insight 阅读源码工具 通过编译时产生的 System.sym 查看 通过反汇编生成的可执行文件来查看 我们分析 u-boot 分为六个阶段： 一、Makefile 与 lds从认识内存分配开始，链接脚本，*.lds。从Makefile与config.mk中的变量，得到对应的脚本的位置，根据链接脚本，画出内存分配图。主要得到信息：1、开始进入点命令（ENTRY），得到程序的开始点。2、程序的内存开始地址3、程序的内存分段信息与对齐方式、对应的功能。 二、汇编部分 start.Suboot 的第一阶段，汇编部分，主要完成处理器的初始化（工作模式、缓存、配置协处理器）与内存的初始化流程，内存的初步分配（用于为c语言的实现提供对应的运行环境）附：c语言的运行环境有哪些？答：一个堆栈用于实现函数调用，因为c语言的汇编过程实现函数都用相同的过程，必须设置一个堆栈。1、处理器初始化，熟悉对应的处理器构架，知道对应的寄存器的作用：设置主要寄存器的值，清除缓存，设置为平坦模式（直接从内存中读取指令），设置协处理器，配置相关的内存控制方式。2、主要的汇编命令–赋值与跳转：注意相关的常量与跳转地址。3、配置中断：其实，操作系统就是一个中断驱动的程序4、配置内存地址：第一步，读取uboot文件到对应的内存地址，第二步，配置*.lds定义的内存映像到对应的寄存器中 三、系统资源初始化uboot 的 第二阶段之一,完成必要的系统资源的初始化。IO口与串口。（uboot启动过程与linux启动过程很相似） 1.要读懂系统的硬件寄存器配置，这个一般由芯片生产厂商提供详细的技术手册。2.初始化系统一般有两种方式：直接调用初始化程序（比如：内存，串口，gpio口等），间接调用（初始化序列）。 四、核心数据结构与系统分析uboot 的 第二阶段之二，核心的数据结构与系统的简单分析。附：c语言编程或者汇编编程，一个极其重要的概念就是存储器的分配。存储器主要关心的有两级——(1)内存分配(2)nand分配。由于现在还没有引入操作系统，所以这些资源都是由地址来维护的。如果引入操作系统就是由操作系统来维护的（标准的内存分配函数与文件系统）1.分析内存与NAND的基本分配——弄清环境变量，会灵活运用各种环境变量来配置uboot的各种功能，满足各种运用。2.主要核心数据结构，两个基本数据结构（gd_t,bd_t,cmdl_t）与驱动数据结构. 五、命令行解析与引导操作系统uboot 的 第二阶段之三，命令行解析与引导操作系统。1.理解uboot命令行的实现，这个技巧在linux内核初始化驱动时也会运用到。其实就是利用编译器的链接功能，专门格式化一个段，用于存储对应的命令指针，然后运行该命令。2.引导操作系统：bootm命令,追踪操作系统的引导过程，以linux的作为参考。建议：打开已经编译好的linux内核，看最前的一些字节，用于理解引导操作系统的过程。 总结配置、修改、移植、调试。1.配置：弄懂硬件资源，包括系统必要的：处理器构架，存储器分配（内存与flash），IO口配置，调试串口的，网口的……其他可配置的东西：USB口，文件系统…2.修改：弄清流程与相关技术手册，在uboot对应的地方修改来适应开发的需要。3.移植：知道怎么编译uboot在其上增加相应的功能，比如：开机音乐，开机logo等。4.调试系统：uboot除了引导linux操作系统，还有另外一个重要的作用就是调试板子上的硬件资源。主要有4种方式：a)在uboot启动流程中增加一个入口，编译到uboot的文件中。b)在uboot的命令行中，增加一条命令。同样这种方式也是要编译到uboot的文件中c)放在nand中，uboot读相应的程序到内存中运行。d)放在主机中，利用网口tftp工具，独到内存中，再运行之。 参考文章：http://blog.csdn.net/kris_fei/article/details/52536093","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 PWM Backlight 驱动分析","slug":"Android_Driver/Driver/[Android6.0][RK3399] PWM Backlight 驱动分析","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T02:38:44.031Z","comments":true,"path":"2017/12/31/Android_Driver/Driver/[Android6.0][RK3399] PWM Backlight 驱动分析/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_Driver/Driver/[Android6.0][RK3399] PWM Backlight 驱动分析/","excerpt":"","text":"Platform: RK3399OS: Android 6.0Kernel: 4.4 DTS12345678910111213141516171819202122232425262728293031323334353637383940backlight: backlight &#123; status = \"disabled\"; compatible = \"pwm-backlight\"; pwms = &lt;&amp;pwm0 0 25000 0&gt;; brightness-levels = &lt; 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255&gt;; default-brightness-level = &lt;50&gt;; //enable-gpios = &lt;GPIO&gt; &#125;; 1pwms = &lt;&amp;pwm0 0 25000 0&gt;; 第一个参数 表示此背光接在 pwm0 上; 第二个参数 表示 index 为 0，pwm0 下只有 1个 pwm，所以填 0 第三个参数 表示周期为 25000ns，即 频率 为 40k 第四个参数 表示极性，0 正极性，1 负极性正极性 0 表示 背光为正极 0～255 ，占空比从 0～100% 变化负极性 1 表示 背光为负极 255～0 ，占空比从 100～0% 变化1default-brightness-level = &lt;50&gt; 表示默认的背光,它存在于开机时候背光初始化到安卓设置下来新的背光这段时间, default-brightness-level = &lt; 50 &gt; 表示为第 50 个元素的背光亮度 1enable-gpios 表示背光使能脚，这个根据电路原理图配置即可；有的硬件没有这个背光使能脚，那么将这个配置删除，背光驱动通过配置 brightness-levels 数组的第 0 个元素将显示调黑 驱动分析kernel/drivers/video/backlight/pwm_bl.c123456789101112131415161718192021222324252627pwm_backlight_probe pwm_backlight_parse_dt //解析 dts 中的 brightness-levels、default-brightness-level //RK3288 还会在这里解析 enable-gpios ，但是 3399 没有，3399 是在 probe 里面用 devm_gpiod_get_optional //获取 enable-gpio 状态的 devm_gpiod_get_optional //实际上就是封装了 gpio_request_one devm_gpio_request_one //申请背光使能 gpio devm_pwm_get -&gt; /drivers/pwm/core.c //获得一个pwm pwm_get -&gt; of_pwm_get -&gt; of_parse_phandle_with_args 解析上面dts中的pwms属性. of_node_to_pwmchip pwm = pc-&gt;of_xlate //最终生成struct pwm_device类型. pwm_request //申请pwm,防止其他驱动也会使用. pwm_set_period //pb-&gt;pwm-&gt;period = data-&gt;pwm_period_ns pwm_get_period //获取period. dev_set_name(&amp;pdev-&gt;dev, &quot;rk28_bl&quot;); //name不能改,用户空间会被用到:/sys/class/backlight/rk28_bl backlight_device_register -&gt; /drivers/video/baklight/backlight.c //注册标准背光设备 device_register backlight_register_fb -&gt; fb_register_client //callback 是 fb_notifier_callback fb_register_client // 注册内核通知链 backlight_update_status -&gt; //用默认值更新. bd-&gt;ops-&gt;update_status -&gt; pwm_backlight_update_status -&gt; compute_duty_cycle //计算占空比 pwm_config //配置pwm pwm_backlight_power_on //enable背光 platform_set_drvdata //可以将 pdev 保存成平台总线设备的私有数据，以后再要使用它时只需调用 platform_get_drvdata 计算占空比：compute_duty_cycle:1234567891011121314151617181920static int compute_duty_cycle(struct pwm_bl_data *pb, int brightness)&#123; /*一般情况下这个值都为0*/ unsigned int lth = pb-&gt;lth_brightness; /*占空比*/ int duty_cycle; /*pb-&gt;levels这个表格就是从dts节点brightness-levels中获取的, 假设进来的参数brightness是254,那么得到的duty_cycle就是1, 如果没有这个表格,那么就直接是进来的亮度值.*/ if (pb-&gt;levels) duty_cycle = pb-&gt;levels[brightness]; else duty_cycle = brightness; /*假设这里lth是0,那么公式就是duty_cycle * pb-&gt;period / pb-&gt;scale pb-&gt;period也就是dts节点 pwms 的第三个参数周期值为 25000 pb-&gt;scale为pb-&gt;levels数组中的最大值 所以这个公式就是按照将Android的纯数值转换成事件周期值对应的占空比.*/ return (duty_cycle * (pb-&gt;period - lth) / pb-&gt;scale) + lth;&#125; KrisFei 的小结:其实不管用哪种方式都是调用backlight_update_status来改变背光,syfs也是,看下backlight.cbacklight_class_init -&gt; backlight.c class_create //创建class,名字是backlight. backlight_class-&gt;dev_attrs = bl_device_attributes;12345678910static struct device_attribute bl_device_attributes[] = &#123; __ATTR(bl_power, 0644, backlight_show_power, backlight_store_power), __ATTR(brightness, 0644, backlight_show_brightness, backlight_store_brightness), __ATTR(actual_brightness, 0444, backlight_show_actual_brightness, NULL), __ATTR(max_brightness, 0444, backlight_show_max_brightness, NULL), __ATTR(type, 0444, backlight_show_type, NULL), __ATTR_NULL, &#125;; 其中backlight_store_brightness() 最终调用backlight_update_status().还有一种情况是亮屏/灭屏时调用,记得前面有注册一个fb notify callback.1234567891011121314151617181920212223static int fb_notifier_callback(struct notifier_block *self, unsigned long event, void *data) &#123; ... /*只处理亮屏和灭屏事件.*/ /* If we aren&apos;t interested in this event, skip it immediately ... */ if (event != FB_EVENT_BLANK &amp;&amp; event != FB_EVENT_CONBLANK) return 0; ... if (bd-&gt;ops) if (!bd-&gt;ops-&gt;check_fb || bd-&gt;ops-&gt;check_fb(bd, evdata-&gt;info)) &#123; bd-&gt;props.fb_blank = *(int *)evdata-&gt;data; //亮屏情况 if (bd-&gt;props.fb_blank == FB_BLANK_UNBLANK) bd-&gt;props.state &amp;= ~BL_CORE_FBBLANK; //灭屏时 else bd-&gt;props.state |= BL_CORE_FBBLANK; backlight_update_status(bd); &#125; ... &#125; 可以看到最后也是调用backlight_update_status() 问题集锦占空比到 20% 就黑了，到 80% 就满了有时候屏 pwm 占空比到 20% 就灭了，到 80% 就很亮了，即 brightness-levels 到 50 就灭了，到 200 就足够亮了。此时不需要 0～49 和 201 ～ 255所以我们 brightness-levels 数组的时候可以均匀的重复某些值。比如brightness-levels = &lt; 255 50 51 51 52 53 53 54 54 55 56 56 57 57 58 59 59 60 60 61 62 62 63 63 … 198 199 199 200&gt; 参考文章：[1] KrisFei http://blog.csdn.net/kris_fei/article/details/52485635","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 更换64GeMMC后无法启动的问题","slug":"Android_Driver/Debug/[Android6.0][RK3399] 更换64GeMMC后无法启动的问题","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T02:51:32.186Z","comments":true,"path":"2017/12/31/Android_Driver/Debug/[Android6.0][RK3399] 更换64GeMMC后无法启动的问题/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_Driver/Debug/[Android6.0][RK3399] 更换64GeMMC后无法启动的问题/","excerpt":"","text":"Author: YounixPlatform: RK3399OS: Android 6.0Kernel: 4.4Version: v2018.05 [TOC] 错误日志123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128[ 2.002835] dwmmc_rockchip fe310000.dwmmc: IDMAC supports 32-bit address mode.[ 2.002992] dwmmc_rockchip fe310000.dwmmc: Using internal DMA controller.[ 2.003029] dwmmc_rockchip fe310000.dwmmc: Version ID is 270a[ 2.003094] dwmmc_rockchip fe310000.dwmmc: DW MMC controller at irq 25,32 bit host data width,256 deep fifo[ 2.003164] dwmmc_rockchip fe310000.dwmmc: No vmmc regulator found[ 2.003178] dwmmc_rockchip fe310000.dwmmc: No vqmmc regulator found[ 2.004431] dwmmc_rockchip fe320000.dwmmc: IDMAC supports 32-bit address mode.[ 2.004506] dwmmc_rockchip fe320000.dwmmc: Using internal DMA controller.[ 2.004526] dwmmc_rockchip fe320000.dwmmc: Version ID is 270a[ 2.004580] dwmmc_rockchip fe320000.dwmmc: DW MMC controller at irq 26,32 bit host data width,256 deep fifo[ 2.004704] dwmmc_rockchip fe320000.dwmmc: No vmmc regulator found[ 2.005047] rockchip-iodomain ff770000.syscon:io-domains: Setting to 3300000 done[ 2.005203] rockchip-iodomain ff770000.syscon:io-domains: Setting to 3300000 done[ 2.017696] mmc_host mmc0: Bus speed (slot 0) = 400000Hz (slot req 400000Hz, actual 400000HZ div = 0)[ 2.031967] dwmmc_rockchip fe320000.dwmmc: 1 slots initialized[ 2.032446] sdhci-pltfm: SDHCI platform and OF driver helper[ 2.034361] sdhci-arasan fe330000.sdhci: No vmmc regulator found[ 2.034386] sdhci-arasan fe330000.sdhci: No vqmmc regulator found[ 2.062984] mmc1: SDHCI controller on fe330000.sdhci [fe330000.sdhci] using ADMA[ 2.115687] mmc1: MAN_BKOPS_EN bit is not set[ 2.131736] mmc1: new HS400 MMC card at address 0001[ 2.132971] mmcblk1: mmc1:0001 MCG8GC 58.2 GiB [ 2.133959] mmcblk1boot0: mmc1:0001 MCG8GC partition 1 4.00 MiB[ 2.134926] mmcblk1boot1: mmc1:0001 MCG8GC partition 2 4.00 MiB[ 2.135958] mmcblk1rpmb: mmc1:0001 MCG8GC partition 3 4.00 MiB[ 2.136600] uboot: 0x000400000 -- 0x000800000 (4 MB)[ 2.136622] trust: 0x000800000 -- 0x000c00000 (4 MB)[ 2.136635] misc: 0x000c00000 -- 0x001000000 (4 MB)[ 2.136647] resource: 0x001000000 -- 0x002000000 (16 MB)[ 2.136659] kernel: 0x002000000 -- 0x003800000 (24 MB)[ 2.136671] boot: 0x003800000 -- 0x005800000 (32 MB)[ 2.136684] recovery: 0x005800000 -- 0x008800000 (48 MB)[ 2.136696] backup: 0x008800000 -- 0x00f800000 (112 MB)[ 2.136708] cache: 0x00f800000 -- 0x017800000 (128 MB)[ 2.136721] system: 0x017800000 -- 0x0d7800000 (3072 MB)[ 2.136735] metadata: 0x0d7800000 -- 0x0d8800000 (16 MB)[ 2.136748] baseparamer: 0x0d8800000 -- 0x0d8c00000 (4 MB)[ 2.136761] frp: 0x0d8c00000 -- 0x0d8c80000 (0 MB)[ 2.136773] userdata: 0x0d8c80000 -- 0xe8f400000 (56167 MB)[ 2.136816] mmcblk1: p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14[ 2.481883] dwmmc_rockchip fe310000.dwmmc: IDMAC supports 32-bit address mode.[ 2.482061] dwmmc_rockchip fe310000.dwmmc: Using internal DMA controller.[ 2.482113] dwmmc_rockchip fe310000.dwmmc: Version ID is 270a[ 2.482169] dwmmc_rockchip fe310000.dwmmc: DW MMC controller at irq 25,32 bit host data width,256 deep fifo[ 2.482287] dwmmc_rockchip fe310000.dwmmc: No vmmc regulator found[ 2.482316] dwmmc_rockchip fe310000.dwmmc: No vqmmc regulator found[ 2.482769] dwmmc_rockchip fe310000.dwmmc: allocated mmc-pwrseq[ 2.494688] mmc_host mmc2: Bus speed (slot 0) = 400000Hz (slot req 400000Hz, actual 400000HZ div = 0)[ 2.507803] dwmmc_rockchip fe310000.dwmmc: 1 slots initialized[ 2.556671] mmc2: queuing unknown CIS tuple 0x80 (2 bytes)[ 2.559525] mmc2: queuing unknown CIS tuple 0x80 (3 bytes)[ 2.561212] mmc2: queuing unknown CIS tuple 0x80 (3 bytes)[ 2.565389] mmc2: queuing unknown CIS tuple 0x80 (7 bytes)[ 2.623906] mmc_host mmc2: Bus speed (slot 0) = 200000000Hz (slot req 208000000Hz, actual 200000000HZ div = 0)[ 2.628545] init: OK,EMMC DRIVERS INIT OK[ 2.932402] EXT4-fs (mmcblk1p10): mounted filesystem with ordered data mode. Opts: noauto_da_alloc[ 2.932568] fs_mgr: __mount(source=/dev/block/platform/fe330000.sdhci/by-name/system,target=/system,type=ext4)=0[ 2.933322] EXT4-fs (mmcblk1p9): Ignoring removed nomblk_io_submit option[ 2.937456] EXT4-fs (mmcblk1p9): mounted filesystem with ordered data mode. Opts: nomblk_io_submit,errors=remount-ro[ 2.937600] fs_mgr: check_fs(): mount(/dev/block/platform/fe330000.sdhci/by-name/cache,/cache,ext4)=0: Success[ 2.956910] fs_mgr: check_fs(): unmount(/cache) succeeded[ 2.958200] fs_mgr: Running /system/bin/e2fsck on /dev/block/platform/fe330000.sdhci/by-name/cache[ 2.964050] mmc1: Got data interrupt 0x00000002 even though no data operation was in progress.[ 2.966278] mmcblk1: error -110 sending stop command, original cmd response 0x900, card status 0x400900[ 2.966313] mmcblk1: retrying because a re-tune was needed[ 2.988024] mmc1: Got data interrupt 0x00000002 even though no data operation was in progress.[ 2.990140] mmcblk1: error -110 sending stop command, original cmd response 0x900, card status 0x400900[ 2.990184] mmcblk1: error -84 transferring data, sector 973048, nr 256, cmd response 0x900, card status 0x0[ 2.990260] mmcblk1: retrying using single block read[ 3.038680] mmc1: Got data interrupt 0x00000002 even though no data operation was in progress.[ 3.040785] mmcblk1: error -110 sending stop command, original cmd response 0x900, card status 0x400900[ 3.040818] mmcblk1: retrying because a re-tune was needed[ 3.059313] mmc1: Got data interrupt 0x00000002 even though no data operation was in progress.[ 3.061430] mmcblk1: error -110 sending stop command, original cmd response 0x900, card status 0x400900[ 3.061469] mmcblk1: error -84 transferring data, sector 972800, nr 224, cmd response 0x900, card status 0x0[ 3.061536] mmcblk1: retrying using single block read[ 3.106220] mmcblk1: error -84 transferring data, sector 972989, nr 35, cmd response 0x900, card status 0x0[ 3.106289] blk_update_request: I/O error, dev mmcblk1, sector 972989[ 3.141668] mmc1: Got data interrupt 0x00000002 even though no data operation was in progress.[ 3.143802] mmcblk1: error -110 sending stop command, original cmd response 0x900, card status 0x400900[ 3.143850] mmcblk1: retrying because a re-tune was needed[ 3.162815] mmc1: Got data interrupt 0x00000002 even though no data operation was in progress.[ 3.165056] mmcblk1: error -110 sending stop command, original cmd response 0x900, card status 0x400900[ 3.165113] mmcblk1: error -84 transferring data, sector 972984, nr 8, cmd response 0x900, card status 0x0[ 3.165155] mmcblk1: retrying using single block read[ 3.184661] mmcblk1: error -84 transferring data, sector 972989, nr 3, cmd response 0x900, card status 0x0[ 3.184715] blk_update_request: I/O error, dev mmcblk1, sector 972989[ 3.204352] mmc1: Got data interrupt 0x00000002 even though no data operation was in progress.[ 3.206483] mmcblk1: error -110 sending stop command, original cmd response 0x900, card status 0x400900[ 3.206525] mmcblk1: retrying because a re-tune was needed[ 3.225395] mmc1: Got data interrupt 0x00000002 even though no data operation was in progress.[ 3.227528] mmcblk1: error -110 sending stop command, original cmd response 0x900, card status 0x400900[ 3.227572] mmcblk1: error -84 transferring data, sector 972984, nr 8, cmd response 0x900, card status 0x0[ 3.227603] mmcblk1: retrying using single block read[ 3.246588] mmcblk1: error -84 transferring data, sector 972989, nr 3, cmd response 0x900, card status 0x0[ 3.246633] blk_update_request: I/O error, dev mmcblk1, sector 972989[ 3.263636] e2fsck[225]: unhandled level 3 translation fault (7) at 0x7f9fc2d4a4, esr 0x82000007[ 3.263682] pgd = ffffffc0e8e0c000[ 3.263702] [7f9fc2d4a4] *pgd=00000000e8473003, *pud=00000000e8473003, *pmd=00000000e8479003, *pte=0000000000000000[ 3.263758] [ 3.263783] CPU: 4 PID: 225 Comm: e2fsck Not tainted 4.4.36 #633[ 3.263807] Hardware name: rockchip,rk3399-excavator-edp (DT)[ 3.263829] task: ffffffc0e8534980 ti: ffffffc0e858c000 task.ti: ffffffc0e858c000[ 3.263854] PC is at 0x7f9fc2d4a4[ 3.263871] LR is at 0x44[ 3.263888] pc : [&lt;0000007f9fc2d4a4&gt;] lr : [&lt;0000000000000044&gt;] pstate: a0000000[ 3.263908] sp : 0000007fd2ee0430[ 3.263924] x29: 0000007fd2ee0430 x28: 0000007fd2ee0600 [ 3.263957] x27: 00000000ffffffd8 x26: 0000007fd2ee05d0 [ 3.263989] x25: 0000000000000000 x24: 0000007fd2ee0c58 [ 3.264020] x23: 00000000ffffffff x22: 0000007f9fc39170 [ 3.264050] x21: 0000007fd2ee05c0 x20: 0000007fd2ee06b8 [ 3.264080] x19: 0000007fd2ee05b4 x18: 0000000000000000 [ 3.264110] x17: 0000007fd2ee0da0 x16: 00000000ffffffe0 [ 3.264140] x15: 0000000000000000 x14: 0000000000000000 [ 3.264201] x13: 0000007fd2ee0630 x12: 0000007fd2ee05a7 [ 3.264232] x11: 0000007fd2ee05a8 x10: 0000007fd2ee0d78 [ 3.264263] x9 : 0000007f9fc56018 x8 : 0000000000000064 [ 3.264293] x7 : 0000007f9fc56098 x6 : 0000007fd2ee06c8 [ 3.264323] x5 : 0000007f9fc56c58 x4 : 0000007f9fc3bf70 [ 3.264353] x3 : 0000000000000002 x2 : 0000000000000030 [ 3.264383] x1 : 0000000000000003 x0 : 00000000ffffffd8 [ 3.264413] [ 3.264907] e2fsck: e2fsck terminated by signal 7 后面则是重复出现上面这个 mounted filesystem with ordered data mode. Opts: noauto_da_alloc,discard 的错误. 解决方案从 Log 上来看, 显然是 fe330000 的有问题. 查看 fe330000 是 sdhci. 所以确定是 EMMC 有问题.在系统起来后, eMMC 的 clock 为 200MHZ , 尝试降低 eMMC CLK Frequence , 发现 50MHZ 100MHZ 150MHZ 系统均可以正常启动.后来和硬件沟通, 了解到这个是由于硬件上 eMMC 走线有问题. 导致信号不完整. 123456789101112diff --git a/arch/arm64/boot/dts/rockchip/rk3399-vop-clk-set.dtsi b/arch/arm64/boot/dts/rockchip/rk3399-vop-clk-set.dtsiindex 0ca60fb..e1d2563 100644--- a/arch/arm64/boot/dts/rockchip/rk3399-vop-clk-set.dtsi+++ b/arch/arm64/boot/dts/rockchip/rk3399-vop-clk-set.dtsi@@ -51,7 +51,8 @@ &amp;sdhci &#123; assigned-clocks = &lt;&amp;cru SCLK_EMMC&gt;; assigned-clock-parents = &lt;&amp;cru PLL_GPLL&gt;;- assigned-clock-rates = &lt;200000000&gt;;+ //assigned-clock-rates = &lt;200000000&gt;;+ assigned-clock-rates = &lt;150000000&gt;; &#125;;","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 PCIe 转 SATA 调试步骤","slug":"Android_Driver/Driver/[Android6.0][RK3399] PCIe 转 SATA 调试步骤","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T02:38:25.463Z","comments":true,"path":"2017/12/31/Android_Driver/Driver/[Android6.0][RK3399] PCIe 转 SATA 调试步骤/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_Driver/Driver/[Android6.0][RK3399] PCIe 转 SATA 调试步骤/","excerpt":"","text":"Platform: RK3399OS: Android 6.0Kernel: 4.4Version: v2017.04 PCI 基本调试手段busybox lspcilspci 命令查看 pci 设备。出现如下信息：10c:00.0 0100: 1000:0056 (rev 02) 0c：00.0 表示含义为 bus number： device number.function number 三者组合成一个 16bit 的识别码 bus number：8bits 最多连接到 256 个 bus device number：6bits 最多连接到 32 种装置 function number：3bits 最多每种装置有 8 种功能0100: 1000:0056 表示含义为 Class ID： Vendor ID Device ID 通过如下命令可以获取 pci 的速度1#lspci -n -d 1000:0056 -vvv |grep -i width cat /proc/partitions可以查看分区信息。 mount调试 PCIe 转 SATA 设备，还需要在生成设备节点后将硬盘的设备节点挂载到我们系统的目录上。1mount -t ext3 /dev/block/sdb1 /mnt/Younix/ PCIe 调试步骤 在 menuconfig 中打开相应的调试宏：BUS Support -&gt; PCI Debugging打开相应 PCIe 总线驱动： BUS Support -&gt; PCI Support打开其热插拔功能（Hot Plug）：BUS Support -&gt; Support for PCI Hotplug 在 PCIe 设备没有插上的情况下开机，得到如下 log 12345[ 1.157185] rockchip-pcie f8000000.pcie: no vpcie3v3 regulator found[ 1.157207] rockchip-pcie f8000000.pcie: no vpcie1v8 regulator found[ 1.157223] rockchip-pcie f8000000.pcie: no vpcie0v9 regulator found[ 1.691995] rockchip-pcie f8000000.pcie: PCIe link training gen1 timeout![ 1.692059] rockchip-pcie: probe of f8000000.pcie failed with error -110 我们 PCIe 设备还未连接，出现如上 Log 为正常。 将 PCIe 的设备插在板子上后。利用 busybox lspci 查看现在的 pci 设备。 123shell@rk3399_mid:/ $ busybox lspci00:00.0 Class 0604: 17cd:000001:00.0 Class 0106: 1b21:0612 可以看到有几个 ID，可以根据 ID 确认设备是否被识别到。 比如我们根据官方的 datasheet 知道，1b21 即 ASMEDIA 厂商的 Vendor ID，0612 即 Product ID。 之后就是加载设备驱动的时候，会根据 VENDOR_ID 进行匹配。识别成功后才能加载 probe。 如果没有进入 probe ，有一种情况是设备已经被一个驱动占有了，找到这个设备使用的驱动，并且去除即可。 调试 PCIe 转 SATA 设备对于调试转 SATA 设备，还需要提供设备驱动的支持： 打开 PCIe 转 SATA 小板的设备驱动：Device Driver -&gt; Serial ATA and Parallel ATA driverrs(libata) -&gt; AHCI SATA support 确认方法为123# ls dev/block/sd*sdasda1 可以看到多出来了 sda 与 sda1，sda 即为 sata 硬盘，sda[n] 即为其分区号。 问题汇总PCIe 供电PCIe 供电没有打开的情况下，需要在 dts 添加 power supply：1234567891011121314151617181920212223242526272829303132333435363738394041index 4763727..677ed9d 100644--- a/arch/arm64/boot/dts/rockchip/rk3399-sapphire.dtsi+++ b/arch/arm64/boot/dts/rockchip/rk3399-sapphire.dtsi@@ -179,6 +179,17 @@ rockchip,pwm_id= &lt;2&gt;; rockchip,pwm_voltage = &lt;1000000&gt;; &#125;;++ vcc3v3_3g: vcc3v3-3g-regulator &#123;+ compatible = &quot;regulator-fixed&quot;;+ enable-active-high;+ regulator-always-on;+ regulator-boot-on;+ gpio = &lt;&amp;gpio0 2 GPIO_ACTIVE_HIGH&gt;;+ pinctrl-names = &quot;default&quot;;+ pinctrl-0 = &lt;&amp;pcie_3g_drv&gt;;+ regulator-name = &quot;vcc3v3_3g&quot;;+ &#125;; &#125;; &amp;cpu_l0 &#123;@@ -511,6 +522,7 @@ num-lanes = &lt;4&gt;; pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;pcie_clkreqn&gt;;+ phy-supply = &lt;&amp;vcc3v3_3g&gt;; status = &quot;okay&quot;; &#125;; @@ -658,6 +670,14 @@ &#125;; &amp;pinctrl &#123;++ pcie &#123;+ pcie_3g_drv: pcie-3g-drv &#123;+ rockchip,pins =+ &lt;0 2 RK_FUNC_GPIO &amp;pcfg_pull_up&gt;;+ &#125;;+ &#125;;+","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android 文件系统分区挂载流程","slug":"Android_Sys/[Android] 文件系统分区挂载流程","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T02:23:04.979Z","comments":true,"path":"2017/12/31/Android_Sys/[Android] 文件系统分区挂载流程/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_Sys/[Android] 文件系统分区挂载流程/","excerpt":"","text":"//DRAFT//TODO 最近在玩 RK 的板子，想要将 Ubuntu 移植上去，对比之前做 Android 的时候，发现他们的 Kernel 部分完全一样。那么 Linux 发行版 和 Android 系统他们之间的差别究竟是怎样的呢？差别在于 Kernel 启动后，挂载的分区有所差别。所进入的 rootfs（根文件系统）不同。之前有写一篇关于 Android 启动流程的文章。 分区挂载配置文件 fstabAndroid 5.1 &amp; 6.0 的分区挂载配置文件是 fstab.*.* ，比如 ./device/rockchip/rk3399/fstab.rk30board.bootmode.emmc12&lt;src&gt; &lt;mount point&gt; &lt;filesystem type&gt; &lt;mount flags parameters&gt; &lt;fs_mgr_flags&gt; /dev/block/platform/fe330000.sdhci/by-name/system /system ext4 ro,noatime,nodiratime,noauto_da_alloc wait,resize 其中 mount flags parameters 文件系统的参数：rw/ro : 是否以以只读或者读写模式挂载async/sync : 设置是否为同步方式运行auto/noauto : 当下载mount -a 的命令时，此文件系统是否被主动挂载。默认为autoexec/noexec : 限制此文件系统内是否能够进行”执行”的操作user/nouser : 是否允许用户使用mount命令挂载suid/nosuid ： 是否允许SUID的存在usrquota : 启动文件系统支持磁盘配额模式grpquota : 启动文件系统对群组磁盘配额模式的支持defaults ： 同时具有rw,suid,dev,exec,auto,nouser,async等默认参数的设置 通过配置 fstab，vold 服务通过 process_config 函数调用 fs_mgr_read_fstab 来完成对分区文件的解析。 init 获取 fstab 的配置信息kernel 加载完后第一个执行的是 init 进程，init 进程会根据 init.rc 的规则启动进程或者服务，这个我之前有写一篇文章讲述。init.rc 通过 import /init.${ro.hardware}.rc导入平台的规则。device/rockchip/common/init.rk30board.rc中：1import init.$&#123;ro.hardware&#125;.bootmode.&#123;ro.bootmode&#125;.rc 这里导入的便是 init.rk30board.bootmode.emmc.rcdevice/rockchip/common/init.rk30board.bootmode.emmc.rc 中：123on fs write /sys/block/mmcblk0/bdi/read_ahead_kb 2048 mount_all fstab.rk30board mount_all 表示执行 do_mount_all 函数，其参数为 fstab.rk30board。在 system/core/init/keyworks.h 中定义 KEYWORD(mount_all, COMMAND, 1, do_mount_all) 这个函数的定义在 system/core/init/builtins.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/* * This function might request a reboot, in which case it will * not return. */int do_mount_all(int nargs, char **args)&#123; pid_t pid; int ret = -1; int child_ret = -1; int status; const char *prop; struct fstab *fstab; if (nargs != 2) &#123; return -1; &#125; /* * Call fs_mgr_mount_all() to mount all filesystems. We fork(2) and * do the call in the child to provide protection to the main init * process if anything goes wrong (crash or memory leak), and wait for * the child to finish in the parent. */ pid = fork(); if (pid &gt; 0) &#123; /* Parent. Wait for the child to return */ int wp_ret = TEMP_FAILURE_RETRY(waitpid(pid, &amp;status, 0)); if (wp_ret &lt; 0) &#123; /* Unexpected error code. We will continue anyway. */ NOTICE(&quot;waitpid failed rc=%d, errno=%d\\n&quot;, wp_ret, errno); &#125; if (WIFEXITED(status)) &#123; ret = WEXITSTATUS(status); &#125; else &#123; ret = -1; &#125; &#125; else if (pid == 0) &#123; /* child, call fs_mgr_mount_all() */ klog_set_level(6); /* So we can see what fs_mgr_mount_all() does */ fstab = fs_mgr_read_fstab(args[1]); //解析分区文件fstab child_ret = fs_mgr_mount_all(fstab); fs_mgr_free_fstab(fstab); if (child_ret == -1) &#123; ERROR(&quot;fs_mgr_mount_all returned an error\\n&quot;); &#125; _exit(child_ret); &#125; else &#123; /* fork failed, return an error */ return -1; &#125; if (ret == FS_MGR_MNTALL_DEV_NEEDS_ENCRYPTION) &#123; property_set(&quot;vold.decrypt&quot;, &quot;trigger_encryption&quot;); &#125; else if (ret == FS_MGR_MNTALL_DEV_MIGHT_BE_ENCRYPTED) &#123; property_set(&quot;ro.crypto.state&quot;, &quot;encrypted&quot;); property_set(&quot;vold.decrypt&quot;, &quot;trigger_default_encryption&quot;); &#125; else if (ret == FS_MGR_MNTALL_DEV_NOT_ENCRYPTED) &#123; property_set(&quot;ro.crypto.state&quot;, &quot;unencrypted&quot;); /* If fs_mgr determined this is an unencrypted device, then trigger * that action. */ action_for_each_trigger(&quot;nonencrypted&quot;, action_add_queue_tail); &#125; else if (ret == FS_MGR_MNTALL_DEV_NEEDS_RECOVERY) &#123; /* Setup a wipe via recovery, and reboot into recovery */ ERROR(&quot;fs_mgr_mount_all suggested recovery, so wiping data via recovery.\\n&quot;); ret = wipe_data_via_recovery(); /* If reboot worked, there is no return. */ &#125; else if (ret &gt; 0) &#123; ERROR(&quot;fs_mgr_mount_all returned unexpected error %d\\n&quot;, ret); &#125; /* else ... &lt; 0: error */ return ret;&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 设置系统默认不会休眠","slug":"Android_App/[Android6.0][RK3399] 设置系统默认不会休眠","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T03:30:31.493Z","comments":true,"path":"2017/12/31/Android_App/[Android6.0][RK3399] 设置系统默认不会休眠/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_App/[Android6.0][RK3399] 设置系统默认不会休眠/","excerpt":"","text":"Platform: RK3399OS: Android 6.0Version: v2017.04 [TOC] 需求默认系统开机休眠时间为 60000 ms，需要设置为 Never （不会休眠）。 原理设置 ro.rk.screenoff_time 参数。和网上所说的设为 -1 不同，rk 平台应该设为 2147483647 。 步骤1$ grep screenoff_time ./device/ -nir 看到12./device/rockchip/common/device.mk:484: ro.rk.screenoff_time=2147483647./device/rockchip/common/device.mk:487: ro.rk.screenoff_time=60000 123456789$ vi ./device/rockchip/common/device.mk +484481 ifeq ($(strip $(TARGET_BOARD_PLATFORM_PRODUCT)), box)482 include device/rockchip/common/samba/rk31_samba.mk483 PRODUCT_PROPERTY_OVERRIDES += \\484 ro.rk.screenoff_time=2147483647485 else486 PRODUCT_PROPERTY_OVERRIDES += \\487 ro.rk.screenoff_time=60000488 endif 可见，默认产品为 box 的时候， ro.rk.screenoff_time 为 2147483647 这个值。其他的产品默认为 60000（1 min）。我们将也修改为 2147483647。 调用./packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java12loadSetting(stmt, Settings.System.SCREEN_OFF_TIMEOUT, SystemProperties.getInt(&quot;ro.rk.screenoff_time&quot;, mContext.getResources().getIntege r(R.integer.def_screen_off_timeout))); 将属性值存储到 stmt 数据库中的 Settings.System.SCREEN_OFF_TIMEOUT 字段中。再供其他 app 如 hdmisetting、displaysetting 等进行调用。 其他另外我尝试在 system.prop 中去添加这个属性。但是没有起作用，adb pull 出 build.prop 后发现，system.prop 中设置的值在前面。PRODUCT_PROPERTY_OVERRIDES 设置的值在后面，会覆盖掉前面的设置。 所以研究了一下系统属性加载优先级。这篇文章很好：http://blog.csdn.net/thl789/article/details/7014300 总的来说，顺序如下 追加 system.prop 的内容到 build.prop 追加 ADDITIONAL_BUILD_PROPERTIES 设定的属性值到 build.prop 追加 PRODUCT_PROPERTY_OVERRIDES 设定的属性值到 build.prop 作为标准的配置而言，最好是加到 device/platform/product/system.prop 中，但是最好先去 device.mk 文件中搜一下有没有设置过这个属性。如果有的话就在 device.mk 中修改吧。 而添加到 PRODUCT_PROPERTY_OVERRIDES 中的属性，因为是最后追加到 build.prop 的。可以保证成功。","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 PCIe 接口 4G模块 EC20 调试记录","slug":"Android_Driver/Driver/[Android6.0][RK3399] PCIe 接口 4G模块 EC20 调试记录","date":"2017-12-31T15:33:05.000Z","updated":"2018-11-08T02:38:06.687Z","comments":true,"path":"2017/12/31/Android_Driver/Driver/[Android6.0][RK3399] PCIe 接口 4G模块 EC20 调试记录/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_Driver/Driver/[Android6.0][RK3399] PCIe 接口 4G模块 EC20 调试记录/","excerpt":"","text":"Platform: RK3399OS: Android 6.0Kernel: 4.4Version: v2017.044G Module: EC20-CE [TOC] 一、基本概念1. USB 部分的功能接口Quectel 3G/4G模块（UMTS/HSPA/LTE）的 USB 部分包括了几个不同的功能接口。 USB SerialttyUSB0 代表 DMttyUSB1 代表 GPS NMEA （GPS导航设备统一的RTCM标准协议）信息输出ttyUSB2 代表 AT commandsttyUSB3 代表 PPP 连接 GobiNet 在移植了 GobiNet 驱动后，会产生一个网络设备和一个 QMI channel。网络设备叫做 ethX（在内核版本2.6.39前叫做 usbX）QMI channel 叫做 /dev/qcqmiX 的节点。网络设备用来进行数据传输，QMI 通道用来进行 QMI 信息交互。Qualcomm Gobi is a family of embedded mobile broadband modem products by Qualcomm. Gobi technology was designed to allow for any product with the embedded solution to connect to the internet anywhere a wireless carrier provides data coverage. One of the more notable products that contain a Gobi modem is the iPhone 4 for Verizon, which contains a MDM6600™, however it does not take advantage of the support for HSPA+ QMI WWAN当移植了 QMI WWAN 驱动后，驱动将会创建网络设备和 QMI channel，网络设备被称作 wwanX，QMI 通道被命名为 /dev/cdc-wdmX。网络设备用来进行数据传输，QMI 通道用来进行 QMI 数据交互。 CDC ACM在移植完了 CDC ACM 驱动后，将会在 /dev 下创建如下节点ttyACM0 用于 PPP连接器 或者 AT命令ttyACM1 用于 Trace1ttyACM2 用于 Trace2ttyACM3 用于 AT commandsttyACM4 用于 AT commands USB 的 CDC 类是 USB 通信设备类 （Communication Device Class）的简称。CDC 类 是 USB 组织定义的一类专门给各种通信设备（电信通信设备和中速网络通信设备）使用的 USB 子类。 2. APNAPN 指一种网络接入技术，是通过手机上网时必须配置的一个参数，它决定了手机通过哪种接入方式来访问网络。 二、驱动移植1. USB Driver主要参考官方文档《Quectel_WCDMA&amp;LTE_Linux_USB_Driver_User_Guide_V1.5.pdf》精简版的移植手册可以参考 http://blog.csdn.net/hnjztyx/article/details/72495433 这篇，三星平台 Android5.1 的，写的比较清晰。 另外有部分地方需要强调一下。 如果是 EC20 需要将其 VendorID 和 ProductID 打印出来看一下，因为有的 EC20 是有两个版本的，分别是 EC20-C 和 EC20-CE。EC20-C IDVendor=0x05c6 IDProduct=0x9215EC20-CE IDVendor=0x2c7c IDProduct=0x0125插拔设备出现信息如下：[ 723.730113] usb 1-1: New USB device found, idVendor=2c7c, idProduct=0125可见我的设备是 EC20-CE。务必确认好自己的物料版本。 移植的时候最好先控制变量，第一步只移植 USB Serial Driver 部分。完成这部分的移植后 /dev/下就应该生成 ttyUSB0-ttyUSB4 。一次添加的东西多了如果出现问题不好定位问题出现的地方。 2. GobiNet Driver 或者 QMI WWANGobiNet Driver 和 QMI WWAN 两者的作用相同，只不过一个是在 Kernel Space 实现，一个是在 Userspace 实现。对于 GobiNet Driver，需要在 Kernel 中添加 供应商提供的 GobiNet 的源码;对于 QMI WWAN ，默认 Android 6.0 中已经实现了这种方式，我们只需要添加 ID 即可，所以我选择的后者。调试完成后会在 /dev 下生成cdc-wdmX节点。 3. PPP 拨号配置在驱动部分参考手册打开对应的宏即可。下面是关于 APN 的配置，在我们完成 RIL 的移植后进行。 APN : Access Point Names 。ChinaUnicom 联通 3gnet ，ChinaMobile 移动 cmnet，ChinaTelecom 电信 ctnet。 三、RIL 移植 RIL 在 Android 中的位置如下图 可以看到，RIL 在 Android 架构中的位置处于 Kernel 和 Framework 之间。Libraries 中的 RIL 被分为两个部分，RILD 和 Vendor RIL。RILD 负责 Socket 和 Framework 之间的通信。Vendor RIL 负责 和 Radio 的通信（通过 AT command channel 与 Packet data channel(PDCH)）。AT command channel 用来直接和 Radio 通信，PDCH 用以 data service。Java framework 中的 RIL 也被分为来两个部分，一部分是 RIL module 另一部分是 Phone module。The RIL modeule 用来和底层的 RILD 通信，The Phone module 直接为应用层（Application）提供电话功能的接口。 1. RIL Driver Integration以 Quectel 的 EC20 为例。Quectel 以源码形式提供了 RIL driver（package/reference-ril）。我们只需要拷贝到我们的 Android 源码的正确路径并编译即可。 相应 Android 源码路径为：hardware/ril/reference-ril ，用代理商提供的代码替换即可。 并且修改 init.rc123456service ril-daemon /system/bin/rild -l /system/lib/libreference-ril.so class main socket rild stream 660 root radio socket rild-debug stream 666 radio system user root group radio cache inet misc audio sdcard_rw log 禁能切换用户 hardware/ril/rild/rild.c123OpenLib: #endif //switchUser(); 如果需要在 非root 下进行调试的话，还可以在 common/ueventd.rockchip.rc 中加上：12345# for radio/dev/ttyUSB0 0666 radio radio/dev/ttyUSB1 0666 radio radio/dev/ttyUSB2 0666 radio radio/dev/ttyUSB3 0666 radio radio 重新编译即可。 2. 抓取 Android Log12# 只看 RIL module 的 logadb logcat -b radio -v time 3. RIL 移植问题汇总1. 代码出现大量 errorEC20 的代理代码释放有误，Android6.0 对应的代码是《Quectel_Android_RIL_SR01A41V17》。 2. 出现模块冲突报错：1build/core/base_rules.mk:157: *** hardware/ril/reference-ril: MODULE.TARGET.EXECUTABLES.chat alread defined by external/ppp/chat。 直接删除 rk 的 chat 模块即可1rm externel/ppp/chat -rf 3. RIL 没有生效（完成了 RIL 部分的移植后，看起来 4G 模块没有起作用）1）确认 RIL 进程有没有运行12# getprop init.svc.ril-daemon应该得到 Running ，如果得到的是 Stopped 或者 Restarting，则需要重新检查移植步骤 2）看一下 lib 是否是 Quectel 的123# getprop gsm.version.ril-impl如果是 Quectel 的应该是Quectel_Android_RIL_SR 开头的 如果这里显示的是RIL_RK_DATA_V3.6_android6.0 //说明调用到 rk 自己的 ril 库了，去下一步确定 init.rc 的修改有没有成功，如果没成功参照 第4点。如果这里显示的是 空说明 库 和平台不兼容，检查是不是调用和自己平台兼容的库，比如 32 位是在 system/lib 下，64位 是在 system/lib64 下 3）确认一下 init.rc 中的修改有没有成功1cat init.rc | grep ril-daemon 没有成功请参照后面的第4点。 4）确认 SELinux 没有打开123# getenforce 来获取 SELinux 的状态# setenforce 0 将其设置为 Permissive 4. init.rc 中的修改没有生效在 device/rockchip/rk3399/init.rc 中的修改没有生效去 out/…/rk3399_mid/root/init.rc 中看，并没有产生我们需要的修改 在 rk3399/device.mk 中可以看到1234#ifeq ($(strip $(TARGET_BOARD_PLATFORM_PRODUCT)), tablet)#PRODUCT_COPY_FILES += \\ $(LOCAL_PATH)/rk3399_32/init.rc:root/init.rc#endif 如果是 tablet 产品，会 copy rk3399_32 中的 init rc 到 mid/init.rc 中。所以这个地方的逻辑修改为12PRODUCT_COPY_FILES += \\ $(LOCAL_PATH)/init.rc:root/init.rc 另外，在3399 平台，会在 device.mk 中追加一次 lib 的路径./rockchip/common/device.mk:588: rild.libpath=/system/lib64/libril-rk29-dataonly.so它会将之前我们指定的库的路径覆盖，需要将这一行删掉。 5. 不修改 init.rc ，修改 system.prop 的方式指定 lib 库有些产品，比如 vr、box 会在 system.prop 中指定 rild.libpath 。。所以我们也可以参考 RK 提供的做法来完成 库 路径的指定：比如我是 mid 产品，指定 lib 路径为 64 bit 的库路径：12345vi device/rockchip/rk3399/rk3399_mid/system.prop-- rild.libpath=/system/lib/libril-rk29-dataonly.so-- rild.libargs=-d /dev/ttyACM0++ rild.libpath=/system/lib64/libreference-ril.so++ rild.libargs=-d /dev/ttyUSB0 6. SIM 卡 ABSENT如果出现如下 Log1234501-18 08:50:21.678 D/ATC ( 225): AT&gt; AT+CPIN?01-18 08:50:21.679 D/ATC ( 225): AT&lt; +CME ERROR: 1001-18 08:50:21.681 D/RILJ ( 731): [3664]&lt; GET_SIM_STATUS IccCardState &#123;CARDSTATE_ABSENT,PINSTATE_UNKNOWN,num_apps=0,gsm_id=8,cdma_id=8,ims_id=8&#125; [SUB0]“CARDSTATE_ABSENT” 说明可能是 SIM 卡卡座有问题。检查 SIM 卡卡座与 SIM 卡，发现 SIM 卡插反了。","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android 智能指针 SP强指针WP弱指针 用法","slug":"Android_Sys/[Android] 智能指针 SP强指针WP弱指针 用法","date":"2017-12-31T15:33:04.000Z","updated":"2018-11-08T02:22:41.071Z","comments":true,"path":"2017/12/31/Android_Sys/[Android] 智能指针 SP强指针WP弱指针 用法/","link":"","permalink":"http://iyounix.com/2017/12/31/Android_Sys/[Android] 智能指针 SP强指针WP弱指针 用法/","excerpt":"","text":"这两天分析问题的时候看到了 sp&lt; xxx &gt; wp&lt; xxx &gt; 这样的类型定义。查阅资料后了解到这是 Android 中智能指针的用法。 概念智能指针是 C++ 中的概念。通过引用计数的方法，解决对象自动释放的问题。在 C++ 编程中，有两个头疼的问题。 忘记释放动态申请的对象而造成内存泄漏 对象在一个地方释放后，又在别的地方被使用，从而引起内存访问错误 所以采用智能指针后，动态申请的内存将会被自动释放，不需要 delete 来释放对象，也不用考虑一个对象是否在其他地方被释放了。Android智能指针相关的源代码在下面两个文件中：frameworks\\base\\include\\utils\\RefBase.hframeworks\\base\\libs\\utils\\RefBase.cpp Android 中有两种指针类型，强指针 SP(strong pointer) 弱指针 WP(weak pointer)自动释放的原理在于可以被智能指针引用的对象都同时被附加了另外一个 weakref_impl类型的对象，这个对象中负责记录对象的强指针引用计数和弱指针引用计数。这个对象是Android智能指针的实现内部使用的，智能指针的使用者看不到这个对象。弱指针操作的就是这个对象，只有当强引用计数和弱引用计数都为0时，这个对象才会被销毁。 强指针强指针与一般意义的智能指针概念相同，通过引用计数来记录有多少使用者在使用一个对象，如果所有使用者都放弃了对该对象的引用，则该对象将被自动销毁。 弱指针弱指针也指向一个对象，但是弱指针仅仅记录该对象的地址，不能通过弱指针来访问该对象，也就是说不能通过弱智真来调用对象的成员函数或访问对象的成员变量。要想访问弱指针所指向的对象，需首先将弱指针升级为强指针（通过wp类所提供的promote()方法）。弱指针所指向的对象是有可能在其它地方被销毁的，如果对象已经被销毁，wp的promote()方法将返回空指针，这样就能避免出现地址访问错的情况。 用法假设现在有一个类MyClass，如果要使用智能指针来引用这个类的对象，那么这个类需满足下列两个前提条件： 这个类是基类 RefBase 的子类或间接子类； 这个类必须定义虚构造函数，即它的构造函数需要这样定义：1virtual ~MyClass(); 满足了上述条件的类就可以定义Android智能指针了，定义方法和普通指针类似。比如普通指针是这样定义：1MyClass* p_obj; Android智能指针是这样定义：1sp&lt; MyClass&gt; p_obj; 注意不要定义成 sp&lt; MyClass&gt;* p_obj。初学者容易犯这种错误，这样实际上相当于定义了一个指针的指针。尽管在语法上没有问题，但是最好永远不要使用这样的定义。 强指针定义了一个智能指针的变量，就可以象普通指针那样使用它，包括赋值、访问对象成员、作为函数的返回值、作为函数的参数等。比如：123456p_obj = new MyClass(); // 注意不要写成 p_obj = new sp&lt; MyClass&gt; sp&lt; MyClass&gt; p_obj2 = p_obj; p_obj-&gt;func(); p_obj = create_obj(); some_func(p_obj); 不要试图 delete 一个 Android 智能指针，即 delete p_obj。不要担心对象的销毁问题，智能指针的最大作用就是自动销毁不再使用的对象。不需要再使用一个对象后，直接将指针赋值为NULL即可：1p_obj = NULL; 弱指针1234wp&lt; MyClass&gt; wp_obj = new MyClass(); p_obj = wp_obj.promote(); // 升级为强指针。不过这里要用.而不是-&gt;，真是有负其指针之名啊 wp_obj = NULL; 缺点Android 智能指针用起来是很方便，在一般情况下最好使用智能指针来代替普通指针。但是需要知道一个智能指针其实是一个对象，而不是一个真正的指针，因此其运行效率是远远比不上普通指针的。所以在对运行效率敏感的地方，最好还是不要使用智能指针为好。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"2017年总结","slug":"Life/InnerPath/17-12-312017年总结","date":"2017-12-31T14:12:04.000Z","updated":"2018-11-08T01:30:40.291Z","comments":true,"path":"2017/12/31/Life/InnerPath/17-12-312017年总结/","link":"","permalink":"http://iyounix.com/2017/12/31/Life/InnerPath/17-12-312017年总结/","excerpt":"","text":"今年应该算是目标更加专注安安心心沉淀技术的一年。自从三月跳槽后，朝九晚十，大半年一眨眼就过了。还是惯例在新年伊始，总结一下去年的收获，制定一下明年的计划。 关于工作写今年在 CSDN 上发表了 28 篇技术文档，翻译了 0 篇外文，创作了 0 篇个人文章。实际上还有二十余篇技术文档 因为公司产品的保密性原因无法释放。但是总共加起来也仅有 50 篇 左右，相比去年的 67 篇技术文档、翻译 2 篇外文、12篇 个人文章，从数量上来看是有大幅的下降的。 分析原因来看，一方面个人时间被项目占据是个人文章产量为 0 的一个借口，另一方面是今年相较去年参加的展会、沙龙屈指可数。缺少了思维的碰撞与视野的拓展。可以说是有舍有得吧。 CSDN 的博客访问从 16年年底的 5万，到 17年年的 17万。增长了 12万：http://blog.csdn.net/dearsq。同时也有很多行业内的小伙伴联系到我咨询技术问题，这个成就感满满。尤其是当看到自己的所作的一些工作成果能为其他人提供方便时，还是相当开心的。 另外创办了一个微信公众号，不过实在精力有限疏于打理，写了几篇文章后就放弃了。比起 CSDN 可以直接支持 Markdown 的语法，使写者可以更专注于文章内容，微信公众号需要大量的时间进行排版。也许在以后微信公众号支持 Markdown 语法，或者是有大牛开发出一个直接将 Markdown 转微信公众号的编辑器后，可能再考虑回归吧。 做所做的项目也不像去年涉及到 Android 的很多层面。准确的说从三月底跳槽后今年只做了一个项目 ———— RK3399 的开发板。包含部分的工作，即开发其 Android 系统与 Linux 系统。 首先，从公司的角度来看，项目成功量产，老板虽然挺开心（因为利润比较高，卖一块顶其他产品十块），但是个人认为这个项目是相当失败的： 软件工程师（我）/硬件工程师个人能力不足，软件上移植调试过程中涉及到的很多部分没有了解过。从学习到实践耗费周期太长。在项目初期大大高估了人员能力和预计开发时间。 整个项目开展过程中没有用到任何项目管理的思维。部分需求纯靠拍脑门，想到啥做啥，在项目后期很多需求还在添加或删除。 项目干系人管理混乱。可能因为工作强度比较大、硬件需求不断变更、和老板产生隔阂，相继离职了两位负责的硬件，硬件前后交接了两次，涉及到三位硬件工程师，硬件文档资料都没有很好的管理，BOM表以及相关资料版本管理混乱，硬件上甚至出现第一个版本的问题，第二个版本解决，第三个版本继续出现的情况。 现在尝试复盘来看： 首先，在项目初期应该由老板或者产品经理确定需求，利用 WBS 将调试模块分解为最底层的 Leaf。将每个任务的耗时至少拆分到以周为单位。最后产出甘特图或是网络图以跟踪项目进度。 实际情况是，在项目初期仅仅用了不到一个小时遍历硬件模块列出了大致需要调试的模块，便埋头投入项目的开发。缺乏深入评估的后果就是很多功能的冲突问题在后期会爆发式的出现，比如 RK3399 只有两组 Mipi CSI，有一组已经被 HDMI-IN 功能占用，但是硬件上另外接出了两组 Camera。老板知道 RK3399 支持 HDMI-IN，支持双摄像头，但是由于缺少评估，不知道这些不能同时使用。结果就是软件兼容性问题耗费的时间没有被预算到开发周期中。 而且因为没有 WBS，导致时常跑偏，比如调试 DC 与 TypeC 充电的时候，在完成调试后发现了应用层的显示缺陷，又投入大量时间了解应用层相关的知识修改 UI。诚然了解更多的知识对工程师个人是有好处的，不过牺牲的是项目的开发时间，而且这种问题在整个项目中的优先级中应该是相当靠后的。不能任由工程师天马星空的埋头死做，要时常回头看是否和 WBS 上的主线任务相契合。 其次，项目责任分工不明确，软件开发没有话语权，HR 负责担任兼职项目经理。应该由老板放权，指明第一项目负责人是谁，他将拥有资源调度的权利。 比如在本次项目的干系人中，话语权最大的是老板，同时会承担项目前期产品经理的工作，话语权第二大的是 HR，兼职担任项目经理的工作，软件开发和硬件开发话语权最小。HR 因为对技术知之甚少，在项目中期会传达错老板的需求。从而影响项目开发的进度。同时项目资源调度也不够及时，比如有的 IC 原厂提供的代码过于老旧，会产生一些顽固的 Bug 可能耗时一周都停滞不前，老板便会勒令 Pending，从其他的模块开始调试，完成其他模块调试后又回头来调这些 Bug，需要重新恢复现场，回顾代码，这种做法相当浪费时间。我认为当遇到某颗 IC 调试有问题的时候，正确的做法应该是由项目经理立即协调 IC 厂的 FAE 或者 SoC 原厂的 FAE，及时提供支持。将难题解决，而不是不停搁置。 对于一个拥有健全完好的分工的嵌入式项目，一定可以跑得更快。 项目范围管理很糟糕。需求时常变更，变更时也没有深入调研分析这种变更是否是值得的。正确的做法前面也有说道，应该在项目初始阶段做好各个模块功能的评估工作。有规划的进行移植工作。 项目没有时间管理的概念。应该利用甘特图等工具，定好项目主干、明确以哪些功能为节点。 复盘后思路确实更加清晰了一些。在 2018 的工作中，一方面要多补充自己项目管理的知识点，一方面要将这些知识点运用到开发工作中。相信后面会越来越好的。 关于生活读今年一共读了 4 本人文书，相较去年的 18 本，确实有大幅下降。可能是因为获取知识的渠道发生改变了。因为项目上的工作比较紧，静下心来读书的时间确实难得，现在碎片化获取知识的渠道变成了 微信听书 以及 得到App。他们的共同作用都是会有人负责提炼一些书中的核心观点，然后进行分享。对于快速获取信息而言着实很方便。不过说这种方法很好，也不尽然。一则，确实太急功近利了; 二则，别人咀嚼的东西即使吃进去也是别人咀嚼的，和自己咀嚼后吞下的是完全不一样的。暂时打算明年也还是通过这种方式，在得到上订阅至少两个专栏，利用碎片时间尽量高效的扩展自己的知识面吧。另外，除了输入，最好也能输出一些，这样可能才是更加高效的。 炼今年 Keep 上一共锻炼了 600 分钟，和去年相比，相形见绌。体脂不断的增加，实在是无可奈何。虽说时间是压榨出来的，但是周日早上的懒觉真的是很难割舍啊。也许有效的方法是平常早上起早一点，适当锻炼，体质增强后睡眠质量也应该也会增加，也就不那么依赖睡眠时间了。达到一种良性循环。 财去年制定的计划，开始理财，算是完成了。一共拿了两万五，趁着行情还不错，一年赚了 5000。这么算年化收益达到了 20%，真的是人不理财，财不理人啊。缺点是太累了太浪费时间了，每天上班电梯、下班电梯、中午吃饭，都会情不自禁的掏出手机看看行情。明年也许可以在代办事项上划掉理财这一栏，把更多的精力放在对自己的提升上，因为对自己能力的投资，才是真正年化收益率最高的理财方式。 总结一转眼毕业两年半，感觉时间越走越快。回头看看，自己对不对得起 2017 的自己呢，说不上来。总之 2018, 继续加油。一切都会更好的。","categories":[],"tags":[{"name":"InnerPath","slug":"InnerPath","permalink":"http://iyounix.com/tags/InnerPath/"}]},{"title":"Linux RK3399 RK Linux 平台启动过程（5个阶段）详解","slug":"Linux/[Linux][RK3399] RK Linux 平台启动过程（5个阶段）详解","date":"2017-12-30T22:06:06.000Z","updated":"2018-11-08T01:52:50.022Z","comments":true,"path":"2017/12/31/Linux/[Linux][RK3399] RK Linux 平台启动过程（5个阶段）详解/","link":"","permalink":"http://iyounix.com/2017/12/31/Linux/[Linux][RK3399] RK Linux 平台启动过程（5个阶段）详解/","excerpt":"","text":"Hardware Platform: RK3399 [TOC] Boot Stage包括两种启动方式：一、U-Boot SPL二、RK idbLoader （由 RK DDR init bin 和 miniloader bin 组成） 所以从不同介质（eMMC / SD Card / U-Disk / net）启动的时候，实际上是不同的概念： Stage 1 在芯片内固化的 Boot ROM 中。它将引导启动 Stage 2 ，有可能引导 Stage 3（仅当使能 SPL_BACK_TO_BROM 选项的时候）。 从 eMMC 或 SDCard 启动的时候，所有固件（stage 2,3,4,5）都在 eMMC 或 SD Card。 从 SPI Flash 启动的时候，stage 2 和 stage 3（只有 SPL 和 U-Boot）在 SPI Flash 中，stage 4 和 stage 5 在其他的地方。 从 U-Disk 启动的时候，stage 4 和 stage 5（不包括 SPL 和 U-boot）是在 U-Disk 中的，只有 5 可供选择。 从 net/tftp 启动的时候，stage 4 和 stage 5（不包括 SPL 和 U-boot）是在 网络 上的。 Package Option 下面是 stage 2～4 package 的 file list。 从源码编译出来的： U-Boot 编译出 u-boot-spl.bin, u-boot.bin(可以用 u-boot-nodtb.bin 和 u-boot.dtb 替代） Kernel 编译出 kernel Image/zImage, kernel dtb ATF 编译出 bl31.bin 从 rkbin 文件夹中提供的： ddr、usbplug、miniloader、bl31 idbspl.img这个 img 是 U-Boot SPL, SPL_BACK_TP_BROM 选项禁能。1./tools/mkimage -n rkxxxx -T rksd -d spl/u-boot-spl.bin idbspl.img 将 idbspl.img 烧写到偏移地址 0x40 处，在此引导 stage 2 ，还需要烧写 stage 3 的 image 到 0x200 (由 CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR 定义)。Stage 3 image 可能只需要 u-boot.bin (如果没有 ATF 要求，比如 armv7), 或者 FIT image bl3.itb(对于从 SPL 加载的 ATF，包括了bl31.bin, u-boot-nodtb.bin and u-boot.dtb)。 idbloader.img这个 img 是 U-Boot SPL, SPL_BACK_TP_BROM 选项使能。前面有说，如果使能，就会引导 Stage 3。12./tools/mkimage -n rkxxxx -T rksd -d spl/u-boot-spl.bin idbloader.imgcat u-boot.bin &gt;&gt; idbloader.img 接下来烧录 idbloader.img 到偏移地址 0x40 处，就会启动 stage 2 和 stage 3。从 rkbin 中打包镜像：1234dd if=rkxx_ddr_vx.xx.bin of=ddr.bin bs=4 skip=1./tools/mkimage -n rkxxxx -T rksd -d ddr.bin idbloader.imgrm ddr.bincat rkxx_miniloader_vx.xx.bin &gt;&gt; idbloader.img 烧录 idbloader.img 到偏移地址 0x40 处，下面你会需要用以启动 stage 3 的 uboot.img。 bl3.itb当使用 SPL 来加载 ATF，打包 bl31.bin ,u-boot-nodtb.bin , uboot.dtb 到 one FIT image1./tools/mkimage -f fit4spl.its -E bl3.itb 烧写 bl3.itb 到偏移位置 0x200 处，它依赖于 烧录到 0x40 的 idbspl.img uboot.img当使用 来自 RK miniloader 的 idbLoader 时，需要通过 Rockchip 工具 loaderimage 将 u-boot.bin 打包成 miniloader 的可加载格式。1./tools/loaderimage --pack --uboot u-boot.bin uboot.img 将 uboot.img 烧录到 0x4000， stage 3。. trust.img当使用 idbLoader 时，为了使用 miniloader，需要通过 Rockchip 工具 trustmerge 将 bl31.bin 打包成 miniloader 的可加载格式。1./tools/trustmerge tools/rk_tools/RKTRUST_RKXXXXTRUST.ini 将 trust.img 烧录到 0x6000，为了使用 miniloader。 rkxx_loader_vx.xx.xxx.bin这个 bin 文件是 RK 以二进制文件提供，是用来以 upgrade_tool 或是 rkdeveloptool 工具 进行 eMMC 烧录的时候使用的。它打包了 ddr.bin，usbplug.bin，miniloader.bin。RK 烧录工具的 DB 命令可以让 usbplug.bin 在已经处于 Rockusb mode 的目标设备上运行。 boot.imgboot.img 将 kernel image 和 dtb 文件的打包成一个已知的文件系统。它将被烧录在 0x8000，stage 4。 rootfs.img烧录 rootfs.img 到 0x40000，stage 5。 12345678910111213141516171819202122232425262728293031st=&gt;start: BootROMrootfs=&gt;end: rootfs0x40000spl=&gt;condition: SPL_BACK_TP_BROMidbloader=&gt;operation: idbloader.imgspl/u-boot-spl.bin + u-boot.bin0x40idbspl=&gt;operation: idbspl.imgspl/u-boot-spl.bin0x40uboot=&gt;operation: uboot.img0x4000trust=&gt;operation: trust.img0x6000bl3=&gt;operation: bl3.itbbl3.bin + u-boot-nodtb.bin + uboot.dtb0x4000boot=&gt;end: boot.img0x8000st-&gt;splspl(yes)-&gt;idbloaderspl(no)-&gt;idbsplidbloader-&gt;uboot-&gt;trust-&gt;bootidbspl-&gt;bl3-&gt;bootboot-&gt;rootfs 不同选择情况下的 Image 准备对于 armv8 采用 SPL：idbspl.imgbl3.itbboot.img or boot folder with Image, dtb and exitlinulx insiderootfs.img 对于 armv8 采用 miniloader：idbLoader.imguboot.imgtrust.imgboot.img or boot folder with Image, dtb and exitlinulx insiderootfs.img 从 eMMC 启动 我们需要进入 maskrom 模式 usb 线连接开发板和主机 烧录 image 到 eMMC 实例：123# 最开始烧录 loader 和 gpt 分区参数rkdeveloptool db rk3399_loader_v1.08.106.binrkdeveloptool gpt parameter_gpt.txt 对于 armv8 使用 SPL：123456rkdeveloptool db rk3399_loader_v1.08.106.binrkdeveloptool wl 0x40 idbspl.imgrkdeveloptool wl 0x200 bl3.itbrkdeveloptool wl 0x8000 boot.imgrkdeveloptool wl 0x40000 rootfs.imgrkdeveloptool rd 对于 armv8 使用 miniloader：1234567rkdeveloptool db rk3399_loader_v1.08.106.binrkdeveloptool wl 0x40 idbloader.imgrkdeveloptool wl 0x4000 uboot.imgrkdeveloptool wl 0x6000 trust.imgrkdeveloptool wl 0x8000 boot.imgrkdeveloptool wl 0x40000 rootfs.imgrkdeveloptool rd 从 SD/TF Card 启动//TODO 从 U-Disk 启动//TODO 从 Network 启动//TODO","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"Linux RK3399 移植蓝牙驱动","slug":"Linux/[Linux][RK3399] 移植蓝牙驱动","date":"2017-12-30T22:06:06.000Z","updated":"2018-11-08T01:52:18.050Z","comments":true,"path":"2017/12/31/Linux/[Linux][RK3399] 移植蓝牙驱动/","link":"","permalink":"http://iyounix.com/2017/12/31/Linux/[Linux][RK3399] 移植蓝牙驱动/","excerpt":"","text":"参考文章：http://blog.csdn.net/linuxheik/article/details/51924026[TOC] 内核配置[] Networking support —&gt;&lt;&gt; Bluetooth subsystem support —&gt; //蓝牙子系统必须选择&lt;&gt; L2CAP protocol suppor//逻辑链路控制和适配协议。&lt;&gt; SCO links support//蓝牙语音和耳机支持&lt;&gt; RFCOMM protocol suppor//面向流的传输协议，支持拨号网络等[] RFCOMM TTY support&lt;&gt; BNEP protocol support //蓝牙网络封装协议，自组网支持[] Multicast filter support //蓝牙多播，支持支持BNEP[] Protocol filter support //蓝牙多播，支持支持支持BNEP&lt;&gt; HIDP protocol support//基本支持协议Bluetooth device drivers —&gt;&lt;*&gt; HCI USB driver//USB蓝牙模块支持 HCI UART driver//基于串口，CF卡或PCMCIA的蓝牙&lt;&gt; HCI BlueFRITZ! USB driver&lt;&gt; HCI VHCI (Virtual HCI device) driver其余的选项，根据自己的蓝牙设备进行调整。 [B] 蓝牙协议栈移植a) 需要的软件包可以在http://sourcearchive.com/下载多用到的所有软件包 (1) D-Bus library 提供简单的应用程序互相通讯下载地址：http://www.freedesktop.org/wiki/Software/dbus#Download (2) GLib library GLib是GTK+和GNOME工程的基础底层核心程序库，是一个综合用途的实用的轻量级的C程序库，它提供C语言的常用的数据结构的定义、相关的处理函数，有趣而实用的宏，可移植的封装和一些运行时机能，如事件循环、线程、动态调用、对象系统等的API。它能够在类UNIX的操作系统平台（如linux， HP-UNIX等），WINDOWS，OS2和BeOS等操作系统台上运行。下载地址：http://ftp.gnome.org/pub/gnome/sources/glib/2.26/(3) USB library (optional) 是一个用c语言开发的跨平台的USB设备访问接口库。下载地址：http://www.libusb.org/(4) Lexical Analyzer (flex或 lex) 词法分析器下载地址：http://linux.softpedia.com/get/Programming/Interpreters/Flex-23296.shtml(5)YACC (yacc, bison, byacc) Unix/Linux上一个用来生成编译器的编译器(编译器代码生成器)下载地址：http://invisible-island.net/byacc/byacc.html(6) alsa-libALSA 应用下载地址：http://www.alsa-project.org/b) 解压编译在编译之前，首先将下载的所有包都放在 bluetooth 文件夹下。并在该文件夹下建立 bluetooth-build 文件夹，并将其输出到环境变量。 #cd Bluetooth #mkdir bluetooth-build #blue=$PWD/bluetooth-build #export blue #export //检查是否包含blue环境变量(1) 编译 alsa-lib 库 #tar -jxvf alsa-lib-1.0.24.1.tar.bz2 #cd alsa-lib-1.0.24.1 #./configure –prefix=$blue CC=arm-linux-gcc –host=arm-linux –disable-Python #make #make install(2) 编译 expat #tar –zxvf expat-2.0.1.tar.gz #cd expat-2.0.1 #./configure –prefix=$blue CC=”arm-linux-gcc -I$blue/include -L$blue/lib “ –host=arm-linux #make #make install(3) D-Bus #tar dbus-1.4.1.tar.gz #cd dbus-1.4.1配置configure: #echo ac_cv_have_abstract_sockets=yes&gt;arm-linux.cache #./configure –prefix=$blue CC=”arm-linux-gcc -I$blue/include -L$blue/lib “ –host=arm-linux–cache-file=arm-linux.cache –with-x=no(4) 编译 glib 库 #vi arm-linux.cache在其中输入如下内容：glib_cv_long_long_format=llglib_cv_stack_grows=noglib_cv_working_bcopy=noglib_cv_sane_realloc=yesglib_cv_have_strlcpy=noglib_cv_va_val_copy=yesglib_cv_rtldglobal_broken=noglib_cv_uscore=noac_cv_func_posix_getpwuid_r=yesac_cv_func_nonposix_getpwuid_r=noac_cv_func_posix_getgrgid_r=noglib_cv_use_pid_surrogate=noac_cv_func_printf_unix98=noac_cv_func_vsnprintf_c99=noac_cv_path_GLIB_COMPILE_SCHEMAS=yes或者不建立arm-linux.chach文件，直接输入如下命令也可以：echo glib_cv_long_long_format=ll&gt;arm-linux.cacheecho glib_cv_stack_grows=no&gt;&gt;arm-linux.cacheecho glib_cv_working_bcopy=no&gt;&gt;arm-linux.cacheecho glib_cv_sane_realloc=yes&gt;&gt;arm-linux.cacheecho glib_cv_have_strlcpy=no&gt;&gt;arm-linux.cacheecho glib_cv_va_val_copy=yes&gt;&gt;arm-linux.cacheecho glib_cv_rtldglobal_broken=no&gt;&gt;arm-linux.cacheecho glib_cv_uscore=no&gt;&gt;arm-linux.cacheecho ac_cv_func_posix_getpwuid_r=yes&gt;&gt;arm-linux.cacheecho ac_cv_func_nonposix_getpwuid_r=no&gt;&gt;arm-linux.cacheecho ac_cv_func_posix_getgrgid_r=no&gt;&gt;arm-linux.cacheecho glib_cv_use_pid_surrogate=no&gt;&gt;arm-linux.cacheecho ac_cv_func_printf_unix98=no&gt;&gt;arm-linux.cacheecho ac_cv_func_vsnprintf_c99=no&gt;&gt;arm-linux.cacheecho ac_cv_path_GLIB_COMPILE_SCHEMAS=yes&gt;&gt;arm-linux.cache 然后保存退出。如果不创建该文件，编译总出现…can’t run test program …错误 #./configure –prefix=$blue CC=”arm-linux-gcc -I$blue/include -L$blue/lib “ –host=arm-linux –cache-file=arm-linux.cache如果继续出错，记录下提示error错误行的上一行，如：checking abstract socket namespace…configure: error: cannot run test program while cross compiling注意到abstract socket namespace在configure中查找abstract socket可以看到类似这样的结构echo “$as_me:$LINENO: checking abstract socket namespace” &gt;&amp;5echo $ECHO_N “checking abstract socket namespace… $ECHO_C” &gt;&amp;6if test “${ac_cv_have_abstract_sockets+set}” = set; thenecho $ECHO_N “(cached) $ECHO_C” &gt;&amp;6其中ac_cv_have_abstract_sockets是我们要查找的变量。然后在当前目录下的arm-linux.cache中加入：echo ac_cv_have_abstract_sockets=yes #make出现如下错误：(process:18811): GLib-Genmarshal-WARNING : unknown type: VARIANTmake[2]: * [stamp-gmarshal.h] 错误 1make[2]: Leaving directory /root/mywork/mini2440/bluetooth/glib-2.26.0/gobject&#39; make[1]: *** [all-recursive] 错误 1 make[1]: Leaving directory/root/mywork/mini2440/bluetooth/glib-2.26.0’make: *** [all] 错误 2出现如上错误好像是文件格式错误引起的。解决办法如下：第一次出错：将其中唯一的一行注释掉！ #vi gobject/stamp-gmarshal.h第二次出错：将如下文件的开头空行删除。 #vi gobject/gmarshal.c这时候，继续编译就通过了。！ #vi tests/gobject/stamp-testmarshal.h什么也不输入，保存退出即可。(5) 编译 bluez #tar -zxvf bluez-4.87.tar.gz #cd bluez-4.87 ./configure –prefix=$blue CC=”arm-linux-gcc -I$blue/include -L$blue/lib “ –host=arm-linux#make #make install编译顺利，没初现错误。(6) 编译YACC #tar -zxvf byacc.tar.gz #cd byacc-20101127 ./configure –prefix=$blue CC=”arm-linux-gcc -I$blue/include -L$blue/lib “ –host=arm-linux#make #make install(7) 编译USB library #tar -zxvf libusb-1.0.8.tar.bz2 #cd libusb-1.0.8 ./configure –prefix=$blue CC=”arm-linux-gcc -I$blue/include -L$blue/lib “ –host=arm-linux#make #make install至此，所有的软件包都编译完成！(8) 复制生成的软件到开发板1) 将bluetooth-build/sbin下的文件复制到开发板的/sbin下 #cp bluetooth-build/sbin/* ROOTFS/sbin //ROOTFS自己指定 #cp bluetooth-build/bin/hcitool ROOTFS/bin/ #cp bluetooth-build/bin/rfcomm ROOTFS/bin/ #cp bluetooth-build/bin/sdptool ROOTFS/bin/ 2) 复制相关的库到开发板的/lib下 #cp Bluetooth-build/lib/libbluetooth* ROOTFS/lib //ROOTFS自己指定3) 复制配置文件到开发板的/etc目录下 #cp -arf bluetooth-build/etc/bluetooth/ ROOTFS/etc/ //ROOTFS自己指定 [C] 蓝牙测试1．检查是否有蓝牙设备在插入蓝牙到到USB口前后，用 lsusb 命令可以发现输出内容不一样。即插入蓝牙设备后 lsusb 输出多了一行。然后，运行 hciconfig 可以看到： #hciconfighci0: Type: BR/EDR Bus: USB BD Address: 00:00:00:00:00:00 ACL MTU: 0:0 SCO MTU: 0:0 DOWN RX bytes:0 acl:0 sco:0 events:0 errors:0 TX bytes:0 acl:0 sco:0 commands:0 errors:0上面的信息说明检测到了蓝牙设备hci0。2．激活蓝牙设备 #hciconfig hci0 up可以激活借口(这一步不做，hcitool scan无法运行) 。这时候如果再次执行hciconfg命令，可以发现蓝牙以及激活(UP RUNNING)：hci0: Type: BR/EDR Bus: USB BD Address: 00:1F:81:00:02:DD ACL MTU: 1021:4 SCO MTU: 180:1 UP RUNNING RX bytes:342 acl:0 sco:0 events:10 errors:0 TX bytes:33 acl:0 sco:0 commands:11 errors:13．扫描设备 #hcitool scan可以得到：Scanning … 00:23:7A:F3:66:8D BlackBerry 9000 这就是搜索到的设备（提前打开哦）4．修改配置文件：修改/etc/bluetooth/rfcomm.conf将里面的：device 11:22:33:44:55:66;修改成hcitool scan的结果，也就是：device 00:23:7A:F3:66:8D保存退出。rfcomm_create_dev。5．创建蓝牙设备运行： #rfcomm_create_dev。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"Linux RK3399 ISP 矫正算法的移植","slug":"Linux/[Linux][RK3399] ISP 矫正算法的移植","date":"2017-12-30T22:06:06.000Z","updated":"2018-11-08T01:52:57.754Z","comments":true,"path":"2017/12/31/Linux/[Linux][RK3399] ISP 矫正算法的移植/","link":"","permalink":"http://iyounix.com/2017/12/31/Linux/[Linux][RK3399] ISP 矫正算法的移植/","excerpt":"","text":"OS:Debian9Hardware:RK3399 [TOC] 一、搭建编译环境1. 首先需要搭建 Gstreamer 环境1$ sudo apt install -y bison flex libffi-dev libmount-dev libpcre3 libpcre3-dev zlib1g-dev libssl-dev gtk-doc-tools build-essential libtool libdrm-dev 2. 安装移植过程中的工具如果你是刚搭建好的 OS，可能会碰到一些工具依赖的问题。罗列如下： 1）xz 解压工具1# apt install xz-utils 2）automake 工具比如出现如下错误：./autogen.sh: 11: ./autogen.sh: autoreconf: not found1# apt install autoconf automake autopoint 2. 安装 ORC 支持库在编译 gst-plugins-base 的时候会依赖这个库1234567891011mkdir ISP_3A_Portingcd ISP_3A_Portingwget https://gstreamer.freedesktop.org/src/orc/orc-0.4.27.tar.xz --no-check-certificatexz -d orc-0.4.27.tar.xztar -xvf orc-0.4.27.tarcd orc-0.4.27./autogen.sh --prefix=/usrmakemake install 3. 安装 GLIB 支持库1234567wget http://ftp.acc.umu.se/pub/GNOME/sources/glib/2.52/glib-2.52.3.tar.xz# xz -d glib-2.52.3.tar.xz# tar xvf glib-2.52.3.tar # cd glib-2.52.3 # ./autogen.sh # make # make install GLIB 所依赖的包在 ./autogen.sh 时123configure: error: *** You must have either have gettext support in your C library, or use the*** GNU gettext library. (http://www.gnu.org/software/gettext/gettext.html 需要1apt install gettext 4. 安装 Gstreamer 程序包https://gstreamer.freedesktop.org/src/ 12mkdir gstreamercd gstreamer 1234567wget https://gstreamer.freedesktop.org/src/gstreamer/gstreamer-1.12.2.tar.xzxz -d gstreamer-1.12.2.tar.xztar -xvf gstreamer-1.12.2.tarcd gstreamer-1.12.2./autogen.sh make make install 1234567wget https://gstreamer.freedesktop.org/src/gst-plugins-base/gst-plugins-base-1.12.2.tar.xzxz -d gst-plugins-base-1.12.2.tar.xztar -xvf gst-plugins-base-1.12.2.tarcd gst-plugins-base-1.12.2./autogen.sh make make install 1234567wget https://gstreamer.freedesktop.org/src/gst-plugins-good/gst-plugins-good-1.12.2.tar.xzxz -d gst-plugins-good-1.12.2.tar.xztar -xvf gst-plugins-good-1.12.2.tarcd gst-plugins-good-1.12.2./autogen.sh make make install 1234567wget https://gstreamer.freedesktop.org/src/gst-plugins-bad/gst-plugins-bad-1.12.2.tar.xzxz -d gst-plugins-bad-1.12.2.tar.xztar -xvf gst-plugins-bad-1.12.2.tarcd gst-plugins-bad-1.12.2./autogen.sh make make install 1234567wget https://gstreamer.freedesktop.org/src/gst-plugins-ugly/gst-plugins-ugly-1.12.2.tar.xzxz -d gst-plugins-ugly-1.12.2.tar.xztar -xvf gst-plugins-ugly-1.12.2.tarcd gst-plugins-ugly-1.12.2./autogen.sh make make install 5. 安装使用 Gstreamer rkisp elemennt在开发板上解压并安装 Gstreamer 的 插件 camera-isp-gstreamer-v1.1.2.tar.gz12345tar -zxvf camera-isp-gstreamer-v1.1.2.tar.gzcd camera-app-gstreamer./autogen.sh --prefix=/usr/local --enable-gst --enable-rkiqmakemake install 1234567891011121314version : 1.1.1enable debug : noenable profiling : nobuild GStreamer plugin : yesbuild aiq analyzer : nouse local aiq : nouse local atomisp : yeshave opencl lib : yeshave opencv lib : noenable 3a lib : noenable smart analysis lib : noenable dvs : noenable libxcam-capi lib : yesenable lib : yes 解决缺少 libdrm-dev 的问题：**make[2]: Entering directory ‘/home/linaro/Desktop/camera-app-gstreamer/xcore’drm_display.h:30:17: fatal error: drm.h: No such file or directory #include &lt;drm.h&gt;** 这实际上是因为 libdrm 没有安装导致的：1apt install libdrm-dev ####1234567891011121314151617root@linaro-alip:/home/linaro/Desktop/camera-app-gstreamer# makemake all-recursivemake[1]: Entering directory &apos;/home/linaro/Desktop/camera-app-gstreamer&apos;Making all in xcoremake[2]: Entering directory &apos;/home/linaro/Desktop/camera-app-gstreamer/xcore&apos;/bin/bash ../libtool --tag=CXX --mode=link g++ -fPIC -DSTDC99 -W -Wall -D_REENTRANT -Wformat -Wformat-plibtool: link: g++ -fPIC -DPIC -shared -nostdlib /usr/lib/gcc/arm-linux-gnueabihf/6/../../../arm-linux-g1../ext/rkisp/lib/librkisp.so: file not recognized: File format not recognizedcollect2: error: ld returned 1 exit statusMakefile:583: recipe for target &apos;libxcam_core.la&apos; failedmake[2]: *** [libxcam_core.la] Error 1make[2]: Leaving directory &apos;/home/linaro/Desktop/camera-app-gstreamer/xcore&apos;Makefile:427: recipe for target &apos;all-recursive&apos; failedmake[1]: *** [all-recursive] Error 1make[1]: Leaving directory &apos;/home/linaro/Desktop/camera-app-gstreamer&apos;Makefile:359: recipe for target &apos;all&apos; failedmake: *** [all] Error 2 这是因为 RK 提供的 librkisp.so 的编译环境和我们不一样。需要提供我们的编译工具 arm-linux-gnueabihf 给他们，重新编译一份 librkisp.so 给我们。 PS: ubuntu 下的编译工具为 /usr/lib/gcc/aarch64-linux-gnu 使用重新编译后的 librkisp.so 后问题解决。 opencl 依赖问题需要参照 https://www.freedesktop.org/wiki/Software/Beignet/ ####dpkg: error processing archive /var/cache/apt/archives/ocl-icd-opencl-dev_2.2.11-1_armhf.deb (–unpack): trying to overwrite ‘/usr/lib/arm-linux-gnueabihf/pkgconfig/OpenCL.pc’, which is also in package libmali-rk-dev:armhf 1.5-6Errors were encountered while processing: /var/cache/apt/archives/ocl-icd-opencl-dev_2.2.11-1_armhf.debE: Sub-process /usr/bin/dpkg returned an error code (1) 1apt remove libmali-rk ####dpkg: error processing archive /var/cache/apt/archives/ocl-icd-opencl-dev_2.2.11-1_armhf.deb (–unpack): trying to overwrite ‘/usr/lib/arm-linux-gnueabihf/libOpenCL.so’, which is also in package libmali-rk-midgard-t86x-r14p0:armhf 1.5-6Errors were encountered while processing: /var/cache/apt/archives/ocl-icd-opencl-dev_2.2.11-1_armhf.deb 1apt remove libmali-rk-midgard-t86x-r14p0 #### root@firefly:~# ldconfig -p | grep isp liburl-dispatcher.so.1 (libc6,AArch64) =&gt; /usr/lib/aarch64-linux-gnu/liburl-dispatcher.so.1 libnss_nisplus.so.2 (libc6,AArch64, OS ABI: Linux 3.7.0) =&gt; /lib/aarch64-linux-gnu/libnss_nisplus2 libnss_nisplus.so (libc6,AArch64, OS ABI: Linux 3.7.0) =&gt; /usr/lib/aarch64-linux-gnu/libnss_nisploroot@firefly:~#root@firefly:~#root@firefly:~# ldconfig -p | grep atom libatomic.so.1 (libc6,AArch64) =&gt; /usr/lib/aarch64-linux-gnu/libatomic.so.1 如果开发板没有环境，可以在主机上进行交叉编译：12export PATH=/path/to/cross-compiler:$PATH CC=aarch64-linux-gcc ./autogen.sh --prefix=/home/out --host=aarch64-linux --enable-gst --enable-rkiq configure:3124: checking for aarch64-linux-gccconfigure:3151: result: aarch64-linux-gccconfigure:3420: checking for C compiler versionconfigure:3429: aarch64-linux-gcc –version &gt;&amp;5./configure: line 3431: aarch64-linux-gcc: command not found1CC=aarch64-linux-gnu-gcc ./autogen.sh --prefix=/home/younix/rk-linux/rootfs/camera-app-gstreamer/out --host=aarch64-linux-gnu --enable-gst --enable-rkiq 遇到问题1234567891011121314151617181920212223242526272829303132333435YounixPC# makemake all-recursivemake[1]: Entering directory &apos;/home/younix/rk-linux/rootfs/camera-app-gstreamer&apos;Making all in xcoremake[2]: Entering directory &apos;/home/younix/rk-linux/rootfs/camera-app-gstreamer/xcore&apos;/bin/bash ../libtool --tag=CXX --mode=link g++ -fPIC -DSTDC99 -W -Wall -D_REENTRANT -Wformat -Wformat-security -fstack-protector -std=c++0x -I/usr/include/libdrm -I../ext/rkisp/include -g -O2 -no-undefined -version-number 1:1:1 -pthread -o libxcam_core.la -rpath /home/younix/rk-linux/rootfs/camera-app-gstreamer/out/lib libxcam_core_la-analyzer_loader.lo libxcam_core_la-smart_analyzer_loader.lo libxcam_core_la-buffer_pool.lo libxcam_core_la-device_manager.lo libxcam_core_la-pipe_manager.lo libxcam_core_la-dma_video_buffer.lo libxcam_core_la-dynamic_analyzer.lo libxcam_core_la-dynamic_analyzer_loader.lo libxcam_core_la-smart_analyzer.lo libxcam_core_la-smart_analysis_handler.lo libxcam_core_la-smart_buffer_priv.lo libxcam_core_la-fake_poll_thread.lo libxcam_core_la-handler_interface.lo libxcam_core_la-image_processor.lo libxcam_core_la-image_projector.lo libxcam_core_la-image_file_handle.lo libxcam_core_la-poll_thread.lo libxcam_core_la-swapped_buffer.lo libxcam_core_la-uvc_device.lo libxcam_core_la-v4l2_buffer_proxy.lo libxcam_core_la-v4l2_device.lo libxcam_core_la-video_buffer.lo libxcam_core_la-xcam_analyzer.lo libxcam_core_la-x3a_analyzer.lo libxcam_core_la-x3a_analyzer_manager.lo libxcam_core_la-x3a_analyzer_simple.lo libxcam_core_la-x3a_image_process_center.lo libxcam_core_la-x3a_stats_pool.lo libxcam_core_la-x3a_result.lo libxcam_core_la-x3a_result_factory.lo libxcam_core_la-xcam_common.lo libxcam_core_la-xcam_buffer.lo libxcam_core_la-xcam_thread.lo libxcam_core_la-x3a_analyze_tuner.lo libxcam_core_la-x3a_ciq_tuning_handler.lo libxcam_core_la-x3a_ciq_tnr_tuning_handler.lo libxcam_core_la-x3a_ciq_bnr_ee_tuning_handler.lo libxcam_core_la-x3a_ciq_wavelet_tuning_handler.lo libxcam_core_la-drm_bo_buffer.lo libxcam_core_la-drm_display.lo libxcam_core_la-drm_v4l2_buffer.lo -ldl -lpthread -ldrm -L../ext/rkisp/lib -lrkisp -L../ext/rkisp/lib -lrkisplibtool: link: g++ -fPIC -DPIC -shared -nostdlib /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/5/crtbeginS.o .libs/libxcam_core_la-analyzer_loader.o .libs/libxcam_core_la-smart_analyzer_loader.o .libs/libxcam_core_la-buffer_pool.o .libs/libxcam_core_la-device_manager.o .libs/libxcam_core_la-pipe_manager.o .libs/libxcam_core_la-dma_video_buffer.o .libs/libxcam_core_la-dynamic_analyzer.o .libs/libxcam_core_la-dynamic_analyzer_loader.o .libs/libxcam_core_la-smart_analyzer.o .libs/libxcam_core_la-smart_analysis_handler.o .libs/libxcam_core_la-smart_buffer_priv.o .libs/libxcam_core_la-fake_poll_thread.o .libs/libxcam_core_la-handler_interface.o .libs/libxcam_core_la-image_processor.o .libs/libxcam_core_la-image_projector.o .libs/libxcam_core_la-image_file_handle.o .libs/libxcam_core_la-poll_thread.o .libs/libxcam_core_la-swapped_buffer.o .libs/libxcam_core_la-uvc_device.o .libs/libxcam_core_la-v4l2_buffer_proxy.o .libs/libxcam_core_la-v4l2_device.o .libs/libxcam_core_la-video_buffer.o .libs/libxcam_core_la-xcam_analyzer.o .libs/libxcam_core_la-x3a_analyzer.o .libs/libxcam_core_la-x3a_analyzer_manager.o .libs/libxcam_core_la-x3a_analyzer_simple.o .libs/libxcam_core_la-x3a_image_process_center.o .libs/libxcam_core_la-x3a_stats_pool.o .libs/libxcam_core_la-x3a_result.o .libs/libxcam_core_la-x3a_result_factory.o .libs/libxcam_core_la-xcam_common.o .libs/libxcam_core_la-xcam_buffer.o .libs/libxcam_core_la-xcam_thread.o .libs/libxcam_core_la-x3a_analyze_tuner.o .libs/libxcam_core_la-x3a_ciq_tuning_handler.o .libs/libxcam_core_la-x3a_ciq_tnr_tuning_handler.o .libs/libxcam_core_la-x3a_ciq_bnr_ee_tuning_handler.o .libs/libxcam_core_la-x3a_ciq_wavelet_tuning_handler.o .libs/libxcam_core_la-drm_bo_buffer.o .libs/libxcam_core_la-drm_display.o .libs/libxcam_core_la-drm_v4l2_buffer.o -ldl -lpthread -ldrm -L../ext/rkisp/lib -lrkisp -L/usr/lib/gcc/x86_64-linux-gnu/5 -L/usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/5/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/5/../../.. -lstdc++ -lm -lc -lgcc_s /usr/lib/gcc/x86_64-linux-gnu/5/crtendS.o /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crtn.o -fstack-protector -g -O2 -pthread -pthread -Wl,-soname -Wl,libxcam_core.so.1 -o .libs/libxcam_core.so.1.1.1/usr/bin/ld: skipping incompatible ../ext/rkisp/lib/librkisp.so when searching for -lrkisp/usr/bin/ld: cannot find -lrkispcollect2: error: ld returned 1 exit statusMakefile:583: recipe for target &apos;libxcam_core.la&apos; failedmake[2]: *** [libxcam_core.la] Error 1make[2]: Leaving directory &apos;/home/younix/rk-linux/rootfs/camera-app-gstreamer/xcore&apos;Makefile:427: recipe for target &apos;all-recursive&apos; failedmake[1]: *** [all-recursive] Error 1make[1]: Leaving directory &apos;/home/younix/rk-linux/rootfs/camera-app-gstreamer&apos;Makefile:359: recipe for target &apos;all&apos; failedmake: *** [all] Error 2","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"Linux RK3399 以太网调试 — 利用 ping 和 pathping 工具","slug":"Linux/[Linux][RK3399] 以太网调试 — 利用 ping 和 pathping 工具","date":"2017-12-30T22:06:06.000Z","updated":"2018-11-08T01:52:33.406Z","comments":true,"path":"2017/12/31/Linux/[Linux][RK3399] 以太网调试 — 利用 ping 和 pathping 工具/","link":"","permalink":"http://iyounix.com/2017/12/31/Linux/[Linux][RK3399] 以太网调试 — 利用 ping 和 pathping 工具/","excerpt":"","text":"网络配置Redhat 的配置在 /etc/sysconfig/network-scripts/ifcfg-eth0Debian 的配置在 /etc/network/interfaces差异有点大，我的板子是采用的 Debian这里以 Debian 为例 网络配置有三个方法 DHCP 动态 static 静态 图形界面配置 因为我们板子和主机连的是同一个网关。先在主机 ifconfig 看一下自己主机所在的网络的相关信息12345678enp2s0 Link encap:以太网 硬件地址 1c:1b:0d:b3:64:d5 inet 地址:192.168.1.130 广播:192.168.1.255 掩码:255.255.255.0 inet6 地址: fe80::1bbe:be89:15eb:3083/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 跃点数:1 接收数据包:1164966 错误:0 丢弃:0 过载:0 帧数:0 发送数据包:557220 错误:0 丢弃:0 过载:0 载波:0 碰撞:0 发送队列长度:1000 接收字节:1400257775 (1.4 GB) 发送字节:60841335 (60.8 MB) 提取出来的信息有Host ip address 192.168.1.130Gatway address 192.168.1.1Broadcast address 192.168.1.255Netmask 255.255.255.0可以按照主机上的信息来配置板子。 DHCP修改配置文件 /etc/network/interfaces12auto eth0 iface eth0 inet dhcp 重启开发板，或者 如下 重启网络服务1sudo /etc/init.d/networking restart Static IP Address修改配置文件 /etc/network/interfaces1234567auto eth0iface eth0 inet staticaddress 192.168.1.66network 192.168.1.0netmask 255.255.255.0broadcast 192.168.1.255gateway 192.168.1.1 重启开发板，或者 如下 重启网络服务1sudo /etc/init.d/networking restart 图形界面 图形界面用到的情况不多，就不赘述了。 更加有详细的配置方法参见这篇文章http://blog.sina.com.cn/s/blog_722e57150100nhz9.html 调试步骤参考 https://technet.microsoft.com/en-us/library/cc940095.aspx 利用 Ping 和 PingPath 来测试网络连接。Ping 用来验证 IP-level 的连通性。PathPing 用来检测 multiple-hop trips 时包是否有 loss。 故障排除后，ping 命令用来发送一个 ICMP 回应请求到目标 host name 或是 IP Address。用 Ping 命令来验证 主机能否正常向目标机发包，也可以用它来区分网络硬件问题和不兼容配置问题。 如果使用了 ipconfig /all 并且接收到了响应，没有必要再 ping 回环地址 和 自己的 IP 地址 —— ipconfig 为了产生报告已经这么去做了。 要使用 Ping 命令可以按照如下步骤： ping 回环地址 loopback addressping 127.0.0.1如果环回步失败，则IP堆栈不响应。这可能是因为TCP驱动程序损坏，网络适配器可能无法正常工作，或其他服务与IP冲突。 ping 本地计算机的 IP 地址 local ip address验证它是否已经正确地添加到网络中。如果路由表是正确的，这只是将数据包转发到 127.0.0.1 回环地址。12# ping &lt;IP address of local host&gt;ping 192.168.1.88 ping 默认网关 IP 地址验证默认网关是否运行，本地是否能与本地网络上的其他主机进行通信。12# ping &lt;Gateway address&gt;ping 192.168.1.1 ping 远程主机 IP 地址验证可以通过路由器进行通信1# ping &lt;Remote IP address&gt; ping 远程主机名验证可以正确解析远程主机名12# ping &lt;Remote Host Name&gt;ping www.baidu.com pathping 远程主机 IP验证到远程主机所经过的 中间路由器是否运行正常。1# pathping &lt;Remote IP address&gt; 错误归纳本地地址返回 0.0.0.0微软MediaSense软件启动，因为网络适配器检测到它没有连接到网络。要解决此问题，通过确保网络适配器和网络电缆连接到集线器关闭MediaSense。如果连接是否牢固，重新安装网卡的驱动程序或新的网络适配器。 ping 远程主机 ip 成功，名称失败问题在 解析，而不是网络连接。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"Android6.0 RK3399 开发环境搭建中碰到的问题","slug":"Android_Sys/[Android6.0] 开发环境搭建中碰到的问题","date":"2017-12-01T15:33:05.000Z","updated":"2018-11-08T02:22:21.116Z","comments":true,"path":"2017/12/01/Android_Sys/[Android6.0] 开发环境搭建中碰到的问题/","link":"","permalink":"http://iyounix.com/2017/12/01/Android_Sys/[Android6.0] 开发环境搭建中碰到的问题/","excerpt":"","text":"OS：Ubuntu16.04 [TOC] 参考文献http://blog.csdn.net/fuchaosz/article/details/51487585这篇文章中涵盖了大部分编译问题 问题汇总clang: error: linker command failed with exit code 1解决方法：代码 art/build/Android.common_build.mk 中123 # By default, host builds use clang for better warnings.-- ART_HOST_CLANG := true++ ART_HOST_CLANG := false 中文路径问题SDK 路径中请不要包含中文 RK upgrade_tool1./upgrade_tool: error while loading shared libraries: libudev.so.1: cannot open shared object file: No such file or directory 1sudo apt-get install libudev-dev not work1234➜ rockdev sudo dpkg -S libudev | grep libudev.solibudev1:amd64: /lib/x86_64-linux-gnu/libudev.so.1.6.4libudev-dev:amd64: /usr/lib/x86_64-linux-gnu/libudev.solibudev1:amd64: /lib/x86_64-linux-gnu/libudev.so.1 12➜ x86_64-linux-gnu ls -al libudev.so.1lrwxrwxrwx 1 root root 16 10月 27 18:12 libudev.so.1 -&gt; libudev.so.1.6.4 Dont do this:1sudo ln -sf /lib/x86_64-linux-gnu/libudev.so.0 /lib/x86_64-linux-gnu/libudev.so.1","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 修改默认壁纸","slug":"Android_App/[Android6.0][RK3399] 修改默认壁纸","date":"2017-12-01T15:33:05.000Z","updated":"2018-11-08T03:27:53.776Z","comments":true,"path":"2017/12/01/Android_App/[Android6.0][RK3399] 修改默认壁纸/","link":"","permalink":"http://iyounix.com/2017/12/01/Android_App/[Android6.0][RK3399] 修改默认壁纸/","excerpt":"","text":"OS: Android6.0Hardware: RK3399 修改默认壁纸系统默认壁纸的存放路径：frameworks/base/core/res/res/drawable 下图片文件名：default_wallpaper替换为同分辨率的图片即可。 Launcher3 默认壁纸加载流程参考：http://www.zhimengzhe.com/Androidkaifa/26383.html","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 双屏异显代码实现流程分析(二)","slug":"Android_Driver/Driver/[Android6.0][RK3399] 双屏异显代码实现流程分析（二）","date":"2017-11-30T19:33:06.000Z","updated":"2018-11-08T02:42:44.980Z","comments":true,"path":"2017/12/01/Android_Driver/Driver/[Android6.0][RK3399] 双屏异显代码实现流程分析（二）/","link":"","permalink":"http://iyounix.com/2017/12/01/Android_Driver/Driver/[Android6.0][RK3399] 双屏异显代码实现流程分析（二）/","excerpt":"","text":"[TOC] Platform: RK3399OS: Android 6.0Version: v2016.08LCD interface: eDP + mipi Patch CodeDate: Fri, 09 Dec 2016 10:53:11 +0800Subject: [PATCH] video: rockchip: fb: add support dual lcdChange-Id: I246f8e7d725d26abf2555d3077dd87da72920731Signed-off-by: Huang Jiachai &lt; ××× &gt; dtsirk3399-android.dtsi123456789101112diff --git a/arch/arm64/boot/dts/rockchip/rk3399-android.dtsi b/arch/arm64/boot/dts/rockchip/rk3399-android.dtsiindex a009537..05a8377 100644--- a/arch/arm64/boot/dts/rockchip/rk3399-android.dtsi+++ b/arch/arm64/boot/dts/rockchip/rk3399-android.dtsi@@ -287,7 +287,7 @@ status = &quot;okay&quot;; compatible = &quot;rockchip,rk-fb&quot;; rockchip,disp-mode = &lt;DUAL&gt;;- rockchip,uboot-logo-on = &lt;1&gt;;+ rockchip,uboot-logo-on = &lt;0&gt;; memory-region = &lt;&amp;rockchip_logo&gt;; &#125;; rk3399-evb-rev3-android.dts 在 rk_screen 中默认只有一个 screen0, 用于填充 primary screen 的 timing 现在需要添加 screen1，用于填充 extend screen 的 timing1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889diff --git a/arch/arm64/boot/dts/rockchip/rk3399-evb-rev3-android.dts b/arch/arm64/boot/dts/rockchip/rk3399-evb-rev3-android.dtsindex 3b3ff7c..3653205 100644--- a/arch/arm64/boot/dts/rockchip/rk3399-evb-rev3-android.dts+++ b/arch/arm64/boot/dts/rockchip/rk3399-evb-rev3-android.dts@@ -51,18 +51,55 @@ &#125;; &amp;rk_screen &#123;- #include &lt;dt-bindings/display/screen-timing/lcd-tv080wum-nl0-mipi.dtsi&gt;+ status = &quot;okay&quot;;+ screen0 &#123;+ screen_prop = &lt;PRMRY&gt;;+ native-mode = &lt;DEFAULT_MODE&gt;;+ power_ctr &#123;+ lcd_en0: lcd-en &#123;+ rockchip,power_type = &lt;GPIO&gt;;+ gpios = &lt;&amp;gpio1 13 GPIO_ACTIVE_HIGH&gt;;+ rockchip,delay = &lt;10&gt;;+ &#125;;+ /* lcd_cs &#123;+ rockchip,power_type = &lt;GPIO&gt;;+ gpios = &lt;&amp;gpio7 GPIO_A4 GPIO_ACTIVE_HIGH&gt;;+ rockchip,delay = &lt;10&gt;;+ &#125;; */+ &#125;;+ #include &lt;dt-bindings/display/screen-timing/lcd-tv080wum-nl0-mipi.dtsi&gt;+ //#include &lt;dt-bindings/display/screen-timing/lcd-F402.dtsi&gt;+ &#125;;+ screen1 &#123;+ screen_prop = &lt;EXTEND&gt;;+ native-mode = &lt;DEFAULT_MODE&gt;;+ power_ctr &#123;+ /* cd_en1: lcd-en &#123;+ rockchip,power_type = &lt;GPIO&gt;;+ gpios = &lt;&amp;gpio1 13 GPIO_ACTIVE_HIGH&gt;;+ rockchip,delay = &lt;10&gt;;+ &#125;;*/+ /* lcd_cs &#123;+ rockchip,power_type = &lt;GPIO&gt;;+ gpios = &lt;&amp;gpio7 GPIO_A4 GPIO_ACTIVE_HIGH&gt;;+ rockchip,delay = &lt;10&gt;;+ &#125;; */+ &#125;;+ #include &lt;dt-bindings/display/screen-timing/lcd-F402.dtsi&gt;+ //#include &lt;dt-bindings/display/screen-timing/lcd-tv080wum-nl0-mipi.dtsi&gt;+ //#include &quot;lcd-box.dtsi&quot;+ &#125;; &#125;; &amp;vopb_rk_fb &#123; status = &quot;okay&quot;; power_ctr: power_ctr &#123; rockchip,debug = &lt;0&gt;;- lcd_en: lcd-en &#123;+ /* lcd_en: lcd-en &#123; rockchip,power_type = &lt;GPIO&gt;; gpios = &lt;&amp;gpio1 13 GPIO_ACTIVE_HIGH&gt;; rockchip,delay = &lt;10&gt;;- &#125;;+ &#125;; */ /*lcd_cs: lcd-cs &#123; rockchip,power_type = &lt;GPIO&gt;;@@ -80,14 +117,23 @@ &amp;vopl_rk_fb &#123; status = &quot;okay&quot;;+ rockchip,uboot-logo-on = &lt;0&gt;; &#125;;//设置 mipi 通道的为主屏， eDP 的为副屏 &amp;mipi0_rk_fb &#123; status = &quot;okay&quot;;+ prop = &lt;PRMRY&gt;;+ //prop = &lt;EXTEND&gt;;+&#125;;++&amp;edp_rk_fb &#123;+ status = &quot;okay&quot;;+ prop = &lt;EXTEND&gt;;+ //prop = &lt;PRMRY&gt;; &#125;; &amp;hdmi_rk_fb &#123;- status = &quot;okay&quot;;+ status = &quot;disabled&quot;; rockchip,hdmi_video_source = &lt;DISPLAY_SOURCE_LCDC1&gt;; &#125;; 123456789101112131415161718192021diff --git a/arch/arm64/boot/dts/rockchip/rk3399-evb.dtsi b/arch/arm64/boot/dts/rockchip/rk3399-evb.dtsiindex b3c7141..b72ce6c 100644--- a/arch/arm64/boot/dts/rockchip/rk3399-evb.dtsi+++ b/arch/arm64/boot/dts/rockchip/rk3399-evb.dtsi@@ -101,7 +101,7 @@ 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255&gt;;- default-brightness-level = &lt;200&gt;;+ default-brightness-level = &lt;128&gt;; &#125;; clkin_gmac: external-gmac-clock &#123;@@ -370,7 +370,7 @@ &#125;; &amp;i2c4 &#123;- status = &quot;okay&quot;;+ status = &quot;disabled&quot;; i2c-scl-rising-time-ns = &lt;600&gt;; i2c-scl-falling-time-ns = &lt;20&gt;; lcdc 控制器rk322x_lcdc.c123456789101112131415diff --git a/drivers/video/rockchip/lcdc/rk322x_lcdc.c b/drivers/video/rockchip/lcdc/rk322x_lcdc.cindex 93c996a..d6bdff3 100644--- a/drivers/video/rockchip/lcdc/rk322x_lcdc.c+++ b/drivers/video/rockchip/lcdc/rk322x_lcdc.c@@ -5252,6 +5252,10 @@ rk322x_pdev = pdev; + if (dev_drv-&gt;cur_screen-&gt;type != SCREEN_HDMI &amp;&amp;+ dev_drv-&gt;cur_screen-&gt;type != SCREEN_TVOUT)+ dev_drv-&gt;hot_plug_state = 1;+ if (dev_drv-&gt;cur_screen-&gt;refresh_mode == SCREEN_CMD_MODE) &#123; te_pin = of_get_named_gpio_flags(np, &quot;te-gpio&quot;, 0, NULL); if (IS_ERR_VALUE(te_pin)) &#123; rk_fb.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328diff --git a/drivers/video/rockchip/rk_fb.c b/drivers/video/rockchip/rk_fb.cindex 25563a4..80db2e2 100644--- a/drivers/video/rockchip/rk_fb.c+++ b/drivers/video/rockchip/rk_fb.c@@ -73,9 +73,8 @@ extern phys_addr_t uboot_logo_base; extern phys_addr_t uboot_logo_size; extern phys_addr_t uboot_logo_offset;-static struct rk_fb_trsm_ops *trsm_lvds_ops;-static struct rk_fb_trsm_ops *trsm_edp_ops;-static struct rk_fb_trsm_ops *trsm_mipi_ops;+static struct rk_fb_trsm_ops *trsm_prmry_ops;+static struct rk_fb_trsm_ops *trsm_extend_ops; static int uboot_logo_on; static int rk_fb_debug_lvl;@@ -115,26 +114,13 @@ int rk_fb_trsm_ops_register(struct rk_fb_trsm_ops *ops, int type) &#123;- switch (type) &#123;- case SCREEN_RGB:- case SCREEN_LVDS:- case SCREEN_DUAL_LVDS:- case SCREEN_LVDS_10BIT:- case SCREEN_DUAL_LVDS_10BIT:- trsm_lvds_ops = ops;- break;- case SCREEN_EDP:- trsm_edp_ops = ops;- break;- case SCREEN_MIPI:- case SCREEN_DUAL_MIPI:- trsm_mipi_ops = ops;- break;- default:- pr_warn(&quot;%s: unsupported transmitter: %d!\\n&quot;,- __func__, type);- break;- &#125;+ if (type == PRMRY)+ trsm_prmry_ops = ops;+ else if (type == EXTEND)+ trsm_extend_ops = ops;+ else+ pr_err(&quot;%s, type:%d\\n&quot;, __func__, type);+ return 0; &#125; @@ -142,27 +128,12 @@ &#123; struct rk_fb_trsm_ops *ops; - switch (type) &#123;- case SCREEN_RGB:- case SCREEN_LVDS:- case SCREEN_DUAL_LVDS:- case SCREEN_LVDS_10BIT:- case SCREEN_DUAL_LVDS_10BIT:- ops = trsm_lvds_ops;- break;- case SCREEN_EDP:- ops = trsm_edp_ops;- break;- case SCREEN_MIPI:- case SCREEN_DUAL_MIPI:- ops = trsm_mipi_ops;- break;- default:- ops = NULL;- pr_warn(&quot;%s: unsupported transmitter: %d!\\n&quot;,- __func__, type);- break;- &#125;+ if (type == PRMRY)+ ops = trsm_prmry_ops;+ else if (type == EXTEND)+ ops = trsm_extend_ops;+ else+ pr_err(&quot;%s, type:%d\\n&quot;, __func__, type); return ops; &#125; @@ -317,10 +288,10 @@ /* * rk display power control parse from dts */-int rk_disp_pwr_ctr_parse_dt(struct rk_lcdc_driver *dev_drv)+int rk_disp_pwr_ctr_parse_dt(struct device_node *np,+ struct rk_screen *rk_screen) &#123;- struct device_node *root = of_get_child_by_name(dev_drv-&gt;dev-&gt;of_node,- &quot;power_ctr&quot;);+ struct device_node *root = of_get_child_by_name(np, &quot;power_ctr&quot;); struct device_node *child; struct rk_disp_pwr_ctr_list *pwr_ctr; struct list_head *pos;@@ -329,10 +300,10 @@ u32 debug = 0; int ret; - INIT_LIST_HEAD(&amp;dev_drv-&gt;pwrlist_head);+ INIT_LIST_HEAD(rk_screen-&gt;pwrlist_head); if (!root) &#123;- dev_err(dev_drv-&gt;dev, &quot;can&apos;t find power_ctr node for lcdc%d\\n&quot;,- dev_drv-&gt;id);+ dev_err(rk_screen-&gt;dev, &quot;can&apos;t find power_ctr node for lcdc%d\\n&quot;,+ rk_screen-&gt;lcdc_id); return -ENODEV; &#125; @@ -347,7 +318,7 @@ pwr_ctr-&gt;pwr_ctr.type = GPIO; pwr_ctr-&gt;pwr_ctr.gpio = of_get_gpio_flags(child, 0, &amp;flags); if (!gpio_is_valid(pwr_ctr-&gt;pwr_ctr.gpio)) &#123;- dev_err(dev_drv-&gt;dev, &quot;%s ivalid gpio\\n&quot;,+ dev_err(rk_screen-&gt;dev, &quot;%s ivalid gpio\\n&quot;, child-&gt;name); return -EINVAL; &#125;@@ -355,7 +326,7 @@ ret = gpio_request(pwr_ctr-&gt;pwr_ctr.gpio, child-&gt;name); if (ret) &#123;- dev_err(dev_drv-&gt;dev,+ dev_err(rk_screen-&gt;dev, &quot;request %s gpio fail:%d\\n&quot;, child-&gt;name, ret); &#125;@@ -364,9 +335,9 @@ pwr_ctr-&gt;pwr_ctr.type = REGULATOR; pwr_ctr-&gt;pwr_ctr.rgl_name = NULL; ret = of_property_read_string(child, &quot;rockchip,regulator_name&quot;,- &amp;(pwr_ctr-&gt;pwr_ctr.rgl_name));+ &amp;(pwr_ctr-&gt;pwr_ctr.rgl_name)); if (ret || IS_ERR_OR_NULL(pwr_ctr-&gt;pwr_ctr.rgl_name))- dev_err(dev_drv-&gt;dev, &quot;get regulator name failed!\\n&quot;);+ dev_err(rk_screen-&gt;dev, &quot;get regulator name failed!\\n&quot;); if (!of_property_read_u32(child, &quot;rockchip,regulator_voltage&quot;, &amp;val)) pwr_ctr-&gt;pwr_ctr.volt = val; else@@ -378,29 +349,30 @@ pwr_ctr-&gt;pwr_ctr.delay = val; else pwr_ctr-&gt;pwr_ctr.delay = 0;- list_add_tail(&amp;pwr_ctr-&gt;list, &amp;dev_drv-&gt;pwrlist_head);+ list_add_tail(&amp;pwr_ctr-&gt;list, rk_screen-&gt;pwrlist_head); &#125; of_property_read_u32(root, &quot;rockchip,debug&quot;, &amp;debug); if (debug) &#123;- list_for_each(pos, &amp;dev_drv-&gt;pwrlist_head) &#123;+ list_for_each(pos, rk_screen-&gt;pwrlist_head) &#123; pwr_ctr = list_entry(pos, struct rk_disp_pwr_ctr_list, list);- pr_info(&quot;pwr_ctr_name:%s\\n&quot;- &quot;pwr_type:%s\\n&quot;- &quot;gpio:%d\\n&quot;- &quot;atv_val:%d\\n&quot;- &quot;delay:%d\\n\\n&quot;,- pwr_ctr-&gt;pwr_ctr.name,- (pwr_ctr-&gt;pwr_ctr.type == GPIO) ? &quot;gpio&quot; : &quot;regulator&quot;,- pwr_ctr-&gt;pwr_ctr.gpio,- pwr_ctr-&gt;pwr_ctr.atv_val,- pwr_ctr-&gt;pwr_ctr.delay);+ printk(KERN_INFO &quot;pwr_ctr_name:%s\\n&quot;+ &quot;pwr_type:%s\\n&quot;+ &quot;gpio:%d\\n&quot;+ &quot;atv_val:%d\\n&quot;+ &quot;delay:%d\\n\\n&quot;,+ pwr_ctr-&gt;pwr_ctr.name,+ (pwr_ctr-&gt;pwr_ctr.type == GPIO) ? &quot;gpio&quot; : &quot;regulator&quot;,+ pwr_ctr-&gt;pwr_ctr.gpio,+ pwr_ctr-&gt;pwr_ctr.atv_val,+ pwr_ctr-&gt;pwr_ctr.delay); &#125; &#125; return 0;+ &#125; int rk_disp_pwr_enable(struct rk_lcdc_driver *dev_drv)@@ -411,9 +383,14 @@ struct regulator *regulator_lcd = NULL; int count = 10; - if (list_empty(&amp;dev_drv-&gt;pwrlist_head))+ if (!dev_drv-&gt;cur_screen-&gt;pwrlist_head) &#123;+ pr_info(&quot;error: %s, lcdc%d screen pwrlist null\\n&quot;,+ __func__, dev_drv-&gt;id); return 0;- list_for_each(pos, &amp;dev_drv-&gt;pwrlist_head) &#123;+ &#125;+ if (list_empty(dev_drv-&gt;cur_screen-&gt;pwrlist_head))+ return 0;+ list_for_each(pos, dev_drv-&gt;cur_screen-&gt;pwrlist_head) &#123; pwr_ctr_list = list_entry(pos, struct rk_disp_pwr_ctr_list, list); pwr_ctr = &amp;pwr_ctr_list-&gt;pwr_ctr;@@ -422,8 +399,7 @@ mdelay(pwr_ctr-&gt;delay); &#125; else if (pwr_ctr-&gt;type == REGULATOR) &#123; if (pwr_ctr-&gt;rgl_name)- regulator_lcd =- regulator_get(NULL, pwr_ctr-&gt;rgl_name);+ regulator_lcd = regulator_get(NULL, pwr_ctr-&gt;rgl_name); if (regulator_lcd == NULL) &#123; dev_err(dev_drv-&gt;dev, &quot;%s: regulator get failed,regulator name:%s\\n&quot;,@@ -456,9 +432,14 @@ struct regulator *regulator_lcd = NULL; int count = 10; - if (list_empty(&amp;dev_drv-&gt;pwrlist_head))+ if (!dev_drv-&gt;cur_screen-&gt;pwrlist_head) &#123;+ pr_info(&quot;error: %s, lcdc%d screen pwrlist null\\n&quot;,+ __func__, dev_drv-&gt;id); return 0;- list_for_each(pos, &amp;dev_drv-&gt;pwrlist_head) &#123;+ &#125;+ if (list_empty(dev_drv-&gt;cur_screen-&gt;pwrlist_head))+ return 0;+ list_for_each(pos, dev_drv-&gt;cur_screen-&gt;pwrlist_head) &#123; pwr_ctr_list = list_entry(pos, struct rk_disp_pwr_ctr_list, list); pwr_ctr = &amp;pwr_ctr_list-&gt;pwr_ctr;@@ -474,8 +455,7 @@ continue; &#125; while (regulator_is_enabled(regulator_lcd) &gt; 0) &#123;- if (regulator_disable(regulator_lcd) == 0 ||- count == 0)+ if (regulator_disable(regulator_lcd) == 0 || count == 0) break; else dev_err(dev_drv-&gt;dev,@@ -530,6 +510,8 @@ screen-&gt;pin_den = 1; else screen-&gt;pin_den = 0;+ printk(&quot;hjc&gt;&gt;&gt;prop:%d, x:%d, y:%d, dclk:%d\\n&quot;, screen-&gt;prop,+ screen-&gt;mode.xres, screen-&gt;mode.yres, screen-&gt;mode.pixclock); return 0; &#125;@@ -544,7 +526,7 @@ pr_err(&quot;parse display timing err\\n&quot;); return -EINVAL; &#125;- dt = display_timings_get(disp_timing, disp_timing-&gt;native_mode);+ dt = display_timings_get(disp_timing, screen-&gt;native_mode); rk_fb_video_mode_from_timing(dt, screen); return 0;@@ -3942,7 +3924,8 @@ win = dev_drv-&gt;win[win_id]; if (!strcmp(fbi-&gt;fix.id, &quot;fb0&quot;)) &#123;- fb_mem_size = get_fb_size(dev_drv-&gt;reserved_fb);+ fb_mem_size = get_fb_size(dev_drv-&gt;reserved_fb,+ dev_drv-&gt;cur_screen); #if defined(CONFIG_ION_ROCKCHIP) if (rk_fb_alloc_buffer_by_ion(fbi, win, fb_mem_size) &lt; 0) return -ENOMEM;@@ -3963,8 +3946,7 @@ if (dev_drv-&gt;prop == EXTEND &amp;&amp; dev_drv-&gt;iommu_enabled) &#123; struct rk_lcdc_driver *dev_drv_prmry; int win_id_prmry;-- fb_mem_size = get_fb_size(dev_drv-&gt;reserved_fb);+ fb_mem_size = get_fb_size(dev_drv-&gt;reserved_fb, dev_drv-&gt;cur_screen); #if defined(CONFIG_ION_ROCKCHIP) dev_drv_prmry = rk_get_prmry_lcdc_drv(); if (dev_drv_prmry == NULL)@@ -4129,14 +4111,9 @@ dev_drv-&gt;area_support[i] = 1; if (dev_drv-&gt;ops-&gt;area_support_num) dev_drv-&gt;ops-&gt;area_support_num(dev_drv, dev_drv-&gt;area_support);- rk_disp_pwr_ctr_parse_dt(dev_drv);- if (dev_drv-&gt;prop == PRMRY) &#123;- rk_fb_set_prmry_screen(screen);- rk_fb_get_prmry_screen(screen);- &#125;- dev_drv-&gt;trsm_ops = rk_fb_trsm_ops_get(screen-&gt;type);- if (dev_drv-&gt;prop != PRMRY)- rk_fb_get_extern_screen(screen);+ rk_fb_set_screen(screen, dev_drv-&gt;prop);+ rk_fb_get_screen(screen, dev_drv-&gt;prop);+ dev_drv-&gt;trsm_ops = rk_fb_trsm_ops_get(dev_drv-&gt;prop); dev_drv-&gt;output_color = screen-&gt;color_mode; return 0;@@ -4511,15 +4488,24 @@ struct fb_info *extend_fbi = rk_fb-&gt;fb[dev_drv-&gt;fb_index_base]; extend_fbi-&gt;var.pixclock = rk_fb-&gt;fb[0]-&gt;var.pixclock;- if (rk_fb-&gt;disp_mode == DUAL_LCD) &#123;- extend_fbi-&gt;fbops-&gt;fb_open(extend_fbi, 1);- if (dev_drv-&gt;iommu_enabled) &#123;- if (dev_drv-&gt;mmu_dev)- rockchip_iovmm_set_fault_handler(dev_drv-&gt;dev,- rk_fb_sysmmu_fault_handler);- &#125;- rk_fb_alloc_buffer(extend_fbi);+ extend_fbi-&gt;var.xres_virtual = rk_fb-&gt;fb[0]-&gt;var.xres_virtual;+ extend_fbi-&gt;var.yres_virtual = rk_fb-&gt;fb[0]-&gt;var.yres_virtual;+ extend_fbi-&gt;var.xres = rk_fb-&gt;fb[0]-&gt;var.xres;+ extend_fbi-&gt;var.yres = rk_fb-&gt;fb[0]-&gt;var.yres;+ extend_fbi-&gt;fbops-&gt;fb_open(extend_fbi, 1);+ if (dev_drv-&gt;iommu_enabled) &#123;+ if (dev_drv-&gt;mmu_dev)+ rockchip_iovmm_set_fault_handler(dev_drv-&gt;dev,+ rk_fb_sysmmu_fault_handler);+ if (dev_drv-&gt;ops-&gt;mmu_en)+ dev_drv-&gt;ops-&gt;mmu_en(dev_drv); &#125;+ rk_fb_alloc_buffer(extend_fbi);+ //if (rk_fb-&gt;disp_mode == DUAL_LCD) &#123;+ extend_fbi-&gt;fbops-&gt;fb_set_par(extend_fbi);+ extend_fbi-&gt;fbops-&gt;fb_pan_display(&amp;extend_fbi-&gt;var,+ extend_fbi);+ //&#125; &#125; #endif return 0; timing 初始化rk_screen.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192diff --git a/drivers/video/rockchip/screen/rk_screen.c b/drivers/video/rockchip/screen/rk_screen.cindex 3a4e6c3..7473e5f 100644--- a/drivers/video/rockchip/screen/rk_screen.c+++ b/drivers/video/rockchip/screen/rk_screen.c@@ -4,57 +4,102 @@ #include &quot;lcd.h&quot; #include &quot;../hdmi/rockchip-hdmi.h&quot; -static struct rk_screen *rk_screen;+static struct rk_screen *prmry_screen;+static struct rk_screen *extend_screen;++static void rk_screen_info_error(struct rk_screen *screen, int prop)+&#123;+ pr_err(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;error&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\n&quot;);+ pr_err(&quot;&gt;&gt;please init %s screen info in dtsi file&lt;&lt;\\n&quot;,+ (prop == PRMRY) ? &quot;prmry&quot; : &quot;extend&quot;);+ pr_err(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;error&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\\n&quot;);+&#125; int rk_fb_get_extern_screen(struct rk_screen *screen) &#123;- if (unlikely(!rk_screen) || unlikely(!screen))+ if (unlikely(!extend_screen) || unlikely(!screen)) return -1;-- memcpy(screen, rk_screen, sizeof(struct rk_screen));+ memcpy(screen, extend_screen, sizeof(struct rk_screen)); screen-&gt;dsp_lut = NULL; screen-&gt;cabc_lut = NULL;- screen-&gt;type = SCREEN_NULL;- return 0; &#125; -int rk_fb_get_prmry_screen(struct rk_screen *screen)+int rk_fb_get_prmry_screen(struct rk_screen *screen) &#123;- if (unlikely(!rk_screen) || unlikely(!screen))+ if (unlikely(!prmry_screen) || unlikely(!screen)) return -1; - memcpy(screen, rk_screen, sizeof(struct rk_screen));+ memcpy(screen, prmry_screen, sizeof(struct rk_screen)); return 0; &#125; -int rk_fb_set_prmry_screen(struct rk_screen *screen)+int rk_fb_get_screen(struct rk_screen *screen, int prop) &#123;- if (unlikely(!rk_screen) || unlikely(!screen))+ struct rk_screen *cur_screen = NULL;+ if (unlikely(!screen)) return -1; - rk_screen-&gt;lcdc_id = screen-&gt;lcdc_id;- rk_screen-&gt;screen_id = screen-&gt;screen_id;- rk_screen-&gt;x_mirror = screen-&gt;x_mirror;- rk_screen-&gt;y_mirror = screen-&gt;y_mirror;- rk_screen-&gt;overscan.left = screen-&gt;overscan.left;- rk_screen-&gt;overscan.top = screen-&gt;overscan.left;- rk_screen-&gt;overscan.right = screen-&gt;overscan.left;- rk_screen-&gt;overscan.bottom = screen-&gt;overscan.left;+ if (prop == PRMRY) &#123;+ if (unlikely(!prmry_screen)) &#123;+ rk_screen_info_error(screen, prop);+ return -1;+ &#125;+ cur_screen = prmry_screen;+ &#125; else &#123;+ if (unlikely(!extend_screen)) &#123;+ rk_screen_info_error(screen, prop);+ return -1;+ &#125;+ cur_screen = extend_screen;+ &#125;+ memcpy(screen, cur_screen, sizeof(struct rk_screen)); return 0; &#125; -size_t get_fb_size(u8 reserved_fb)+int rk_fb_set_screen(struct rk_screen *screen, int prop)+&#123;+ struct rk_screen *cur_screen = NULL;++ if (unlikely(!screen))+ return -1;+ if (prop == PRMRY) &#123;+ if (unlikely(!prmry_screen)) &#123;+ rk_screen_info_error(screen, prop);+ return -1;+ &#125;+ cur_screen = prmry_screen;+ &#125; else &#123;+ if (unlikely(!extend_screen)) &#123;+ rk_screen_info_error(screen, prop);+ return -1;+ &#125;+ cur_screen = extend_screen;+ &#125;++ cur_screen-&gt;lcdc_id = screen-&gt;lcdc_id;+ cur_screen-&gt;screen_id = screen-&gt;screen_id;+ cur_screen-&gt;x_mirror = screen-&gt;x_mirror;+ cur_screen-&gt;y_mirror = screen-&gt;y_mirror;+ cur_screen-&gt;overscan.left = screen-&gt;overscan.left;+ cur_screen-&gt;overscan.top = screen-&gt;overscan.left;+ cur_screen-&gt;overscan.right = screen-&gt;overscan.left;+ cur_screen-&gt;overscan.bottom = screen-&gt;overscan.left;++ return 0;+&#125;++size_t get_fb_size(u8 reserved_fb, struct rk_screen *screen) &#123; size_t size = 0; u32 xres = 0; u32 yres = 0; - if (unlikely(!rk_screen))+ if (unlikely(!screen)) return 0; - xres = rk_screen-&gt;mode.xres;- yres = rk_screen-&gt;mode.yres;+ xres = screen-&gt;mode.xres;+ yres = screen-&gt;mode.yres; /* align as 64 bytes(16*4) in an odd number of times */ xres = ALIGN_64BYTE_ODD_TIMES(xres, ALIGN_PIXEL_64BYTE_RGB8888);@@ -73,22 +118,51 @@ static int rk_screen_probe(struct platform_device *pdev) &#123; struct device_node *np = pdev-&gt;dev.of_node;- int ret;+ struct device_node *screen_np;+ struct rk_screen *rk_screen;+ int ret, screen_prop; if (!np) &#123; dev_err(&amp;pdev-&gt;dev, &quot;Missing device tree node.\\n&quot;); return -EINVAL; &#125;- rk_screen = devm_kzalloc(&amp;pdev-&gt;dev,- sizeof(struct rk_screen), GFP_KERNEL);- if (!rk_screen) &#123;- dev_err(&amp;pdev-&gt;dev, &quot;kmalloc for rk screen fail!&quot;);- return -ENOMEM;++ for_each_child_of_node(np, screen_np) &#123;+ rk_screen = devm_kzalloc(&amp;pdev-&gt;dev,+ sizeof(struct rk_screen), GFP_KERNEL);+ if (!rk_screen) &#123;+ dev_err(&amp;pdev-&gt;dev, &quot;kmalloc for rk screen fail!&quot;);+ return -ENOMEM;+ &#125;+ rk_screen-&gt;pwrlist_head = devm_kzalloc(&amp;pdev-&gt;dev,+ sizeof(struct list_head), GFP_KERNEL);+ if (!rk_screen-&gt;pwrlist_head) &#123;+ dev_err(&amp;pdev-&gt;dev, &quot;kmalloc for rk_screen pwrlist_head fail!&quot;);+ return -ENOMEM;+ &#125;+ of_property_read_u32(screen_np, &quot;screen_prop&quot;, &amp;screen_prop);+ if (screen_prop == PRMRY)+ prmry_screen = rk_screen;+ else if (screen_prop == EXTEND)+ extend_screen = rk_screen;+ else+ dev_err(&amp;pdev-&gt;dev, &quot;unknow screen prop: %d\\n&quot;,+ screen_prop);+ rk_screen-&gt;prop = screen_prop;+ of_property_read_u32(screen_np, &quot;native-mode&quot;, &amp;rk_screen-&gt;native_mode);+ rk_screen-&gt;dev = &amp;pdev-&gt;dev;+ ret = rk_fb_prase_timing_dt(screen_np, rk_screen);+ pr_info(&quot;%s screen timing parse %s\\n&quot;,+ (screen_prop == PRMRY) ? &quot;prmry&quot; : &quot;extend&quot;,+ ret ? &quot;failed&quot; : &quot;success&quot;);+ ret = rk_disp_pwr_ctr_parse_dt(screen_np, rk_screen);+ pr_info(&quot;%s screen power ctrl parse %s\\n&quot;,+ (screen_prop == PRMRY) ? &quot;prmry&quot; : &quot;extend&quot;,+ ret ? &quot;failed&quot; : &quot;success&quot;); &#125;- ret = rk_fb_prase_timing_dt(np, rk_screen);- dev_info(&amp;pdev-&gt;dev, &quot;rockchip screen probe %s\\n&quot;,- ret ? &quot;failed&quot; : &quot;success&quot;);- return ret;++ dev_info(&amp;pdev-&gt;dev, &quot;rockchip screen probe success\\n&quot;);+ return 0; &#125; static const struct of_device_id rk_screen_dt_ids[] = &#123; rk32_dp.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263diff --git a/drivers/video/rockchip/transmitter/rk32_dp.c b/drivers/video/rockchip/transmitter/rk32_dp.cindex 6d386bc..0bffdb0 100755--- a/drivers/video/rockchip/transmitter/rk32_dp.c+++ b/drivers/video/rockchip/transmitter/rk32_dp.c@@ -129,7 +129,7 @@ struct rk_screen *screen = &amp;edp-&gt;screen; u32 val = 0; - rk_fb_get_prmry_screen(screen);+ rk_fb_get_screen(screen, edp-&gt;prop); if (cpu_is_rk3288()) &#123; if (screen-&gt;lcdc_id == 1) /*select lcdc*/@@ -1734,17 +1734,21 @@ struct resource *res; struct device_node *np = pdev-&gt;dev.of_node; int ret;+ int prop; if (!np) &#123; dev_err(&amp;pdev-&gt;dev, &quot;Missing device tree node.\\n&quot;); return -EINVAL; &#125;+ of_property_read_u32(np, &quot;prop&quot;, &amp;prop);+ pr_info(&quot;Use EDP as %s screen\\n&quot;, (prop == PRMRY) ? &quot;prmry&quot; : &quot;extend&quot;); edp = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(struct rk32_edp), GFP_KERNEL); if (!edp) &#123; dev_err(&amp;pdev-&gt;dev, &quot;no memory for state\\n&quot;); return -ENOMEM; &#125;+ edp-&gt;prop = prop; edp-&gt;dev = &amp;pdev-&gt;dev; edp-&gt;video_info.h_sync_polarity = 0; edp-&gt;video_info.v_sync_polarity = 0;@@ -1756,7 +1760,7 @@ edp-&gt;video_info.link_rate = LINK_RATE_1_62GBPS; edp-&gt;video_info.lane_count = LANE_CNT4;- rk_fb_get_prmry_screen(&amp;edp-&gt;screen);+ rk_fb_get_screen(&amp;edp-&gt;screen, prop); if (edp-&gt;screen.type != SCREEN_EDP) &#123; dev_err(&amp;pdev-&gt;dev, &quot;screen is not edp!\\n&quot;); return -EINVAL;@@ -1852,7 +1856,7 @@ pm_runtime_get_sync(&amp;pdev-&gt;dev); rk32_edp = edp;- rk_fb_trsm_ops_register(&amp;trsm_edp_ops, SCREEN_EDP);+ rk_fb_trsm_ops_register(&amp;trsm_edp_ops, prop); #if defined(CONFIG_DEBUG_FS) edp-&gt;debugfs_dir = debugfs_create_dir(&quot;edp&quot;, NULL); if (IS_ERR(edp-&gt;debugfs_dir)) &#123;diff --git a/drivers/video/rockchip/transmitter/rk32_dp.h b/drivers/video/rockchip/transmitter/rk32_dp.hindex 2dc41c6..fda0de2 100755--- a/drivers/video/rockchip/transmitter/rk32_dp.h+++ b/drivers/video/rockchip/transmitter/rk32_dp.h@@ -571,6 +571,7 @@ bool edp_en; int soctype; struct dentry *debugfs_dir;+ int prop; &#125;; rk32_mipi_dsi.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152diff --git a/drivers/video/rockchip/transmitter/rk32_mipi_dsi.c b/drivers/video/rockchip/transmitter/rk32_mipi_dsi.cindex 741fdb5..ed68d85 100644--- a/drivers/video/rockchip/transmitter/rk32_mipi_dsi.c+++ b/drivers/video/rockchip/transmitter/rk32_mipi_dsi.c@@ -1609,7 +1609,7 @@ pm_runtime_get_sync(&amp;dsi0-&gt;pdev-&gt;dev); #endif opt_mode = dsi0-&gt;screen.refresh_mode;- rk_fb_get_prmry_screen(dsi0-&gt;screen.screen);+ rk_fb_get_screen(dsi0-&gt;screen.screen, dsi0-&gt;prop); dsi0-&gt;screen.lcdc_id = dsi0-&gt;screen.screen-&gt;lcdc_id; rk32_init_phy_mode(dsi0-&gt;screen.lcdc_id); @@ -1875,7 +1875,7 @@ static int rk32_mipi_dsi_probe(struct platform_device *pdev) &#123; int ret = 0;- static int id;+ static int id, prop; struct dsi *dsi; struct mipi_dsi_ops *ops; struct rk_screen *screen;@@ -1890,7 +1890,8 @@ return -ENODEV; &#125; data = of_id-&gt;data;-+ of_property_read_u32(np, &quot;prop&quot;, &amp;prop);+ pr_info(&quot;Use mipi as %s screen\\n&quot;, (prop == PRMRY) ? &quot;prmry&quot; : &quot;extend&quot;); dsi = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(struct dsi), GFP_KERNEL); if (!dsi) &#123; dev_err(&amp;pdev-&gt;dev, &quot;request struct dsi fail!\\n&quot;);@@ -1997,8 +1998,8 @@ dev_err(&amp;pdev-&gt;dev, &quot;request struct rk_screen fail!\\n&quot;); return -1; &#125;- rk_fb_get_prmry_screen(screen);-+ rk_fb_get_screen(screen, prop);+ dsi-&gt;prop = prop; dsi-&gt;pdev = pdev; ops = &amp;dsi-&gt;ops; ops-&gt;dsi = dsi;@@ -2056,7 +2057,7 @@ if(!support_uboot_display()) rk32_init_phy_mode(dsi_screen-&gt;lcdc_id); */- rk_fb_trsm_ops_register(&amp;trsm_dsi_ops, SCREEN_MIPI);+ rk_fb_trsm_ops_register(&amp;trsm_dsi_ops, prop); #ifdef MIPI_DSI_REGISTER_IO debugfs_create_file(&quot;mipidsi0&quot;, S_IFREG | S_IRUGO, dsi-&gt;debugfs_dir, dsi, &amp;reg_proc_fops); rk32_mipi_dsi.h123456789101112diff --git a/drivers/video/rockchip/transmitter/rk32_mipi_dsi.h b/drivers/video/rockchip/transmitter/rk32_mipi_dsi.hindex f568254..473db82 100644--- a/drivers/video/rockchip/transmitter/rk32_mipi_dsi.h+++ b/drivers/video/rockchip/transmitter/rk32_mipi_dsi.h@@ -307,6 +307,7 @@ struct dsi &#123; u8 dsi_id; u8 lcdc_id;+ int prop; u8 vid; u8 clk_on; struct regmap *grf_base; rk_fb.h123456789101112131415161718diff --git a/include/dt-bindings/display/rk_fb.h b/include/dt-bindings/display/rk_fb.hindex 81c9855..ae7241d 100755--- a/include/dt-bindings/display/rk_fb.h+++ b/include/dt-bindings/display/rk_fb.h@@ -14,6 +14,13 @@ #define DUAL 2 #define DUAL_LCD 3 +#define DEFAULT_MODE 0+#define HDMI_720P 0+#define HDMI_1080P 1+#define HDMI_2160P 2+#define NTSC_CVBS 3+#define PAL_CVBS 4+ #define DEFAULT_MODE 0 #define ONE_VOP_DUAL_MIPI_HOR_SCAN 1 #define ONE_VOP_DUAL_MIPI_VER_SCAN 2 lcd 的 dtsi1234567891011121314151617diff --git a/include/dt-bindings/display/screen-timing/lcd-F402.dtsi b/include/dt-bindings/display/screen-timing/lcd-F402.dtsiindex a3ad25f..abe178f 100644--- a/include/dt-bindings/display/screen-timing/lcd-F402.dtsi+++ b/include/dt-bindings/display/screen-timing/lcd-F402.dtsi@@ -4,9 +4,9 @@ */ -disp_timings: display-timings &#123;- native-mode = &lt;&amp;timing0&gt;;- timing0: timing0 &#123;+display-timings &#123;+ native-mode = &lt;&amp;f402&gt;;+ f402: timing0 &#123; screen-type = &lt;SCREEN_EDP&gt;; out-face = &lt;OUT_P666&gt;; clock-frequency = &lt;205000000&gt;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162diff --git a/include/dt-bindings/display/screen-timing/lcd-box.dtsi b/include/dt-bindings/display/screen-timing/lcd-box.dtsiindex 2109a89..20e2a21 100644--- a/include/dt-bindings/display/screen-timing/lcd-box.dtsi+++ b/include/dt-bindings/display/screen-timing/lcd-box.dtsi@@ -3,36 +3,9 @@ * */ - disp_power_ctr: power_ctr &#123;- /* rockchip,debug = &lt;0&gt;;- lcd_en:lcd_en &#123;- rockchip,power_type = &lt;GPIO&gt;;- gpios = &lt;&amp;gpio0 GPIO_B0 GPIO_ACTIVE_HIGH&gt;;- rockchip,delay = &lt;10&gt;;- &#125;;-- bl_en:bl_en &#123;- rockchip,power_type = &lt;GPIO&gt;;- gpios = &lt;&amp;gpio0 GPIO_A2 GPIO_ACTIVE_HIGH&gt;;- rockchip,delay = &lt;10&gt;;- &#125;;-- bl_ctr:bl_ctr &#123;- rockchip,power_type = &lt;GPIO&gt;;- gpios = &lt;&amp;gpio3 GPIO_D6 GPIO_ACTIVE_HIGH&gt;;- rockchip,delay = &lt;10&gt;;- &#125;;-- lcd_rst:lcd_rst &#123;- rockchip,power_type = &lt;REGULATOR&gt;;- rockchip,delay = &lt;5&gt;;- &#125;;*/--&#125;;--disp_timings: display-timings &#123;- native-mode = &lt;&amp;timing0&gt;;- timing0: timing0 &#123;+display-timings &#123;+ native-mode = &lt;&amp;hdmi_720p&gt;;+ hdmi_720p: timing0 &#123; screen-type = &lt;SCREEN_RGB&gt;; out-face = &lt;OUT_P888&gt;; color-mode = &lt;COLOR_YCBCR&gt;;@@ -53,7 +26,7 @@ swap-rg = &lt;0&gt;; swap-gb = &lt;0&gt;; &#125;;- timing1: timing1 &#123;+ hdmi_1080p: timing1 &#123; screen-type = &lt;SCREEN_RGB&gt;; out-face = &lt;OUT_P888&gt;; color-mode = &lt;COLOR_YCBCR&gt;;@@ -74,7 +47,7 @@ swap-rg = &lt;0&gt;; swap-gb = &lt;0&gt;; &#125;;- timing2: timing2 &#123;+ hdmi_2160p: timing2 &#123; screen-type = &lt;SCREEN_RGB&gt;; out-face = &lt;OUT_P888&gt;; color-mode = &lt;COLOR_YCBCR&gt;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566diff --git a/include/dt-bindings/display/screen-timing/lcd-tv080wum-nl0-mipi.dtsi b/include/dt-bindings/display/screen-timing/lcd-tv080wum-nl0-mipi.dtsiindex b408d65..6a203a9 100644--- a/include/dt-bindings/display/screen-timing/lcd-tv080wum-nl0-mipi.dtsi+++ b/include/dt-bindings/display/screen-timing/lcd-tv080wum-nl0-mipi.dtsi@@ -84,10 +84,10 @@ */ &#125;; -disp_timings: display-timings &#123;- native-mode = &lt;&amp;timing0&gt;;+display-timings &#123;+ native-mode = &lt;&amp;tv080wum_nl0_mipi&gt;; compatible = &quot;rockchip,display-timings&quot;;- timing0: timing0 &#123;+ tv080wum_nl0_mipi: timing0 &#123; screen-type = &lt;SCREEN_MIPI&gt;; lvds-format = &lt;LVDS_8BIT_2&gt;; out-face = &lt;OUT_P888&gt;;diff --git a/include/linux/rk_fb.h b/include/linux/rk_fb.hindex d7634a8..1130ea4 100755--- a/include/linux/rk_fb.h+++ b/include/linux/rk_fb.h@@ -811,7 +811,10 @@ extern int rk_fb_get_prmry_screen( struct rk_screen *screen); extern int rk_fb_set_prmry_screen(struct rk_screen *screen); extern u32 rk_fb_get_prmry_screen_pixclock(void);-extern int rk_disp_pwr_ctr_parse_dt(struct rk_lcdc_driver *dev_drv);+extern int rk_fb_get_screen(struct rk_screen *screen, int prop);+extern int rk_fb_set_screen(struct rk_screen *screen, int prop);+extern int rk_disp_pwr_ctr_parse_dt(struct device_node *np,+ struct rk_screen *rk_screen); extern int rk_disp_pwr_enable(struct rk_lcdc_driver *dev_drv); extern int rk_disp_pwr_disable(struct rk_lcdc_driver *dev_drv); extern bool is_prmry_rk_lcdc_registered(void);diff --git a/include/linux/rk_screen.h b/include/linux/rk_screen.hindex 5e5cd30..71a0d4d 100644--- a/include/linux/rk_screen.h+++ b/include/linux/rk_screen.h@@ -61,13 +61,17 @@ *ft: the time need to display one frame time */ struct rk_screen &#123;- u16 type;+ struct device *dev;+ int prop; u16 refresh_mode;+ struct list_head *pwrlist_head;+ u16 type; u16 lvds_format; u16 face; u16 color_mode; u8 lcdc_id; u8 screen_id;+ int native_mode; struct fb_videomode mode; u32 post_dsp_stx; u32 post_dsp_sty;@@ -145,7 +149,7 @@ &#125;; extern void set_lcd_info(struct rk_screen *screen, struct rk29lcd_info *lcd_info);-extern size_t get_fb_size(u8 reserved_fb);+extern size_t get_fb_size(u8 reserved_fb, struct rk_screen *screen); extern void set_tv_info(struct rk_screen *screen); extern void set_hdmi_info(struct rk_screen *screen);","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 双屏异显代码实现流程分析","slug":"Android_Driver/Driver/[Android6.0][RK3399] 双屏异显代码实现流程分析（一）","date":"2017-11-30T19:33:05.000Z","updated":"2018-11-08T02:41:55.821Z","comments":true,"path":"2017/12/01/Android_Driver/Driver/[Android6.0][RK3399] 双屏异显代码实现流程分析（一）/","link":"","permalink":"http://iyounix.com/2017/12/01/Android_Driver/Driver/[Android6.0][RK3399] 双屏异显代码实现流程分析（一）/","excerpt":"","text":"Platform: RK3399OS: Android 6.0Version: v2016.08 [TOC] 本文分为两部分。《[RK3399] 双屏异显代码实现流程分析（一）》为分析 RK video 部分标准的代码（base on 2017.2.13 updated）《[RK3399] 双屏异显代码实现流程分析（二）》为打上双屏异显 patch 后的代码流程分析（eDP + mipi） 代码流程参考 KrisFei 大神总结的 3288 display 模块加载流程。http://blog.csdn.net/kris_fei/article/details/52584903KrisFei 归纳的代码流程如下： mipi dsi 接口信息初始化 fb相关信息读取 timing参数初始化 mipi dsi controller初始化 lcdc控制器注册 代码详解在 RK3399 上代码没有太大的变化。下面为 display 部分的标准流程。 在 make menuconfig 配置的时候 Location: | -&gt; Device Drivers | -&gt; Graphics support | -&gt; Rockchip Misc Video driver | -&gt; LCD Panel Select ( [=y]) drivers/video/rockchip/screen/Kconfig choice 包括 General lcd panel 和 rk mipi dsi lcd 差别是 12345&lt; # CONFIG_LCD_GENERAL is not set&lt; CONFIG_LCD_MIPI=y---&gt; CONFIG_LCD_GENERAL=y&gt; # CONFIG_LCD_MIPI is not set 分别对应的驱动文件是lcd_general.clcd_mipi.c 现在的版本（2017.2.13）中，lcd_general.c 还未实现代码。所以我们从分析默认的 lcd_mipi.c 开始。 mipi dsi 接口信息初始化lcd_mipi.crk_mipi_screen_init -&gt; platform_driver_probe -&gt; //name是rk_mipi_screen rk_mipi_screen_probe -&gt; rk_mipi_screen_init_dt //读取mipi信息（包括 screen_init）,dsi_lane,dsi_hs_clk,mipi_dsi_num, power, rst, gpio, 屏幕的 timing 信息（包括 sceen on cmds, cmd_type, cmd_delay, cmd_debug） fb相关信息读取rk_fb_init -&gt; rk_fb.c platform_driver_register -&gt; //name: “rockchip,rk-fb” rk_fb_probe -&gt; //获取disp-mode, u-boot-logo-on等参数。 rockchip_ion_client_create //创建ion client。 / ION与PMEM类似，管理一或多个内存池，其中有一些会在boot time的时候预先分配，以备给特殊的硬件使用（GPU，显示控制器等）。它通过ION heaps来管理这些pool。它可以被userspace的process之间或者内核中的模块之间进行内存共享。/ timing 参数初始化//不管是那种接口类型的lcd,lcd的时序参数都是要读取的。rk_screen_init -&gt; rk_screen.c platform_driver_register -&gt; //name: “rk-screen” rk_screen_probe -&gt; rk_fb_prase_timing_dt -&gt; rk_fb.c //读取来的配置存在结构体 rk_screen 变量中 of_get_display_timing //获取时序参数，dts中可以配置多组，这里会循环读取。 display_timings_get //根据当前native-mode来选取当前使用哪组时序参数。 rk_fb_video_mode_from_timing //把 timing转换到fb video mode中去供后续使用。 mipi dsi controller 初始化//如果是另外的接口那就调用相应的接口控制器驱动来初始化.rk32_mipi_dsi_init -&gt; rk32_mipi_dsi.c platform_driver_register -&gt; //name: “rk32-mipi” rk32_mipi_dsi_probe -&gt; //初始化struct dsi结构,包括clock, dsi ops, rk_screen 传递过来的参数, rk_fb_get_prmry_screen -&gt; rk_screen.c //获取在之前 rk_screen_probe() 中初始化的rk_screen变量. //rk_mipi_dsi_probe -&gt; //这个在 3399 代码中没有了 register_dsi_ops //dsi-&gt;ops给dsi_ops //dsi_probe_current_chip //检测dsi chip是否存在，这个在 3399 的代码中没有了 rk_fb_trsm_ops_register //注册trsm_mipi_ops为trsm_dsi_ops 这里 3288 中的 rk_mipi_dsi_probe 在 3399 中被删掉了直接在 rk_fb_get_prmry_screen 中 register_dsi_ops，也省略掉了 dsi_probe_current_chip lcdc控制器注册：rk3368_lcdc_module_init -&gt; rk3368_lcdc.c platform_driver_register -&gt; //.name = “rk3368-lcdc”, rk3368_lcdc_probe -&gt; of_property_read_u32(np, “rockchip,prop”, &amp;prop);//判断屏幕是 primary 还是 extend，如果是 extend 会延后 register rk3368_lcdc_parse_dt //读取lcdc控制器的参数 dev_drv-&gt;ops = &lcdc_drv_ops; //lcdc对应ops devm_request_irq //lcdc对应irq是rk3368_lcdc_isr() rk_fb_register -&gt; //对应ops是lcdc_drv_ops rk_fb-&gt;lcdc_dev_drv[i] = dev_drv; //根据 RK30_MAX_LCDC_SUPPORT，循环注册两组 lcdc_dev_drv init_lcdc_device_driver -&gt; //初始化 lcdc_device_driver init_lcdc_win //一个lcdc能支持4层win. rk_disp_pwr_ctr_parse_dt //解析lcdc power ctrl相关内容。 rk_fb_set_prmry_screen rk_fb_trsm_ops_get //根据不同的屏幕类型选择对应的ops. framebuffer_alloc //系统根据 win 的多少来创建相应数量的 fb fb_videomode_to_var //将 fb_videomode 转化为 fb_var_screeninfo dsp_mode == ONE_VOP_DUAL_MIPI_VER_SCAN //判断双屏同显的刷新方式，这里如果是垂直刷新的话 //设置 fbi-&gt;var.xres /= 2;fbi-&gt;var.yres = 2; fbi-&gt;var.xres_virtual /= 2; fbi-&gt;var.yres_virtual = 2; fbi-&gt;fbops = &fb_ops; //fb ops rkfb_create_sysfs //生成到/dev/graphics/fbx/下 register_framebuffer rkfb_create_sysfs //以下 code 只跑一次 kthread_run //创建rk_fb_wait_for_vsync_thread dev_drv-&gt;ops-&gt;post_dspbuf //show logo for primary display device","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 电源管理系统","slug":"Android_Driver/Driver/[Android6.0][RK3399] 电池管理系统","date":"2017-08-31T15:33:05.000Z","updated":"2018-11-08T02:43:42.132Z","comments":true,"path":"2017/08/31/Android_Driver/Driver/[Android6.0][RK3399] 电池管理系统/","link":"","permalink":"http://iyounix.com/2017/08/31/Android_Driver/Driver/[Android6.0][RK3399] 电池管理系统/","excerpt":"","text":"[TOC] 本文是对 wowotech.net 上讲解电源管理系统系列相关文章的学习笔记。原文地址 http://www.wowotech.net/pm_subsystem/pm_architecture.html 一、基本概念电源管理（Power Management）在Linux Kernel中，是一个比较庞大的子系统，涉及到供电（Power Supply）、充电（Charger）、时钟（Clock）、频率（Frequency）、电压（Voltage）、睡眠/唤醒（Suspend/Resume）等方方面面。 1.1 Hibernate（冬眠）和Sleep（睡眠）是Linux电源管理在用户角度的抽象，是用户可以看到的实实在在的东西。它们的共同点，是保存系统运行的上下文后挂起（suspend）系统，并在系统恢复后接着运行，就像什么事情都没有发生一样。它们的不同点，是上下文保存的位置、系统恢复的触发方式以及具体的实现机制。 1.2 Suspend有两个层次的含义。一是Hibernate和Sleep功能在底层实现上的统称，都是指挂起（Suspend）系统，根据上下文的保存位置，可以分为Suspend to Disk（STD，即Hibernate，上下文保存在硬盘/磁盘中）和Suspend to RAM（STR，为Sleep的一种，上下文保存在RAM中）；二是Sleep功能在代码级的实现，表现为“kernel/power/suspend.c”文件。 1.3 Standby是Sleep功能的一个特例，可以翻译为“打盹”。正常的Sleep（STR），会在处理完上下文后，由arch-dependent代码将CPU置为低功耗状态（通常为Sleep）。而现实中，根据对功耗和睡眠唤醒时间的不同需求，CPU可能会提供多种低功耗状态，如除Sleep之外，会提供Standby状态，该状态下，CPU处于浅睡眠模式，有任何的风吹草动，就会立即醒来。 1.4 Wakeup这是我们第一次正式的提出Wakeup的概念。我们多次提到恢复系统，其实在内核中称为Wakeup。表面上，wakeup很简单，无论是冬眠、睡眠还是打盹，总得有一个刺激让我们回到正常状态。但复杂的就是，什么样的刺激才能让我们醒来？动物界，温度回升可能是唯一可以让动物从冬眠状态醒来的刺激。而踢一脚、闹钟响等刺激，则可以让我们从睡眠状态唤醒。对于打盹来说，则任何的风吹草动，都可以唤醒。而在计算机界，冬眠（Hibernate）时，会关闭整个系统的供电，因此想醒来，唯有Power按钮可用。而睡眠时，为了缩短Wakeup时间，并不会关闭所有的供电，另外，为了较好的用户体验，通常会保留某些重要设备的供电（如键盘），那样这些设备就可以唤醒系统。这些刻意保留下来的、可以唤醒系统的设备，统称为唤醒源（Wakeup source）。而Wakeup source的选择，则是PM设计工作（特别是Sleep、Standby等功能）的重点。 二、Generic PM传统的常规电源管理 包括关机（Power off）、待机（Standby or Hibernate）、重启（Reboot）、冬眠（Hibernate）、睡眠（Sleep 或被称为 Suspend）。wowtech 在文章中给这种常规的电源管理起名为 Generic PM，它是和 Runtime PM 相对的。 软件架构如下： 根据上面的描述可知，Generic PM大致可以分为三个软件层次：API Layer，用于向用户空间提供接口，其中关机和重启的接口形式是系统调用（在新的内核中，关机接口还有一种新方式，具体讲到的时候再说），Hibernate和Suspend的接口形式是sysfs。PM Core，位于kernel/power/目录下，主要处理和硬件无关的核心逻辑。PM Driver，分为两个部分，一是体系结构无关的Driver，提供Driver框架（Framework）。另一部分是具体的体系结构相关的Driver，这也是电源管理驱动开发需要涉及到的内容（图中红色边框的模块）。 2.1 Generic PM RebootRESTART，正常的重启，也是我们平时使用的重启。执行该动作后，系统会重新启动。HALT，停止操作系统，然后把控制权交给其它代码（如果有的话）。具体的表现形式，依赖于系统的具体实现。CAD_ON/CAD_OFF，允许/禁止通过Ctrl-Alt-Del组合按键触发重启（RESTART）动作。注1：Ctrl-Alt-Del组合按键的响应是由具体的Driver（如Keypad）实现的。POWER_OFF，正常的关机。执行该动作后，系统会停止操作系统，并去除所有的供电。RESTART2，重启的另一种方式。可以在重启时，携带一个字符串类型的cmd，该cmd会在重启前，发送给任意一个关心重启事件的进程，同时会传递给最终执行重启动作的machine相关的代码。内核并没有规定该cmd的形式，完全由具体的machine自行定义。 2.2 Power Managent InterfacePM Interface 的功能，对下，定义了 Device PM 相关的回调函数。对上，实现了 PM 统一的操作函数，供 PM 核心逻辑调用。 旧版内核中，PM callbacks 分布在设备模型的大型数据结构中，如 struct bus_type 中的 suspend、suspend_late、resume、resume_late，如 struct device_driver/struct class/struct device_type中的suspend、resume。随着设备复杂度的增加，这些 suspend 和 resume 已经不能满足电源管理的需求，就需要扩充 PM callbacks ，所以会影响这些数据结构。 新版本的内核中，PM callbacks 被统一封装为一个数据结构 struct dev_pm_ops，上层的数据结构只需要包含这个结构即可。为兼容旧版本也仍然存在 suspend 和 resume ，但是不建议使用。 1234567891011121314151617181920212223242526 1: /* include/linux/pm.h, line 276 in linux-3.10.29 */ 2: struct dev_pm_ops &#123; 3: int (*prepare)(struct device *dev); 4: void (*complete)(struct device *dev); 5: int (*suspend)(struct device *dev); 6: int (*resume)(struct device *dev); 7: int (*freeze)(struct device *dev); 8: int (*thaw)(struct device *dev); 9: int (*poweroff)(struct device *dev);10: int (*restore)(struct device *dev);11: int (*suspend_late)(struct device *dev);12: int (*resume_early)(struct device *dev);13: int (*freeze_late)(struct device *dev);14: int (*thaw_early)(struct device *dev);15: int (*poweroff_late)(struct device *dev);16: int (*restore_early)(struct device *dev);17: int (*suspend_noirq)(struct device *dev);18: int (*resume_noirq)(struct device *dev);19: int (*freeze_noirq)(struct device *dev);20: int (*thaw_noirq)(struct device *dev);21: int (*poweroff_noirq)(struct device *dev);22: int (*restore_noirq)(struct device *dev);23: int (*runtime_suspend)(struct device *dev);24: int (*runtime_resume)(struct device *dev);25: int (*runtime_idle)(struct device *dev);26: &#125;; PM Core 会在特定的电源管理阶段，调用相应的 callbacks，比如 suspend/resume 的过程中，函数调用链如下：prepare—&gt;suspend—&gt;suspend_late—&gt;suspend_noirq—wakeup—-&gt;resume_noirq—&gt;resume_early—&gt;resume—&gt;complete。 1234567891011121314151617181920212223242526272829 1: struct bus_type &#123; 2: ... 3: const struct dev_pm_ops *pm; 4: ... 5: &#125;; 6: 7: struct device_driver &#123; 8: ... 9: const struct dev_pm_ops *pm;10: ...11: &#125;;12: 13: struct class &#123;14: ...15: const struct dev_pm_ops *pm;16: ...17: &#125;;18: 19: struct device_type &#123;20: ...21: const struct dev_pm_ops *pm;22: &#125;;23: 24: struct device &#123;25: ...26: struct dev_pm_info power;27: struct dev_pm_domain *pm_domain;28: ...29: &#125;; 重点关注 device 结构中的 power 和 pm_domain 变量。power 变量类型是 struct dev_pm_info保存 PM 相关的状态：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354struct dev_pm_info &#123;559 pm_message_t power_state; //当前的 power 状态560 unsigned int can_wakeup:1; //是否可以被唤醒561 unsigned int async_suspend:1;562 bool is_prepared:1; /* Owned by the PM core */ //是否 prepared 完成563 bool is_suspended:1; /* Ditto */ //是否 suspended 完成564 bool is_noirq_suspended:1;565 bool is_late_suspended:1;566 bool ignore_children:1;567 bool early_init:1; /* Owned by the PM core */568 bool direct_complete:1; /* Owned by the PM core */569 spinlock_t lock;570 #ifdef CONFIG_PM_SLEEP571 struct list_head entry;572 struct completion completion;573 struct wakeup_source *wakeup;574 bool wakeup_path:1;575 bool syscore:1;576 bool no_pm_callbacks:1; /* Owned by the PM core */577 #else578 unsigned int should_wakeup:1;579 #endif580 #ifdef CONFIG_PM581 struct timer_list suspend_timer;582 unsigned long timer_expires;583 struct work_struct work;584 wait_queue_head_t wait_queue;585 struct wake_irq *wakeirq;586 atomic_t usage_count;587 atomic_t child_count;588 unsigned int disable_depth:3;589 unsigned int idle_notification:1;590 unsigned int request_pending:1;591 unsigned int deferred_resume:1;592 unsigned int run_wake:1;593 unsigned int runtime_auto:1;594 unsigned int no_callbacks:1;595 unsigned int irq_safe:1;596 unsigned int use_autosuspend:1;597 unsigned int timer_autosuspends:1;598 unsigned int memalloc_noio:1;599 enum rpm_request request;600 enum rpm_status runtime_status;601 int runtime_error;602 int autosuspend_delay;603 unsigned long last_busy;604 unsigned long active_jiffies;605 unsigned long suspended_jiffies;606 unsigned long accounting_timestamp;607 #endif608 struct pm_subsys_data *subsys_data; /* Owned by the subsystem. */609 void (*set_latency_tolerance)(struct device *, s32);610 struct dev_pm_qos *qos;611 &#125;; pm_domain 指针PM domain 是针对 device 而言的，通过 PM domain 实现没有 driver 的 device 的电源管理。1234567891011121314151617617 /*618 * Power domains provide callbacks that are executed during system suspend,619 * hibernation, system resume and during runtime PM transitions along with620 * subsystem-level and driver-level callbacks.621 *622 * @detach: Called when removing a device from the domain.623 * @activate: Called before executing probe routines for bus types and drivers.624 * @sync: Called after successful driver probe.625 * @dismiss: Called after unsuccessful driver probe and after driver removal.626 */627 struct dev_pm_domain &#123;628 struct dev_pm_ops ops;629 void (*detach)(struct device *dev, bool power_off);630 int (*activate)(struct device *dev);631 void (*sync)(struct device *dev);632 void (*dismiss)(struct device *dev);633 &#125;; 2.3 device PM callbacks API为了操作 device PM callbacks 数据结构，定义了大量 API。分为两类：通用的辅助性质类 API：直接调用指定设备所绑定的driver的、pm指针的、相应的callback比如 pm_generic_prepare，查看dev-&gt;driver-&gt;pm-&gt;prepare接口是否存在，如果存在，直接调用并返回结果。 整体电源管理行为相关 API：将各个独立的电源管理行为组合起来，组成一个较为简单的功能比如 dpm_prepare，执行所有设备的“-&gt;prepare() callback(s)”比如 dpm_suspend，执行所有设备的“-&gt;suspend() callback(s)”比如 dpm_suspend_start，依次执行dpm_prepare和dpm_suspend两个动作比如 dpm_suspend_end，依次执行所有设备的“-&gt;suspend_late() callback(s)”以及所有设备的“-&gt;suspend_noirq() callback(s)”上面是休眠相关的。dpm_resume、dpm_complete、dpm_resume_start、dpm_resume_end，是电源管理过程的唤醒动作。和上面类似。 三、Hibernnate &amp; SleepHibernate和Sleep两个功能是Linux Generic PM的核心功能，它们的目的是类似的：暂停使用——&gt;保存上下文——&gt;关闭系统以节电········&gt;恢复系统——&gt;恢复上下文——&gt;继续使用 3.1 软件架构 API Layer 描述用户空间 API 的一个抽象层。PM Core 电源管理的核心逻辑层。包括：主功能，负责 global APIs 相关逻辑，为用户空间提供 APISTD，包括hibernate、snapshot、swap、block_io等子模块，负责实现STD功能和硬件无关的逻辑STR&amp;Stanby，包括suspend和suspend_test两个子模块，负责实现STR、Standby等功能和硬件无关的逻辑PM Driver 电源管理驱动层，涉及体系结构无关驱动、体系结构有关驱动、设备模型以及各个设备驱动等多个软件模块 3.2 用户空间接口","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 电池系统（二）BQ IC 添加 DC 充电功能","slug":"Android_Driver/Driver/[Android6.0][RK3399] 电池系统（二）BQ IC 添加 DC 充电功能","date":"2017-08-31T15:33:05.000Z","updated":"2018-11-08T02:46:54.118Z","comments":true,"path":"2017/08/31/Android_Driver/Driver/[Android6.0][RK3399] 电池系统（二）BQ IC 添加 DC 充电功能/","link":"","permalink":"http://iyounix.com/2017/08/31/Android_Driver/Driver/[Android6.0][RK3399] 电池系统（二）BQ IC 添加 DC 充电功能/","excerpt":"","text":"Platform: RK3399OS: Android 6.0Kernel: 4.4Version: v2017.04IC: TI BQ25700、RK808 在上一章 [RK3399] Android 电池系统(一) BQ25700 IC 驱动分析 中我们分析了 BQ IC 的驱动加载流程。 我们也知道了平台默认的代码，定位是 PD 充电，不支持 DC 充电。这一章我们来添加 DC 充电的功能。 解决思路首先我们知道 DC 插入的时候， CHG_OK_H 会被拉高。所以我们思考是否可以在 CHG_OK 的中断处理函数中完成对 BQ IC DC 充电功能的配置。但是当 TypeC 适配器插入的时候，CHG_OK_H 也会被拉高。不过利用 TypeC 充电时候的配置和 利用 DC 充电的配置是相同的。 另外需要说明的是，硬件上实现了，在插入 DC 的时候，会关断 TypeC 的供电。以方式两边同时往板子充电而引起的异常。 所以，一共有以下几种情况：仅插上 TypeC 适配器，代码默认实现正常充电。仅插上 DC 适配器，在 CHG_OK 中断处理函数中完成充电配置。插上 TypeC 适配器后，再插入 DC 适配器，不会触发中断处理函数，但是在 BQ IC 中的配置此时是适用于 DC 充电的。所以没问题。硬件上 TypeC 充电被关断。插上 DC 适配器后，再插入 TypeC 适配器，先利用中断处理函数中对 BQ IC 的配置进行充电。由于硬件上此时已经关断了 TypeC 充电。所以没问题。 分析得知这样是可行的，那么我们开始在 CHG_OK 的中断处理函数中完成对 BQ IC 的操作。 代码添加根据 datasheet ，我们了解到开启 BQ IC 充电需要完成 INPUT_CURRENT 与 CHARGE_CURRENT 寄存器的写操作。其次，深入 TypeC 检测后的处理函数，我们也可以看到最后其是调用了 bq25700_enable_charger 完成充电：123456static void bq25700_enable_charger(struct bq25700_device *charger, u32 input_current)&#123; bq25700_field_write(charger, INPUT_CURRENT, input_current); bq25700_field_write(charger, CHARGE_CURRENT, charger-&gt;init_data.ichg);&#125; 那么我们仿照其使能 BQ IC 充电的方式来完成中断处理函数中的操作：123456789101112131415161718192021222324252627282930313233343536373839404142434445bq25700_probe&#123;... ret = devm_request_threaded_irq(dev, client-&gt;irq, NULL, bq25700_irq_handler_thread, irq_flag | IRQF_ONESHOT , &quot;bq25700_irq&quot;, charger); if (ret)...&#125;static irqreturn_t bq25700_irq_handler_thread(int irq, void *private)&#123; struct bq25700_device *charger = private; int irq_flag; struct bq25700_state state; DBG(&quot;BQ25700: bq25700_irq_handler_thread\\n&quot;); if (bq25700_field_read(charger, AC_STAT)) &#123; irq_flag = IRQF_TRIGGER_LOW;++ bq25700_field_write(charger, INPUT_CURRENT, charger-&gt;init_data.input_current_cdp);++ bq25700_field_write(charger, CHARGE_CURRENT, charger-&gt;init_data.ichg);++ bq25700_get_chip_state(charger, &amp;state);++ charger-&gt;state = state;++ power_supply_changed(charger-&gt;supply_charger);++ DBG(&quot;BQ25700: set irq_flag = IRQF_TRIGGER_LOW\\n&quot;); &#125; else &#123; irq_flag = IRQF_TRIGGER_HIGH; bq25700_field_write(charger, INPUT_CURRENT, charger-&gt;init_data.input_current); bq25700_disable_charge(charger); bq25700_get_chip_state(charger, &amp;state); charger-&gt;state = state; power_supply_changed(charger-&gt;supply_charger); charger-&gt;typec0_status = USB_STATUS_NONE; charger-&gt;typec1_status = USB_STATUS_NONE;++ DBG(&quot;BQ25700:set irq_flag = IRQF_TRIGGER_HIGH\\n&quot;); &#125; irq_set_irq_type(irq, irq_flag | IRQF_ONESHOT ); rk_send_wakeup_key(); DBG(&quot;BQ25700: bq25700_irq_handler_thread done\\n&quot;); return IRQ_HANDLED;&#125; 验证结果在插拔 DC 的时候我们1cat /sys/class/i2c-adapter/i2c-4/4-0009/charge_info 发现插入 DC 时充电电流为 2.3 A，表示其是可以正常工作的。 遇到 Bug过程中遇到两个问题。第一个问题是使能 BQ IC 充电的方式当时查阅 Datasheet 发现说需要 给 CHRG_INHIBIT 写 0 ，表示使能 BQ IC。写 1 表示禁能 BQ IC。如下：1bq25700_field_write(charger, CHRG_INHIBIT, 0); 所以我就这样写了，但是这个导致的问题是输入电流极大，为 3.25A。再仔细查阅 datasheet 发现，如果采用 CHRG_INHIBIT 来使能 BQ IC 的话，会自动对 INPUT_CURRENT 配置，默认为 3.25A。 第二个问题很蠢如下完成写这两个寄存器12bq25700_field_write(charger, INPUT_CURRENT, charger-&gt;init_data.input_current);bq25700_field_write(charger, CHARGE_CURRENT, charger-&gt;init_data.ichg); 我们 dts 是这样配的123456ti,charge-current = &lt;2500000&gt;;ti,input-current = &lt;2000000&gt;; //2Ati,input-current-sdp = &lt;500000&gt;;ti,input-current-dcp = &lt;2000000&gt;;ti,input-current-cdp = &lt;2000000&gt;;ti,minimum-sys-voltage = &lt;7400000&gt;; 看起来这样就是配置 INPUT_CURRENT 为 2A 、配置 CHAGRE_CURRENT 为 2.5A 了？错！实际上在 dts 解析的过程是没有解析 input_current 的，也就是说其是为 0 的：123456789101112131415161718192021222324struct &#123; char *name; bool optional; enum bq25700_table_ids tbl_id; u32 *conv_data; /* holds converted value from given property */&#125; props[] = &#123; /* required properties */ &#123;&quot;ti,charge-current&quot;, false, TBL_ICHG, &amp;init-&gt;ichg&#125;, &#123;&quot;ti,max-charge-voltage&quot;, false, TBL_CHGMAX, &amp;init-&gt;max_chg_vol&#125;, &#123;&quot;ti,input-current-sdp&quot;, false, TBL_INPUTCUR, &amp;init-&gt;input_current_sdp&#125;, &#123;&quot;ti,input-current-dcp&quot;, false, TBL_INPUTCUR, &amp;init-&gt;input_current_dcp&#125;, &#123;&quot;ti,input-current-cdp&quot;, false, TBL_INPUTCUR, &amp;init-&gt;input_current_cdp&#125;, &#123;&quot;ti,minimum-sys-voltage&quot;, false, TBL_SYSVMIN, &amp;init-&gt;sys_min_voltage&#125;, &#123;&quot;ti,otg-voltage&quot;, false, TBL_OTGVOL, &amp;init-&gt;otg_voltage&#125;, &#123;&quot;ti,otg-current&quot;, false, TBL_OTGCUR, &amp;init-&gt;otg_current&#125;,&#125;; 所以要充 2A 应该改为1bq25700_field_write(charger, INPUT_CURRENT, charger-&gt;init_data.input_current_cdp);","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 电池系统（三）电量计 CW2015 驱动流程分析","slug":"Android_Driver/Driver/[Android6.0][RK3399] 电池系统（三）电量计 CW2015 驱动流程分析","date":"2017-08-31T15:33:05.000Z","updated":"2018-11-08T02:44:44.223Z","comments":true,"path":"2017/08/31/Android_Driver/Driver/[Android6.0][RK3399] 电池系统（三）电量计 CW2015 驱动流程分析/","link":"","permalink":"http://iyounix.com/2017/08/31/Android_Driver/Driver/[Android6.0][RK3399] 电池系统（三）电量计 CW2015 驱动流程分析/","excerpt":"","text":"已知问题cw2015 的代码默认是 rk3288 平台的，3399 平台有一些接口已经升级。所以默认编译是无法通过的。所以当前的问题是进行代码的修改以适用于当前 3399 平台。磨刀不误砍柴工，我们先磨好刀，下一章再开始砍柴。 驱动分析我在驱动中添加了 cw_init_power_supply 和 cw_turn_on_bq_hw_init。在前者里面完成了 power_supply 设备的注册（利用升级后的 register_power_supply 接口）在后者中完成了电池状态的检测，并传给 bq25700_charger IC。 函数调用链12345678910111213141516171819202122232425cw_bat_probe cw2015_parse_dt // 解析 dts。 // 包括 bat_config_info、dc_det_gpio、bat_low_gpio、chg_ok_gpio // chg_mode_sel_gpio、 // is_dc_charge 是否支持 dc 充电 // is_usb_charge 是否支持 usb 充电 cw_bat_gpio_init // 申请 GPIO 并分配 dc_det_gpio、bat_low_gpio、chg_ok_gpio 为 input // 分配 chg_mode_sel_gpio 为 output cw_init // 初始化 cw2015 的寄存器。 // 设置工作模式，如果是 SLEEP MODE 就将其唤醒进入 NORMAL MODE; // 设置警报寄存器 ATHD; // 更新还未设置的寄存器信息 cw_init_power_supply // 注册 power_supply 设备（三种 battery、usb、ac） cw_update_time_member_capacity_change // 更新到现在开始充电系统启动的用时，以及到现在为止系统休眠了多长时间 cw_update_time_member_charge_start // 更新到现在电量改变系统启动的用时，以及到现在为止系统休眠了多长时间 battery_workqueue = create_singlethread_workqueue // 创建单线程工作队列 rk_battery INIT_DELAYED_WORK // 初始化 cw_bat_work 绑定到 battery_delay_work cw_bat_work // 不断更新电池信息 rk_ac_update_online // 更新 DC 状态 power_supply_changed(cw_bat-&gt;rk_ac) // rk_usb_update_online // 更新 usb 状态 power_supply_changed(cw_bat-&gt;rk_usb) INIT_DELAYED_WORK // 初始化 dc_detect_do_wakeup 绑定到 dc_wakeup_work dc_detect_do_wakeup // 获取 dc_det irq 号，根据现在中断状态来设置下一次中断的触发条件 cw_turn_on_bq_hw_init // 获取 VCELL Voltage 并且传递标志位给 BQ IC 的驱动，用以决定是否配置 BQ IC","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 电池系统（四）不插电池无法开机的问题","slug":"Android_Driver/Driver/[Android6.0][RK3399] 电池系统（四）不插电池无法开机的问题","date":"2017-08-31T15:33:05.000Z","updated":"2018-11-08T02:47:21.269Z","comments":true,"path":"2017/08/31/Android_Driver/Driver/[Android6.0][RK3399] 电池系统（四）不插电池无法开机的问题/","link":"","permalink":"http://iyounix.com/2017/08/31/Android_Driver/Driver/[Android6.0][RK3399] 电池系统（四）不插电池无法开机的问题/","excerpt":"","text":"[TOC] 在前面我们 分析了 Charger IC BQ25700 的驱动流程 添加了 BQ IC 的 DC 充电功能 分析了 电量计 CW2015 的驱动流程 在这一章，我们完成电量计的移植，并且整合电量计与充电IC。使其协同为电池工作。 已知问题与需求分析现在的 BQ IC Driver 有一个大 Bug。在接上电池的时候，Battery、Battery+TypeC、Battery+DC 都是可以正常开机的。但是没有电池的时候，单独 TypeC 或者 DC 开机是有问题的。 RK 反馈他们那边也有这个问题，定位问题在于 bq25600_hw_init ，BQ IC 的初始化配置。当屏蔽该函数的时候，单独 TypeC 或者 DC 是可以正常开机的。但是电池的正常工作又必须依赖于它的初始化。 解决思路三条： 寻找 DC / TypeC 开机时对 BQ IC 寄存器初始化的操作 和 bq_hw_init 中进行的操作对比。 在 dts 中配置一个标志位，has_battery，当 has_battery = 1 的时候，加载 bq_hw_init ，没有的时候屏蔽 bq_hw_init 利用 cw2015 电量计 IC ，检测是否有无电池，并根据检测结果决定是否屏蔽 bq_hw_init。 1 当然是正解。但是寻求了 BQ IC FAE 的帮助，无果，他们反馈理论上 bq_hw_init 中的配置是没问题的，不因采用哪种供电方式而发生改变。2 缺陷是会生成两套 resource.img ，根据不同的条件使用不同的 resource.img ，这显然是不好的3 需要移植 cw2015。 综上，只能选择第三种方式了 代码移植dtsdts 中 对于 cw2015 的配置12345678910111213 cw2015@62 &#123; compatible = \"cw201x\"; reg = &lt;0x62&gt;; dc_det_gpio = &lt;&amp;gpio1 23 GPIO_ACTIVE_LOW&gt;; // DC_DET_H GPIO1_C7 //bat_low_gpio = &lt;&amp;gpio0 GPIO_A7 GPIO_ACTIVE_LOW&gt;; //chg_ok_gpio = &lt;&amp;gpio1 1 GPIO_ACTIVE_HIGH&gt;; // CHG_OK_H GPIO1_A1 bat_config_info = &lt;0x15 0x42 0x60 0x59 0x52 0x58 0x4D 0x48 0x48 0x44 0x44 0x46 0x49 0x48 0x32 0x24 0x20 0x17 0x13 0x0F 0x19 0x3E 0x51 0x45 0x08 0x76 0x0B 0x85 0x0E 0x1C 0x2E 0x3E 0x4D 0x52 0x52 0x57 0x3D 0x1B 0x6A 0x2D 0x25 0x43 0x52 0x87 0x8F 0x91 0x94 0x52 0x82 0x8C 0x92 0x96 0xFF 0x7B 0xBB 0xCB 0x2F 0x7D 0x72 0xA5 0xB5 0xC1 0x46 0xAE&gt;; is_dc_charge = &lt;1&gt;; is_usb_charge = &lt;1&gt;;&#125;; Makefile 和 Kconfig//Todoobj-y cw2015_battery.c修改 cw2015_battery 的代码是适用于 rk3288 平台的，有些接口进行了升级。包括 i2c_master_reg8_send/write 和 register_power_supply并且我们还 定义了 have_battery 标志位，判断出电池有无，并将标志位送给 bq 进行下一步电池初始化的操作。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313diff --git a/drivers/power/cw2015_battery.c b/drivers/power/cw2015_battery.cindex aaf01fc..5e35216 100755--- a/drivers/power/cw2015_battery.c+++ b/drivers/power/cw2015_battery.c@@ -28,6 +28,12 @@ #include &lt;linux/power/cw2015_battery.h&gt; +int have_battery;++#define VCELL_VOLTAGE 3000000+#define DEBUG 1+#define DOUBLE_SERIES_BATTERY 1+ static int i2c_master_reg8_send(const struct i2c_client *client, const char reg, const char *buf, int count, int scl_rate) &#123;@@ -47,7 +53,7 @@ static int i2c_master_reg8_send(const struct i2c_client *client, const char reg, msg.flags = client-&gt;flags; msg.len = count + 1; msg.buf = (char *)tx_buf;- msg.scl_rate = scl_rate;+ //msg.scl_rate = scl_rate; ret = i2c_transfer(adap, &amp;msg, 1); kfree(tx_buf);@@ -67,13 +73,13 @@ static int i2c_master_reg8_recv(const struct i2c_client *client, const char reg, msgs[0].flags = client-&gt;flags; msgs[0].len = 1; msgs[0].buf = &amp;reg_buf;- msgs[0].scl_rate = scl_rate;+ //msgs[0].scl_rate = scl_rate; msgs[1].addr = client-&gt;addr; msgs[1].flags = client-&gt;flags | I2C_M_RD; msgs[1].len = count; msgs[1].buf = (char *)buf;- msgs[1].scl_rate = scl_rate;+ //msgs[1].scl_rate = scl_rate; ret = i2c_transfer(adap, msgs, 2); @@ -562,6 +568,9 @@ static int cw_get_vol(struct cw_battery *cw_bat) &#125; voltage = value16_1 * 305;+ + if(DOUBLE_SERIES_BATTERY)+ voltage = voltage * 2; dev_dbg(&amp;cw_bat-&gt;client-&gt;dev, &quot;the cw201x voltage=%d,reg_val=%x %x\\n&quot;, voltage, reg_val[0], reg_val[1]);@@ -813,14 +822,14 @@ static void cw_bat_work(struct work_struct *work) if (cw_bat-&gt;plat_data.is_dc_charge == 1) &#123; ret = rk_ac_update_online(cw_bat); if (ret == 1)- power_supply_changed(&amp;cw_bat-&gt;rk_ac);+ power_supply_changed(cw_bat-&gt;rk_ac); &#125; if (cw_bat-&gt;plat_data.is_usb_charge == 1) &#123; ret = rk_usb_update_online(cw_bat); if (ret == 1) &#123;- power_supply_changed(&amp;cw_bat-&gt;rk_usb);- power_supply_changed(&amp;cw_bat-&gt;rk_ac);+ power_supply_changed(cw_bat-&gt;rk_usb);+ power_supply_changed(cw_bat-&gt;rk_ac); &#125; &#125; @@ -830,12 +839,12 @@ static void cw_bat_work(struct work_struct *work) rk_bat_update_time_to_empty(cw_bat); if (cw_bat-&gt;bat_change) &#123;- power_supply_changed(&amp;cw_bat-&gt;rk_bat);+ power_supply_changed(cw_bat-&gt;rk_bat); cw_bat-&gt;bat_change = 0; &#125; queue_delayed_work(cw_bat-&gt;battery_workqueue,- &amp;cw_bat-&gt;battery_delay_work, msecs_to_jiffies(1000));+ &amp;cw_bat-&gt;battery_delay_work, msecs_to_jiffies(10000)); dev_dbg(&amp;cw_bat-&gt;client-&gt;dev, &quot;cw_bat-&gt;bat_change = %d, cw_bat-&gt;time_to_empty = %d, cw_bat-&gt;capacity = %d\\n&quot;,@@ -851,9 +860,9 @@ static int rk_usb_get_property(struct power_supply *psy, union power_supply_propval *val) &#123; int ret = 0;- struct cw_battery *cw_bat;+ struct cw_battery *cw_bat = power_supply_get_drvdata(psy); - cw_bat = container_of(psy, struct cw_battery, rk_usb);+ //cw_bat = container_of(psy, struct cw_battery, rk_usb); switch (psp) &#123; case POWER_SUPPLY_PROP_ONLINE: val-&gt;intval = (cw_bat-&gt;charger_mode == USB_CHARGER_MODE);@@ -873,9 +882,9 @@ static int rk_ac_get_property(struct power_supply *psy, union power_supply_propval *val) &#123; int ret = 0;- struct cw_battery *cw_bat;+ struct cw_battery *cw_bat = power_supply_get_drvdata(psy); - cw_bat = container_of(psy, struct cw_battery, rk_ac);+ //cw_bat = container_of(psy, struct cw_battery, rk_ac); switch (psp) &#123; case POWER_SUPPLY_PROP_ONLINE: val-&gt;intval = (cw_bat-&gt;charger_mode == AC_CHARGER_MODE);@@ -895,9 +904,9 @@ static int rk_battery_get_property(struct power_supply *psy, union power_supply_propval *val) &#123; int ret = 0;- struct cw_battery *cw_bat;+ struct cw_battery *cw_bat = power_supply_get_drvdata(psy); - cw_bat = container_of(psy, struct cw_battery, rk_bat);+ //cw_bat = container_of(psy, struct cw_battery, rk_bat); switch (psp) &#123; case POWER_SUPPLY_PROP_CAPACITY: val-&gt;intval = cw_bat-&gt;capacity;@@ -941,6 +950,67 @@ static enum power_supply_property rk_battery_properties[] = &#123; POWER_SUPPLY_PROP_TECHNOLOGY, &#125;; ++static const struct power_supply_desc cw_bat_desc = &#123;+ .name = &quot;rk-bat&quot;,+ .type = POWER_SUPPLY_TYPE_BATTERY,+ .properties = rk_battery_properties,+ .num_properties = ARRAY_SIZE(rk_battery_properties),+ .get_property = rk_battery_get_property,+&#125;;++static const struct power_supply_desc cw_ac_desc = &#123;+ .name = &quot;rk-ac&quot;,+ .type = POWER_SUPPLY_TYPE_MAINS,+ .properties = rk_ac_properties,+ .num_properties = ARRAY_SIZE(rk_ac_properties),+ .get_property = rk_ac_get_property,+&#125;;++static const struct power_supply_desc cw_usb_desc = &#123;+ .name = &quot;rk-usb&quot;,+ .type = POWER_SUPPLY_TYPE_USB,+ .properties = rk_usb_properties,+ .num_properties = ARRAY_SIZE(rk_usb_properties),+ .get_property = rk_usb_get_property,+&#125;;+++static int cw_init_power_supply(struct cw_battery *bat)+&#123;+ struct power_supply_config psy_cfg = &#123;.drv_data = bat, &#125;;+ + bat-&gt;rk_bat = power_supply_register(&amp;bat-&gt;client-&gt;dev, &amp;cw_bat_desc, &amp;psy_cfg);+ if (IS_ERR(bat-&gt;rk_bat)) &#123;+ dev_err(&amp;bat-&gt;client-&gt;dev,+ &quot;power supply register rk_bat error\\n&quot;);+ return PTR_ERR(bat-&gt;rk_bat);+ &#125;+ + bat-&gt;rk_ac = power_supply_register(&amp;bat-&gt;client-&gt;dev, &amp;cw_ac_desc, &amp;psy_cfg);+ if (IS_ERR(bat-&gt;rk_ac)) &#123;+ dev_err(&amp;bat-&gt;client-&gt;dev,+ &quot;power supply register rk_ac error\\n&quot;);+ return PTR_ERR(bat-&gt;rk_ac);+ &#125;++ if(bat-&gt;plat_data.is_usb_charge == 1) &#123;+ bat-&gt;rk_usb = power_supply_register(&amp;bat-&gt;client-&gt;dev, &amp;cw_usb_desc, &amp;psy_cfg);+ if (IS_ERR(bat-&gt;rk_usb)) &#123;+ dev_err(&amp;bat-&gt;client-&gt;dev,+ &quot;power supply register rk_usb error\\n&quot;);+ return PTR_ERR(bat-&gt;rk_usb);+ &#125;+ bat-&gt;charger_init_mode = dwc_otg_check_dpdm();+ pr_info(&quot;%s cw2015 support charger by usb. usb_mode=%d\\n&quot;,+ __func__, bat-&gt;charger_init_mode);+ &#125;+ return 0;+&#125;+ static int cw_bat_gpio_init(struct cw_battery *cw_bat) &#123; int ret;@@ -1236,45 +1308,10 @@ static int cw_bat_probe(struct i2c_client *client, return ret; &#125; - cw_bat-&gt;rk_bat.name = &quot;rk-bat&quot;;- cw_bat-&gt;rk_bat.type = POWER_SUPPLY_TYPE_BATTERY;- cw_bat-&gt;rk_bat.properties = rk_battery_properties;- cw_bat-&gt;rk_bat.num_properties = ARRAY_SIZE(rk_battery_properties);- cw_bat-&gt;rk_bat.get_property = rk_battery_get_property;- ret = power_supply_register(&amp;client-&gt;dev, &amp;cw_bat-&gt;rk_bat);- if (ret &lt; 0) &#123;- dev_err(&amp;cw_bat-&gt;client-&gt;dev,- &quot;power supply register rk_bat error\\n&quot;);- goto rk_bat_register_fail;- &#125;-- cw_bat-&gt;rk_ac.name = &quot;rk-ac&quot;;- cw_bat-&gt;rk_ac.type = POWER_SUPPLY_TYPE_MAINS;- cw_bat-&gt;rk_ac.properties = rk_ac_properties;- cw_bat-&gt;rk_ac.num_properties = ARRAY_SIZE(rk_ac_properties);- cw_bat-&gt;rk_ac.get_property = rk_ac_get_property;- ret = power_supply_register(&amp;client-&gt;dev, &amp;cw_bat-&gt;rk_ac);- if (ret &lt; 0) &#123;- dev_err(&amp;cw_bat-&gt;client-&gt;dev,- &quot;power supply register rk_ac error\\n&quot;);- goto rk_ac_register_fail;- &#125;-- if (cw_bat-&gt;plat_data.is_usb_charge == 1) &#123;- cw_bat-&gt;rk_usb.name = &quot;rk-usb&quot;;- cw_bat-&gt;rk_usb.type = POWER_SUPPLY_TYPE_USB;- cw_bat-&gt;rk_usb.properties = rk_usb_properties;- cw_bat-&gt;rk_usb.num_properties = ARRAY_SIZE(rk_usb_properties);- cw_bat-&gt;rk_usb.get_property = rk_usb_get_property;- ret = power_supply_register(&amp;client-&gt;dev, &amp;cw_bat-&gt;rk_usb);- if (ret &lt; 0) &#123;- dev_err(&amp;cw_bat-&gt;client-&gt;dev,- &quot;power supply register rk_usb error\\n&quot;);- goto rk_usb_register_fail;- &#125;- cw_bat-&gt;charger_init_mode = dwc_otg_check_dpdm();- pr_info(&quot;%s cw2015 support charger by usb. usb_mode=%d\\n&quot;,- __func__, cw_bat-&gt;charger_init_mode);+ ret = cw_init_power_supply(cw_bat);+ if (ret) &#123;+ dev_err(&amp;cw_bat-&gt;client-&gt;dev, &quot;init power supply fail!\\n&quot;);+ return ret; &#125; cw_bat-&gt;dc_online = 0;@@ -1304,7 +1341,7 @@ static int cw_bat_probe(struct i2c_client *client, &#125; irq_flags = level ? IRQF_TRIGGER_FALLING : IRQF_TRIGGER_RISING; ret =- request_irq(irq, dc_detect_irq_handler, irq_flags,+ request_irq(irq, dc_detect_irq_handler, irq_flags | IRQF_SHARED, &quot;dc_detect&quot;, cw_bat); if (ret &lt; 0) pr_err(&quot;%s: request_irq(%d) failed\\n&quot;, __func__, irq);@@ -1331,14 +1368,17 @@ static int cw_bat_probe(struct i2c_client *client, dev_info(&amp;cw_bat-&gt;client-&gt;dev, &quot;cw2015/cw2013 driver v1.2 probe sucess\\n&quot;);++ ret = cw_get_vol(cw_bat);+ if(ret &gt; VCELL_VOLTAGE)&#123; + have_battery = 1;+ dev_info(&amp;cw_bat-&gt;client-&gt;dev,&quot;FOUND BAT! have_battery = %d\\n&quot;,have_battery);+ &#125;else&#123;+ have_battery = 0;+ dev_dbg(&amp;cw_bat-&gt;client-&gt;dev,&quot;NOT FOUND BAT! have_battery = %d\\n&quot;,have_battery);+ &#125; return 0; -rk_usb_register_fail:- power_supply_unregister(&amp;cw_bat-&gt;rk_usb);-rk_ac_register_fail:- power_supply_unregister(&amp;cw_bat-&gt;rk_ac);-rk_bat_register_fail:- power_supply_unregister(&amp;cw_bat-&gt;rk_bat); pdate_fail: dev_info(&amp;cw_bat-&gt;client-&gt;dev, &quot;cw2015/cw2013 driver v1.2 probe error!!!!\\n&quot;);diff --git a/include/linux/power/cw2015_battery.h b/include/linux/power/cw2015_battery.hindex 6f14aa7..1a3c203 100644--- a/include/linux/power/cw2015_battery.h+++ b/include/linux/power/cw2015_battery.h@@ -78,9 +78,9 @@ struct cw_battery &#123; struct delayed_work bat_low_wakeup_work; struct cw_bat_platform_data plat_data; - struct power_supply rk_bat;- struct power_supply rk_ac;- struct power_supply rk_usb;+ struct power_supply *rk_bat;+ struct power_supply *rk_ac;+ struct power_supply *rk_usb; long sleep_time_capacity_change; long run_time_capacity_change;@@ -102,7 +102,10 @@ struct cw_battery &#123; &#125;; #if defined(CONFIG_ARCH_ROCKCHIP)-int get_gadget_connect_flag(void);+int get_gadget_connect_flag(void)+&#123;+ return 0;+&#125; int dwc_otg_check_dpdm(void); int dwc_vbus_status(void); #else@@ -116,10 +119,11 @@ static inline int dwc_otg_check_dpdm(bool wait) return 0; &#125; -static inline int dwc_vbus_status(void);+static inline int dwc_vbus_status(void) &#123; return 0; &#125;+ #endif #endif bq25700_charger.c在 bq 中我们会根据 cw 中获得到的电池的状态来操作 是否进行 BQ IC 寄存器的初始化（hw_init）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162--- a/drivers/power/bq25700_charger.c+++ b/drivers/power/bq25700_charger.c@@ -33,6 +33,8 @@ #include &lt;linux/of_gpio.h&gt; #include &lt;linux/rk_keys.h&gt; +extern int have_battery;+ static int dbg_enable = 1; module_param_named(dbg_level, dbg_enable, int, 0644); @@ -741,7 +743,7 @@ static int bq25700_chip_reset(struct bq25700_device *charger) &#123; int ret; int rst_check_counter = 10;- return 0;+ //return 0; // hw_init 中不需要 chip reset ，关掉 DBG(\"BQ25700: bq25700_chip_reset\\n\"); ret = bq25700_field_write(charger, RESET_REG, 1);@@ -781,7 +783,14 @@ static int bq25700_hw_init(struct bq25700_device *charger) &#123;OTG_CURRENT, charger-&gt;init_data.otg_current&#125;, &#125;; - DBG(\"BQ25700: bq25700_hw_init.\\n\");+ if(!have_battery) //如果没有电池，就 bq25700_hw_init 就直接返回+ &#123;+ DBG(\"BQ25700: CW said NO BAT FOUND!\\n\");+ return -1;+ &#125;++ DBG(\"BQ25700: We have BAT,bq25700_hw_init.\\n\"); ret = bq25700_chip_reset(charger); if (ret &lt; 0) return ret;@@ -887,6 +896,46 @@ static int bq25700_hw_init(struct bq25700_device *charger) return ret; &#125; // 将中断设为 共享中断@@ -1079,7 +1139,7 @@ static irqreturn_t bq25700_irq_handler_thread(int irq, void *private) charger-&gt;typec1_status = USB_STATUS_NONE; DBG(\"BQ25700: irq_flag = IRQF_TRIGGER_HIGH\\n\"); &#125;- irq_set_irq_type(irq, irq_flag | IRQF_ONESHOT);+ irq_set_irq_type(irq, irq_flag | IRQF_ONESHOT | IRQF_SHARED); rk_send_wakeup_key(); DBG(\"BQ25700: bq25700_irq_handler_thread done\\n\");@@ -1815,7 +1875,7 @@ while(1) &#123; ret = devm_request_threaded_irq(dev, client-&gt;irq, NULL, bq25700_irq_handler_thread,- irq_flag | IRQF_ONESHOT,+ irq_flag | IRQF_ONESHOT | IRQF_SHARED, \"bq25700_irq\", charger); if (ret) goto irq_fail;@@ -1825,18 +1885,6 @@ while(1) &#123; DBG(\"BQ25700: enable_irq_wake done.\\n\"); 验证结果 12ls sys/class/power_supply/ bq25700_charger rk_ac rk_usb rk_bat 可以看到四个设备bq25700_charger rk_ac rk_usb rk_batbq25700_charger 是在 bq 中注册的 Type = POWER_SUPPLY_TYPE_USB 的设备rk_ac 是在 cw 中注册的 Type = POWER_SUPPLY_TYPE_MAINS 的设备rk_usb 是在 cw 中注册的 Type = POWER_SUPPLY_TYPE_USB 的设备rk_bat 是在 cw 中注册的 Type = POWER_SUPPLY_TYPE_BATTERY 的设备 均注册正常。而且无论是否接电池，现在都可以正常开机。","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 电池系统（一）BQ25700 IC 驱动分析","slug":"Android_Driver/Driver/[Android6.0][RK3399] 电池系统（一）BQ25700 IC 驱动分析","date":"2017-08-31T15:33:05.000Z","updated":"2018-11-08T02:44:05.395Z","comments":true,"path":"2017/08/31/Android_Driver/Driver/[Android6.0][RK3399] 电池系统（一）BQ25700 IC 驱动分析/","link":"","permalink":"http://iyounix.com/2017/08/31/Android_Driver/Driver/[Android6.0][RK3399] 电池系统（一）BQ25700 IC 驱动分析/","excerpt":"","text":"Platform: RK3399OS: Android 6.0Kernel: 4.4Version: v2017.04IC: TI BQ25700、RK808 基本概念TypeC PD 快充：在USB Type-C接口中，拥有PD标准可承受3A或5A的大电流，根据不同电压，传输的最大功率可达100W。需要充电器（适配器）和被充电设备（手机、平板、电脑）均支持 PD 协议才行。 标准下行端口(SDP)这与USB 2.0规范定义的端口相同，也是台式机和笔记本电脑常见的典型端口。挂起时，最大负载电流为2.5A；连接且非挂起状态下为100mA，可以配置电流为500mA (最大)。设备可利用硬件识别SDP，USB数据线D+和D-分别通过15kΩ接地，但仍然需要枚举，以符合USB规范。尽管现在许多硬件不经枚举即消耗功率，但在USB 2.0规范中，从严格意义上并不合法，违反规范要求。 充电下行端口(CDP) BC1.1为PC、笔记本电脑及其它硬件规定了这种较大电流的新型USB口。现在，CDP可提供高达1.5A电流，由于可在枚举之前提供电流，所以有别于USB 2.0。插入CDP的装置可通过操纵和监测D+、D-线，从而利用硬件握手识别CDP (参见USB电池充电规范第3.2.3部分)。在将数据线转为USB收发之前进行硬件测试，这样就能够在枚举之前检测到CDP (以及开始充电)。 专用充电端口(DCP) BC1.1规定了不进行枚举的电源，例如墙上适配器电源和汽车适配器，不需要数字通信即可启动充电。DCP可提供高达1.5A电流，通过短路D+和D-进行识别，从而能够设计DCP“墙上适配器电源”，采用USB mini或微型插孔，而非圆形插头或自制连接器的固定安装线。这样的适配器可采用任意USB电缆(配备正确插头)进行充电。 驱动分析默认 3399 SDK 中，BQ IC 驱动仅实现了 TypeC 充电（不支持 DC 充电）。首先我们分析一下其驱动的函数调用链。 函数调用链123456789101112131415161718192021222324252627282930313233bq25700_probe i2c_check_functionality //是否支持 SMBUS 通信 devm_regmap_init_i2c //采用 regmap api 操作 i2c，初始化 bq25700 的 regmap_config devm_regmap_field_alloc //为 regmap 分配内存空间 i2c_set_clientdata bq25700_field_read //读 chip id bq25700_fw_probe bq25700_fw_read_u32_props //获取 dts 中的属性，包括 charge-current、max-charge-voltage、input-current-sdp/dcp/cdp、minimum-sys-voltage 、otg-voltage、otg-current bq25700_hw_init //1. bq25700_chip_reset //芯片重启 //2. WDTWR_ADJ = 0 //disable watchdog //3. 初始化电流电压和其他参数 //4. 配置 ADC 用以持续转化，禁能 bq25700_parse_dt //获取 dts 中的属性 pd-charge-only bq25700_init_usb usb_charger_wq = alloc_ordered_workqueue //分配工作队列，用于事件通知链 extcon_get_edev_by_phandle(dev, 0) //获取外部连接器 fusb302 bq25700_register_cg_nb(charger); //注册 charger 通知链。如果 pd_charge_only 为 0 ，表示不仅仅采用 TypeC 充电，则执行。添加等待队列。 bq25700_charger_evt_worker //初始化 charger 等待队列 bq25700_charger_evt_handel //判断 charger 类型，并使能 INPUT_CURRENT/CHARGE_CURRENT bq25700_charger_evt_notifier //添加 charger 事件通知链 bq25700_register_cg_extcon //注册 charger 外部控制器，以及其事件通知链 bq25700_register_host_nb(charger); //注册 host 通知链 bq25700_register_discnt_nb(charger); //注册 disconnect 通知链 bq25700_register_pd_nb(charger); //注册 pd 通知链 schedule_delayed_work //提交任务到工作队列 bq25700_init_sysfs //创建 sysfs 中的属性节点 //根据 AC_STAT 确定触发条件，设定中断触发条件 device_init_wakeup devm_request_threaded_irq enable_irq_wake //使能中断唤醒 bq25700_power_supply_init //注册 power supply 的 desc bq25700_power_supply_get_property //获取系统属性的接口 其中要注意的是 bq25700_hw_init。在其中完成了比较重要寄存器配置工作，可以在其后 dump 出寄存器信息，对照 datasheet 进行校对。 调试流程一开始最直观的效果是，电池电压没有升高，所以没有充电。 根据 datasheet 我们查看标准充电流程： 先检查芯片供电是否正常。 再检查 CHARGER_OK_H 引脚电平，在插入电源（TypeC 或者 DC）的时候是否改变（被拉高） 检查 I2C 通信是否正常。包括 I2C 组别是否设置正确，I2C 地址是否有误。注意，如果你的代码中是通过 smbus api 的方式和 IC 通信的，地址需要设置为 0x09，如果是采用 I2C 通信，地址为 6a。 检查电池相关的参数配置的是否有误。比如 charge-current、max-charge-voltage、input-current-sdp/dcp/cdp、minimum-sys-voltage 、otg-voltage、otg-current。双节电池 7.4 V 配置如下，单节电池 3.7V 的差异在注释中有标注。1234567891011121314151617181920212223bq25700: bq25700@09 &#123;//09 for SMBUS,6a for I2C compatible = &quot;ti,bq25700&quot;; reg = &lt;0x09&gt;; extcon = &lt;&amp;fusb0&gt;; interrupt-parent = &lt;&amp;gpio1&gt;; interrupts = &lt;1 IRQ_TYPE_LEVEL_LOW&gt;; //GPIO1_A1 pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;charger_ok&gt;; ti,charge-current = &lt;2500000&gt;; ti,max-input-voltage = &lt;20000000&gt;; ti,max-input-current = &lt;6000000&gt;; ti,max-charge-voltage = &lt;8750000&gt;; // single battery is 4000000 dual is 8750000 ti,input-current = &lt;5000000&gt;; ti,input-current-sdp = &lt;500000&gt;; ti,input-current-dcp = &lt;2000000&gt;; ti,input-current-cdp = &lt;2000000&gt;; ti,minimum-sys-voltage = &lt;7400000&gt;; // single battery is 3400000 dual is 7400000 ti,otg-voltage = &lt;5000000&gt;; ti,otg-current = &lt;500000&gt;; pd-charge-only = &lt;0&gt;; //typec0-enable-gpios = &lt;&amp;gpio1 3 GPIO_ACTIVE_HIGH&gt;; //GPIO1 GPIO1_A3 //typec0-discharge-gpios = &lt;&amp;gpio0 12 GPIO_ACTIVE_HIGH&gt;; //GPIO0 GPIO0_B4 &#125;; 5. 检查 Input Voltage 和 Current Limit 相关的寄存器设置是否正常。寄存器是在函数 bq25700_hw_init 中进行寄存器初始化。可以通过 dump_regs 打印出寄存器信息观察。也可以通过 cat /sys/class/i2c-adapter/i2c-4/4-0009/charge_info 节点来各个观察寄存器中的信息。如果 CHARGE_CURRENT 过低，可能是 input current 有一部分跑到系统上去了，供电不足，可以将 input-current 调大试试（比如将现在的 input-current 从 500mA 改为 1A ti,input-current = &lt;10000000&gt;; 。 6. 观察 INPUT_CURRENT 和 CHARGE_CURRENT 寄存器值是否正确，rk 将这两个操作封装在了 bq25700_enable_charger 这个函数中。在其中加入打印信息，观察否是调用该函数。对于我的板子而言，这个函数没有调用，观察其函数调用链bq25700_register_cg_nb-&gt;bq25700_charger_evt_worker-&gt;bq25700_charger_evt_handel-&gt; bq25700_enable_chargerbq25700_register_cg_nb 函数调用的逻辑是12if (!charger-&gt;pd_charge_only) bq25700_register_cg_nb(charger); 而我的 pd_charge_only 设置为 1 。它表示只采用 PD 充电，而我是直流电源（TypeC 接口）充电，如果设置为 1 ，则不会进入 bq25700_enable_charger 的逻辑。故无法充电。硬件要满足 PD 充电的条件必须是采用 PD 专用的适配器，市面上大概 100 多一个，所以如果你的适配器没有这么贵的话，果断关掉 pd-charge-only 选项吧。改为 0 后可以充电。问题解决。 另外，因为部分寄存器为 16bit ，i2c-tools 仅能读出 8bit，差点被其误导以为寄存器中的数据有误。","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 Mipi LCD RM72014 移植调试流程","slug":"Android_Driver/Driver/[Android6.0][RK3399] Mipi LCD RM72014 移植调试流程","date":"2017-08-31T15:33:05.000Z","updated":"2018-11-08T06:19:50.232Z","comments":true,"path":"2017/08/31/Android_Driver/Driver/[Android6.0][RK3399] Mipi LCD RM72014 移植调试流程/","link":"","permalink":"http://iyounix.com/2017/08/31/Android_Driver/Driver/[Android6.0][RK3399] Mipi LCD RM72014 移植调试流程/","excerpt":"","text":"[TOC] 前言其实之前有写过一篇关于 =RK3288 平台 LCD 调试流程的博客 。不过是 RK3288 Android5.1 平台的。虽然实际上 Mipi 部分代码实在是大同小异。但是距上次那篇文章到现在也已经不知不觉整整一年了，这一年 Mipi LCD 确实也调了不少。索性再次重新梳理一下，也许会有别样的收获吧。没有看过那篇文章的同学也不需要再看了，这篇文章会更加全面的描述和分析调试流程。这次文章以 RM72014 这颗 Driver IC 为例，从 RK Mipi LCD 代码分析 到 屏的公式计算 再到实践中的问题都会涉及，调试为主，分析为辅，比较冗长，大家可以挑选自己需要的部分来看。随着我碰到的情况更多，本文也将不断更新。也欢迎大家留言分享交流自己碰到的情况和解决方案。 本文地址：http://blog.csdn.net/dearsq/article/details/77341120作者 Younix，欢迎转载，转载请著名出处，谢谢。 一、扣出屏 datasheet 中的关键信息首先我们要找屏厂索取详细版的屏的规格书，扣出其中的关键信息。屏 Spec 的目录大概如下： 其中我们最需要关注的是General SpecificationPower on/off sequence 上电下电时序Timing 屏参 1. General Specification 提炼出来关键信息是Hactive = 800 ，水平分辨率Vactive = 1280 ，垂直分辨率Lanes = 4 ，Mipi data 信号线通道数 2. Power on/off sequence 这个在屏点不亮的时候需要首先确认，这个我们后面会说。我们在调屏的时候可以先把这个截图保存到自己的笔记中，就不需要每次都去翻 datasheet 了。 3. Timing 关键信息提炼出来：Hactive = 800HFP = 24HBP = 132Hsync = 4 Vactive = 1280VFP = 8VBP = 8VSync = 4 Pixel Clock Frequency（Pclk）= 74.88MHZ 这里我们详细说一下各个参数的含义，这个对我们后续调屏会非常有帮助。更加详细全面的参见 NXP 的一份资料：graphics.lcd.technologies.pdf 说白了核心思想就是下面这张图： Horizontal 代表水平方向，HBP 行同步信号后肩 、HFP 行同步信号前肩，单位是 clocks，什么 clock ？pclk （pixel clock frequence），像素时钟频率，也就是我们在 dts 中填充的 clock-frequence 这个参数。Vertical 代表垂直方向，VBP 帧同步信号后肩、VFPP 帧同步信号前肩，单位是 lines。 另外根据以上的信息，我们还能计算出 Mipi Dsi Clock 。DCLK = 100 + H_total×V_total × fps × 3 × 8 / lanes_numstotal 这里指的是 sync + front + back + active比如 H_total = Hsync + HFP(hfront-proch) + HBP(hback-porch) + Hactivefps 指的是帧率，一般我们按照 60 帧来计算3 × 8 代表一个 RGB 为 3 个字节，每个字节 8 bitlanes 代表 mipi data 通道数 所以对于我这个屏DCLK= 100Mbps + H_Total × V_Total x fps x 3 x 8 / lanes_nums= 100 + ( 800 + 21 + 132 + 4 ) x ( 1280 + 8 + 8 + 4 ) x 60 帧 x 3 字节 x 8 bit / 4 lanes= 100Mbps + 449Mbps = 549 Mbps 二、根据屏参 和 硬件设计填写 dtsRK LCD 这部分的去耦合性已经做的很好了。我们仅仅只需要填写 dts ，驱动会自动解析 dts ，管脚控制部分会自动申请分配操纵 GPIO，屏初始化代码（init cmds）和屏参（timing）将被自动封装成 mipi dsi 命令进行发送。 2.1 创建屏的 dtsi 文件仿造平台的其他 lcd-*-mipi.dtsi 编写 lcd-xxx-mipi.dtsi 后 需要在 主 dts 文件中包含这个 dtsi。1234&amp;rk_screen &#123; /* 8inch LCD Mipi */ #include &lt;dt-bindings/display/screen-timing/lcd-mipi-rm72014.dtsi&gt;&#125;; 根据前面我们获取到的屏参信息开始编写 dtsi 2.1.1 Mipi Host1234567891011121314151617//MIPI Host配置disp_mipi_init: mipi_dsi_init&#123; compatible = &quot;rockchip,mipi_dsi_init&quot;; /* 是否要在 dtsi 中初始化 1 是 0 否 */ rockchip,screen_init = &lt;1&gt;; /* 要几条数据 lane*/ rockchip,dsi_lane = &lt;4&gt;; /* ddr clk 一条 lane 的传输速率 Mbits/s */ /* 前面我们已经算得为 549 */ rockchip,dsi_hs_clk = &lt;549&gt;; /* 单mipi 还是双 mipi*/ rockchip,mipi_dsi_num = &lt;1&gt;;&#125;; 2.1.2 Timing1234567891011121314151617181920212223242526disp_timings: display-timings &#123; native-mode = &lt;&amp;timing0&gt;; compatible = &quot;rockchip,display-timings&quot;; timing0: timing0 &#123; screen-type = &lt;SCREEN_MIPI&gt;; //单mipi SCREEN_MIPI 双mipi SCREEN_DUAL_MIPI lvds-format = &lt;LVDS_8BIT_2&gt;; //不用配置 out-face = &lt;OUT_P888&gt;; //屏的接线格式 //配置颜色，可为OUT_P888（24位）、OUT_P666（18位）或者OUT_P565（16位） clock-frequency = &lt;74488000&gt;; //dclk频率，看规格书，或者 H×V×fps hactive = &lt;800&gt;; //水平有效像素 vactive = &lt;1280&gt;; //垂直有效像素 hback-porch = &lt;132&gt;; //水平同步信号 后肩 hfront-porch = &lt;24&gt;; //水平同步信号 前肩 vback-porch = &lt;8&gt;; vfront-porch = &lt;8&gt;; hsync-len = &lt;4&gt;; //水平同步信号 vsync-len = &lt;4&gt;; hsync-active = &lt;0&gt;; //hync 极性控制 置 1 反转极性 vsync-active = &lt;0&gt;; de-active = &lt;0&gt;; //DEN 极性控制 pixelclk-active = &lt;0&gt;; //dclk 极性控制 swap-rb = &lt;0&gt;; //设 1 反转颜色 red 和 blue swap-rg = &lt;0&gt;; swap-gb = &lt;0&gt;; &#125;;&#125;; 2.1.3 init cmds屏场给的初始化时序往往不会是 RK 平台的。我们可能需要自己转换一下。不过一般也很好理解，我们分别分析两组平台的例子： 展讯平台：12345678910111213GP_COMMAD_PA(02);SPI_WriteData(0x53);SPI_WriteData(0x24);GP_COMMAD_PA(03);SPI_WriteData(0xf0);SPI_WriteData(0x5a);SPI_WriteData(0x5a); Delay_ms(30);GP_COMMAD_PA(01);SPI_WriteData(0x11); Delay_ms(100);GP_COMMAD_PA(01);SPI_WriteData(0x29); Delay_ms(30);GP_COMMAD_PA(04);SPI_WriteData(0xc3);SPI_WriteData(0x40);SPI_WriteData(0x00);SPI_WriteData(0x28);GP_COMMAD_PA(02);SPI_WriteData(0x50);SPI_WriteData(0x77);GP_COMMAD_PA(02);SPI_WriteData(0xe1);SPI_WriteData(0x66);GP_COMMAD_PA(02);SPI_WriteData(0xdc);SPI_WriteData(0x67);GP_COMMAD_PA(02);SPI_WriteData(0xd3);SPI_WriteData(0xc8);GP_COMMAD_PA(02);SPI_WriteData(0x50);SPI_WriteData(0x00);GP_COMMAD_PA(02);SPI_WriteData(0xf0);SPI_WriteData(0x5a);GP_COMMAD_PA(02);SPI_WriteData(0xf5);SPI_WriteData(0x80);Delay(120); GP_COMMAD_PA 表示 dsi packets 的个数SPI_WriteData 接口用来写数据Delay_ms 表示延时 xx 毫秒所以GP_COMMAD_PA(02);SPI_WriteData(0x53);SPI_WriteData(0x24);表示给屏 0x53 指令，有一个指令参数，为 0x24GP_COMMAD_PA(03);SPI_WriteData(0xf0);SPI_WriteData(0x5a);SPI_WriteData(0x5a); Delay_ms(30);表示给屏 0xf0 指令，有两个指令参数 0x5a 和 0x5a ，并且延时 30msGP_COMMAD_PA(01);SPI_WriteData(0x11); Delay_ms(100);表示给屏 0x11 指令，没有指令参数，并且延时 100msGP_COMMAD_PA(01);SPI_WriteData(0x29); Delay_ms(30);表示给屏 0x29 指令，没有指令参数，并且延时 30ms 后面同理。 细心的同学发现了我这里强调了指令参数的个数。因为这涉及到了 dsi 协议中 dsi 传输的数据类型。根据 《MIPI-DSI-specification-v1-1.pdf》49 页我们可以看到，有如下这些数据类型。 我们只需要关注 0x05 ，0x15，0x39，他们分别对应的 dsi 参数类型是 无参指令（Short No parameters）、单参数指令（Short 1 parameter）、多参数指令（Long Command Packets）。 MTK 平台1234data_array[0]=0x00043902;data_array[1]=0x8983FFB9; dsi_set_cmdq(&amp;data_array, 2, 1); MDELAY(10); 分析得知array[0] 中 04 代表要传输的字节数，3902 代表传输的是多参指令//MTK平台 3900 代表无参 3905 表示单参 3902 表示多参array1 中的参数全部为传输的参数，而且正确的传参数据是倒着的 B9 FF 83 89所以移植到 RK 平台应该是12345678rockchip,on-cmds1 &#123; compatible = &quot;rockchip,on-cmds&quot;; rockchip,cmd_type = &lt;LPDT&gt;; rockchip,dsi_id = &lt;0&gt;; rockchip,cmd = &lt;0x39 0xB9 0xFF 0x83 0x89&gt;; //0x39 为 DSI 数据类型、 0xB9 为LCD 命令、后面为参数 rockchip,cmd_delay = &lt;10&gt;;&#125; Mipi DSI 协议中 Generic 和 DCS 的区别另外，值得一提的是。在上面 Mipi 的 Spec 中，大家可以看到 0x29 和 0x39 都可以表示多参，0x03 和 0x05 都可以表示无参，0x13 和 0x15 都可以表示单参。但他们不是没有区别的。 DSI 协议中 ，0x29 和 0x39 区别：在 Mipi 协议中，它俩都表示 长包（Long Packet）数据类型。但是 Mipi DSI 的 Spec 中写着两者的区别 0x29 属于 Generic long write ，0x39 属于 DCS long write。DCS 系的读写命令，可带参数，常用于 LCD 初始化参数命令。Generic 系读写命令，是协议规范外的命令，通常是一些 IC 定制的，只要确保主机和外设同意这些数据格式即可，通常和 DCS 通用。 RK 平台上述两个例子举完了。我们继续写 RK 平台 RM72014 的 inital cmds： 对应的 inital cmds12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 disp_mipi_init_cmds: screen-on-cmds &#123; rockchip,cmd_debug = &lt;0&gt;; compatible = &quot;rockchip,screen-on-cmds&quot;; rockchip,on-cmds1 &#123; compatible = &quot;rockchip,on-cmds&quot;; rockchip,cmd_type = &lt;LPDT&gt;; rockchip,dsi_id = &lt;2&gt;; rockchip,cmd = &lt;0x15 0x53 0x24&gt;; rockchip,cmd_delay = &lt;0&gt;; &#125;; rockchip,on-cmds2 &#123; compatible = &quot;rockchip,on-cmds&quot;; rockchip,cmd_type = &lt;LPDT&gt;; rockchip,dsi_id = &lt;2&gt;; rockchip,cmd = &lt;0x39 0xf0 0x5a 0x5a&gt;; rockchip,cmd_delay = &lt;30&gt;; &#125;; rockchip,on-cmds3 &#123; compatible = &quot;rockchip,on-cmds&quot;; rockchip,cmd_type = &lt;LPDT&gt;; rockchip,dsi_id = &lt;2&gt;; rockchip,cmd = &lt;0x05 0x11&gt;; rockchip,cmd_delay = &lt;100&gt;; &#125;; rockchip,on-cmds4 &#123; compatible = &quot;rockchip,on-cmds&quot;; rockchip,cmd_type = &lt;LPDT&gt;; rockchip,dsi_id = &lt;2&gt;; rockchip,cmd = &lt;0x05 0x29&gt;; rockchip,cmd_delay = &lt;30&gt;; &#125;;//... rockchip,on-cmds11 &#123; compatible = &quot;rockchip,on-cmds&quot;; rockchip,cmd_type = &lt;LPDT&gt;; rockchip,dsi_id = &lt;2&gt;; rockchip,cmd = &lt;0x15 0xf0 0x5a&gt;; rockchip,cmd_delay = &lt;0&gt;; &#125;; rockchip,on-cmds12 &#123; compatible = &quot;rockchip,on-cmds&quot;; rockchip,cmd_type = &lt;LPDT&gt;; rockchip,dsi_id = &lt;2&gt;; rockchip,cmd = &lt;0x15 0xf5 0x80&gt;; rockchip,cmd_delay = &lt;120&gt;; &#125;; cmd_type 表示 dsi 传输类型，分为 HSDT 高速（Video 模式） 和 LPDT 低速（command 模式）dsi_id 表示通过哪一组 mipi 发送。0 表示第一组 Mipi ，2 表示两组同时发。1 表示第二组 Mipi，但是一般不会出现只用第二组的情况，所以不会是 1 。 2.2 硬件管脚 GPIO 配置 有两种方式控制屏相关的 GPIO，一种是在屏 dtsi 中配置，一种是交由 vop 进行控制。 前者的例子如下，比如可以在 dtsi 中完成电源控制配置 123456789101112131415161718 ## 屏电源控制配置disp_mipi_power_ctr: mipi_power_ctr &#123; compatible = \"rockchip,mipi_power_ctr\"; mipi_lcd_rst:mipi_lcd_rst&#123; compatible = \"rockchip,lcd_rst\"; rockchip,gpios = &lt;&amp;gpio4 GPIO_D6 GPIO_ACTIVE_HIGH&gt;; rockchip,delay = &lt;10&gt;; &#125;; // 配置 lcd_en GPIO 哪一路 ，有可能没有 LCD_EN 那么就是 VCC 常供电 mipi_lcd_en:mipi_lcd_en &#123; compatible = \"rockchip,lcd_en\"; rockchip,gpios = &lt;&amp;gpio1 GPIO_B5 GPIO_ACTIVE_HIGH&gt;; rockchip,delay = &lt;10&gt;; &#125;; //还可能有片选 cs&#125;; 也可以交由 vop 控制，比如这样：12345678910111213141516171819&amp;vopl_rk_fb &#123; status = \"okay\"; rockchip,prop = &lt;PRMRY&gt;; assigned-clocks = &lt;&amp;cru DCLK_VOP1_DIV&gt;; assigned-clock-parents = &lt;&amp;cru PLL_CPLL&gt;; power_ctr: power_ctr &#123; rockchip,debug = &lt;0&gt;; lcd_en: lcd-en &#123; rockchip,power_type = &lt;GPIO&gt;; gpios = &lt;&amp;gpio1 GPIO_B5 GPIO_ACTIVE_HIGH&gt;; rockchip,delay = &lt;10&gt;; &#125;; lcd_rst: lcd-rst &#123; rockchip,power_type = &lt;GPIO&gt;; gpios = &lt;&amp;gpio4 GPIO_D6 GPIO_ACTIVE_HIGH&gt;; rockchip,delay = &lt;10&gt;; &#125;; &#125;;&#125;; GPIO_A / B C 的定义在 kernel/arch/arm64/boot/dts/include/dt-binding/pinctl/rk.h 中delay 需要根据上面的时序图进行设置，一般 10ms 可以适配大部分的屏幕了。这里的 rockchip,gpios 我们根据硬件进行配置： 1rockchip,gpios = &lt;&amp;gpio4 30 GPIO_ACTIVE_HIGH&gt;; // GPIO4_D6 1rockchip,gpios = &lt;&amp;gpio1 13 GPIO_ACTIVE_HIGH&gt;; //GPIO1_B5 三、背光 Backlight背光常用的有三种情况：一是 常开。二是 背光 IC 使能后，输入 PWM 信号调光。三是 背光 IC 使能后，通过 FB 获得反馈自动进行调光。 比如我曾用到一颗 背光 IC 是这样的： 我们了解到 EN 拉高时背光使能，拉低时背光禁能; FB 接受反馈信号，动态控制背光亮度。 根据相关的原理图 BL_EN 是普通的 GPIO ，LCDC_BL 是支持 PWM 输出的管脚，所以得知我们硬件采用的是第二种调光方式 完成 dts 中 backlight 相关的配置123456789101112131415161718backlight &#123; compatible = &quot;pwm-backlight&quot;; pwms = &lt;&amp;pwm0 0 25000&gt;; //在这里配置采用的是 pwm0 还是 pwm1 brightness-levels = &lt;255 254 253 252 251 250 249 248 247 246 245 244 243 242 241 240 239 238 237 236 235 234 233 232 231 230 229 228 227 226 225 224 223 222 221 220 219 218 217 216 215 214 213 212 211 210 209 208 207 206 205 204 203 202 201 200 199 198 197 196 195 194 193 192 191 190 189 188 187 186 185 184 183 182 181 180 179 178 177 176 175 174 173 172 171 170 169 168 167 166 165 164 163 162 161 160 159 158 157 156 155 154 153 152 151 150 149 148 147 146 145 144 143 142 141 140 139 138 137 136 135 134 133 132 131 130 129 128 127 126 125 124 123 122 121 120 119 118 117 116 115 114 113 112 111 110 109 108 107 106 105 104 103 102 101 100 99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0&gt;; default-brightness-level = &lt;200&gt;; enable-gpios = &lt;&amp;gpio7 GPIO_A2 GPIO_ACTIVE_HIGH&gt;; //BL_EN 背光使能管脚 &#125;; 四、确认驱动代码和 vop/lcdc 通道打开make menuconfig 确认一下三个宏打开 dts 中确认123456789// RK3399 平台 &amp;mipi0_rk_fb &#123; status = &quot;disabled&quot;; &#125;;// RK3288 平台 &amp;dsi_host &#123; status = &quot;disabled&quot;; &#125;; 五、调试流程一般按照上面的顺序，编译，烧录后。幸运的话，屏就可以点亮（有东西显示）了。 但是这个世界对长的帅的人就是如此不公平。至少我从来没有一次就直接点亮过。 下面我们开始进入调试阶段。 5.1 检查电压检查原理图上各个供电管脚的电压VCC 、VCC IO 是否正常。VCC IO 是给 GPIO 供电用，比如 RST。有的屏会兼容 3.3V 和 1.8 V 的 IO 电平，但是大部分不会。VCC_LCDA 、VCC_LCDK 电压是否满足要求。 确认电压正常后，关机，上屏，结合 开机 Log 看屏部分是否正常初始化。 5.2 背光是否正常背光没亮的话确认一下接上屏的时候，量一量 VDD_LCDA 的电压为多少（串联电路大概能到 20V+）没有就去检查背光电路供电电压和 backlight 相关的配置（比如背光功能使能的 GPIO 有没有控制到、PWM通道是否配置正确）。 5.3 framebuffer 是否有数据产生3368/3399 的命令为123echo bmp &gt; sys/class/graphics/fb0/dump_buf 或者echo bin &gt; sys/class/graphics/fb0/dump_buf 312x 的命令为1cat /dev/graphics/fb0 &gt; /data/fb0.yuv 将生成的文件 adb pull 出来后可以通过图片查看软件,譬如 7YUV 读取输出的 bmp 文件或者 bin 文件。如果有软件能正常显示画面，说明是 mipi 的问题。如果软件不能正常显示画面,说明 fb 刷下来的数据有问题 5.4 打印 Mipi LCD 相关 Log 信息打开 Mipi DBG 的接口12345driver/video/rockchip/transmitter/rk32_mipi_dsi.c 中的: #define MIPI_DBG(x...) printk(KERN_INFO x)driver/video/rockchip/screen/lcd_mipi.c 中的: #define MIPI_SCREEN_DBG(x...) printk(KERN_ERR x) 看看 log 中是否有异常。 譬如probe 函数是否正常;是否有调用到 rk32_dsi_enable() 函数,该函数为 lcdc 调用 mipi 的入口函数;初始化 mipi 的过程中是否有报错等等 电源控制部分对应的操作函数:driver/video/rockchip/screen/lcd_mipi.c 的rk_mipi_screen_pwr_enable(),rk_mipi_screen_pwr_disable()。 Clock 部分在 drivers/video/rockchip/transmitter/rk32_mipi_dsi.c 可以添加如下打印12345678910111213141516 256 static int rk312x_mipi_dsi_phy_set_gotp(struct dsi *dsi, u32 offset, int n) 257 &#123; 258 u32 val = 0, temp = 0, Tlpx = 0; 259 u32 ddr_clk = dsi-&gt;phy.ddr_clk; 260 u32 Ttxbyte_clk = dsi-&gt;phy.Ttxbyte_clk; 261 u32 Tsys_clk = dsi-&gt;phy.Tsys_clk; 262 u32 Ttxclkesc = dsi-&gt;phy.Ttxclkesc; 263 printk(\"%s : ddr_clk %d\\n\", __func__, ddr_clk); 1123 static int rk32_mipi_dsi_enable_hs_clk(void *arg, u32 enable)1124 &#123;1125 struct dsi *dsi = arg;1126 printk(\"rk32_mipi_dsi_enable_hs_clk,enable=%d\\n\",enable);1127 rk32_dsi_set_bits(dsi, enable, phy_txrequestclkhs);1128 return 0;1129 &#125; dts 中也有一些 Debug 的开关可以打开以协助分析问题。RK 手册中会有更加详细的描述，这里不赘述了。 5.5 上电时序是否正常根据前面我们从 datasheet 中扣出来的上电时序图 确认上电时序是否正常，VCC、RST、MIPI 顺序是否正常。 VCC 使能有没有起作用。 RST 是否有一个 低-高 的变化，没有则是 rst 设置的触发方式可能反了 在 RST 变高后会开始传输数据，量 lanes 是否有数据输出。抓取数据需要一定规格的示波器和差分探头，我们用普通的示波器大致看看有没有数据输出就够了。 如果到这篇文章中的所有办法都用完了还没有点亮，只能来这里重新测 data 和 clk 波形是否正常。如果也正常,那就需要确认 mipi phy 是否把初始化命令正确发送出来。用差分探头在单端模式下抓 mipi phy 的 lane0N 和 lane0P。命令也是正常的，屏依旧还没有点亮，只能进一步分析 mipi 协议了。 5.6 clock 是否正常用示波器量波形看 DCLK 的频率为多少，是否为 dsi_hs_clk 中设置的（可能实际的会略低一点）。实际的 DCLK 是否满足屏的要求。 5.7 可以显示了但是 花屏/闪屏/抖动 等见后面的问题集锦 5.8 进一步分析 Mipi 协议屏参、上电时序、clock 啥都确定是对的了。竟然还是无法点亮屏幕。最后只能分析协议。这是网友 @nice 碰到的问题。最后发现是 LP00 的时间不对，RK 平台默认是 85ms，但是屏要求是 15ms。修改后正常。参考文章：http://blog.csdn.net/g_salamander/article/details/9163455我就不重复造轮子了。上面这篇文章写的非常好。等什么时候我有更深的感悟了也写一篇包含自己体会的 Mipi 协议分析博客好了。 六、问题集锦RK 的官方文档中描述了不少问题，我这边就不再赘述了。以下是我碰到的一些问题的解决办法，还有一些从网上搜到的发挥了作用的解决办法，一并都附在这里了。 6.1 RST 复位不正常我们 RST 是低电平有效，所以我想当然的将 RST 设置为ACTIVE_LOW。 我在调试的时候发现 lane 一直为低电平，没有数据传输，然后采取量 RST 发现唤醒屏后待到屏幕快灭了 RST 才会被拉高。跟代码发现 RK 平台的实现是 12！你设置的触发电平你设置的触发电平 我设置的触发电平是 低电平有效 ACTIVE_LOW即12！ACTIVE_LOWACTIVE_LOW 即先高再低。所以是错的，改为 ACTIVE_HIGH 后正常。 但是虽然填的是 ACTIVE_HIGH ，但是根据驱动应该还是属于低电平有效的，这里是 RK 平台 driver 的实现有问题。修改后 lane 有数据传递了。 6.2 有数据传输，但是 cmds 有问题cmds 有的参数超过了 32个字节（有个有36个字节，有个有39个字节），完成 dtsi 中 cmds 编写后烧录，板子跑飞，空指针异常。发现传递 这个超长 参数的时候有内存溢出情况。于是跟代码发现 dcs_cmd.cmds 的数据类型为 int cmds[32]，所以擅自想当然的将包拆成了 39 = 28+11，还将其中的延时设置为 0 。这样当然是不行的。但是一切都是基于这个拆了包的 cmds 来调，走了不少弯路。 于是去联系原厂的工程师，说平台参数大小有限制，咨询拆包是否可行。他们说可以直接修改 cmds 数组大小，将 cmds[32] 改成了 cmds[400] 。 这个问题在 RK 后来的 kernel 中被更新了。 所以有时候碰到问题需要确认一下 kernel 是不是最新的，也许会有意想不到的效果。 6.3 开机 Logo 闪烁，且水平方向向右偏移压缩了半个屏幕在点亮屏后刚开始有开机 logo 闪烁，向右偏移了近半个屏幕的长度。重新确认 clock-frequence 后发现少打了一个 0 。修改后解决了 闪烁，大偏移 的问题。 6.4 偏移巨大如下面这张图，偏移的特别多，可能是 dclk 有问题，修改 dsi_hs_clk 由 504 降到 496 解决。 比如下面这张图，也是偏移的很多，将 dclk 增加解决。 6.5 偏移一点点如下图，一般修改 HBP、HFP、VBP、VFP 即可。 6.6 水平方向似乎被裁剪（偏移）如下图，实际是 HBP 的问题。增大 HBP 后解决，将 HBP 由 10 增加到 30。 6.7 正常开机可以点亮，休眠唤醒无法点亮。dclk 有问题。用示波器去测究竟 dclk 出来的是多少。比如我设置的 470 开机启动可以点亮，休眠唤醒无法点亮。用示波器一测，竟然才 200 Mbps，修改到 584 后（实际出来为 450） 休眠唤醒才也可以点亮。 6.8 白屏（偶尔）白屏有可能是静电问题，把 LCD 拿到头发上擦几下，如果很容易出现白屏那肯定就是静电问题了。另外一个在有Backend IC的情况下，也有可能bypass没处理好。 6.9 白屏（开机 Logo 到 Android 动画之间）結束開機logo至Android動畫出現之間出現閃屏或者閃白光的情況。原因：在這個時間點kernel會會對屏再次初始化，我們可以軟件上屏蔽第一次初始化動作從而解决。 6.10 白屏（进入睡眠 suspend / 开始显示 resume 时）喚醒屏幕閃白光問題，說白了是背光早亮了，很有可能是下序列mdelay太久，改小點就沒有這個問題了。根本原因屏幕初始化序列下慢了。sleep out（0x11）和 display on（0x29）之间需要 mdelay（120ms）左右。 6.11 花屏LCD 初始化成功，但是 RGB 没有刷过来。优先确认 timing 中的 pclk，另外还有可能是总线速度有问题。 开机花屏最简单的解决方式是，在 Init 结束的地方加一个刷黑屏的功能。也可以在睡眠函数里加延时函数。 6.12 闪烁（快速，大量） pclk 有问题在最开始的时候，我的 pclk 漏了一个 0 ，为之前的 1/10 此时就有图像闪烁问题。 proch 有问题在调试完后，我尝试将 proch 增加到极限，发现会出现图像闪烁的问题。 6.13 闪烁（偶尔）通过调节电压来稳定，一般调节的电压为VRL、VRH、VDV和VCM 6.14 闪烁（唤醒 resume 时）RST 后下载初始化时序时间过长，适当减少 delay 时间可以解决。 6.15 抖动测时序，延时不足 6.16 灰屏（唤醒时）寄存器没有使能外部升压电路 6.17 水波纹通常都是rgb interface polarity導致，需要調整pclk hsync vsync de極性使之符合平台極性 6.18 调节对比度VRL、VRH、VDV和VCM，这些电压也可以用来调节亮暗（对比度）也可以通过调节Gamma值来实现，要调节的对象为 PRP、PRN、VRP、VRN 等 6.19 图像颜色不正常可能时钟型号极性反了可能 VCOM 调节不正常进行 GAMMA 校正 6.20 明暗色过渡部分，出现不停闪动的亮点pixel clock 极性，由上升沿采样改为下降沿采样即可。 最后，我上面说的都是废话。最好的资料就是 RK 官方的TRM 、屏的 Spec 和 Mipi DSI 协议规格书。LCD 这边的变数太多了，一万个工程师可以碰到一万种屏不显示的情况。网上搜再多资料也没有抓波、抓上电时序，对照官方手册确认 来的实在。 本文地址：http://blog.csdn.net/dearsq/article/details/77341120作者 Younix，欢迎转载，转载请著名出处，谢谢。","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Day01 什么是查理·芒格的人生开关","slug":"Life/Learning/王烁30天认知训练营 Day01 什么是查理·芒格的人生开关","date":"2017-08-14T04:01:05.000Z","updated":"2018-11-08T01:30:40.291Z","comments":true,"path":"2017/08/14/Life/Learning/王烁30天认知训练营 Day01 什么是查理·芒格的人生开关/","link":"","permalink":"http://iyounix.com/2017/08/14/Life/Learning/王烁30天认知训练营 Day01 什么是查理·芒格的人生开关/","excerpt":"","text":"《穷查理宝典》 投资决策方法一：翻转从失败的决策中获得经验。 方法二：跨界蠢人和愚蠢 是学习资料。 思维定势导致的误判心理学 激励。用利益而不是道理说服。 爱。 恨。 讨厌不确定性。立即行动。 一致性。好习惯事半功倍。 好奇心。 公平。 妒忌。 追求暴利。 联系。 有些无关的东西，也许只是肤浅的摆在一起，也会对人的判断造成影响。波斯信使综合症。 否认现实。 过度重视自己。 过度自信。少想自己，多想概率。看数据。 厌恶损失。 寻找认同。 对标。比如一个人买辆车，容易买很多配件。 重视容易获得的东西。 服从权威。所以要慎用人。 万事皆有理由。让别人做事的时候让他们知道为什么。 组合上面的开关。 思维误判的解决方法 每个人都有这些思考的快捷方式。 要意识到自己处于这些思维方式之中解药：1.1 对照清单，检查决策1.2 冷静期1.3 算概率1.4 参照系，通过比较进行决策1.5 前后不一致，接受自相矛盾1.6 直面真相，不管他有多么难以接受","categories":[],"tags":[{"name":"InnerPath","slug":"InnerPath","permalink":"http://iyounix.com/tags/InnerPath/"}]},{"title":"Android6.0 修改默认输入法为 Sogou","slug":"Android_App/[Android6.0][MTK6737] 修改默认输入法为 Sogou","date":"2017-08-05T15:01:05.000Z","updated":"2018-11-08T03:25:24.512Z","comments":true,"path":"2017/08/05/Android_App/[Android6.0][MTK6737] 修改默认输入法为 Sogou/","link":"","permalink":"http://iyounix.com/2017/08/05/Android_App/[Android6.0][MTK6737] 修改默认输入法为 Sogou/","excerpt":"","text":"Hardware:MT6737DeviceOS:Android6.0Kernel: Linux3.18HostOS: Ubuntu16.04 [TOC] 预置 APP12345678910111213141516171819202122232425262728293031323334353637383940414243444546commit f99f8c8092e65cbadf138c9e6b55fb9f22160425Author: dearsq &lt;zhang.yang@aiiage.com&gt;Date: Fri May 11 12:33:01 2018 +0800 将 Sogou 作为内置输入法 APK Change-Id: If5ec1311a0cc36a3300effbe5a3ea50c157d7793diff --git a/apps/Sogou/Android.mk b/apps/Sogou/Android.mknew file mode 100644index 0000000..7513cf4--- /dev/null+++ b/apps/Sogou/Android.mk@@ -0,0 +1,28 @@+LOCAL_PATH := $(call my-dir)++include $(CLEAR_VARS)++LOCAL_MODULE := Sogou++LOCAL_MODULE_TAGS := optional++LOCAL_SRC_FILES := $(LOCAL_MODULE).apk++LOCAL_MODULE_CLASS := APPS++LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)++LOCAL_PREBUILT_JNI_LIBS := \\+ @lib/armeabi-v7a/libmono.so \\+ @lib/armeabi-v7a/libyuvutil.so \\+ @lib/armeabi-v7a/libbutterfly.so \\+ @lib/armeabi-v7a/libluajava.so \\+ @lib/armeabi-v7a/libNinepatch.so \\+ @lib/armeabi-v7a/libweibosdkcore.so \\+ @lib/armeabi-v7a/libmain.so \\+ @lib/armeabi-v7a/libsogouupdcore.so \\+ @lib/armeabi-v7a/liblegalkey.so ++LOCAL_CERTIFICATE := PRESIGNED+include $(BUILD_PREBUILT)+diff --git a/apps/Sogou/Sogou.apk b/apps/Sogou/Sogou.apknew file mode 100644index 0000000..b72d600Binary files /dev/null and b/apps/Sogou/Sogou.apk differ 参考 https://blog.csdn.net/long375577908/article/details/78270702 查看所有的输入法的包名代码内进行如下修改12345678910--- a/base/services/core/java/com/android/server/InputMethodManagerService.java+++ b/base/services/core/java/com/android/server/InputMethodManagerService.java@@ -3037,6 +3037,7 @@ public class InputMethodManagerService extends IInputMethodManager.Stub &#125; if (DEBUG) Slog.d(TAG, &quot;Checking &quot; + compName);+ Slog.d(TAG, &quot;Checking packageName:&quot; + si.packageName + &quot; name:&quot; + si.name); try &#123; InputMethodInfo p = new InputMethodInfo(mContext, ri, additionalSubtypes); 开机阶段1adb logcat | grep &quot;Checking &quot; 可以看到内置的所有输入法的名字 查看 Setting 中我们需要写入的值在设置的 语言和输入法 界面点击切换输入法.会出现如下 Log1234adb logcat | grep SettingsProvider05-10 11:52:58.431 891 909 V SettingsProvider: packageValueForCallResult, name = default_input_method, value : com.cootek.smartinputv5/com.cootek.smartinput5.TouchPalIME05-10 11:52:58.445 891 891 V SettingsProvider: packageValueForCallResult, name = enabled_input_methods, value : com.android.inputmethod.latin/.LatinIME:com.cootek.smartinputv5/com.cootek.smartinput5.TouchPalIME 所以我们知道了我们需要去操作的值是default_input_method 和 enabled_input_methods 在代码中写入 Setting 的值1234567891011121314151617181920212223242526272829--- a/base/packages/SettingsProvider/res/values/defaults.xml+++ b/base/packages/SettingsProvider/res/values/defaults.xml@@ -22,6 +22,9 @@ &lt;integer name=&quot;def_sleep_timeout&quot;&gt;-1&lt;/integer&gt; &lt;bool name=&quot;def_airplane_mode_on&quot;&gt;false&lt;/bool&gt; &lt;bool name=&quot;def_theater_mode_on&quot;&gt;false&lt;/bool&gt;++ &lt;string name=&quot;enabled_input_methods&quot; translatable=&quot;false&quot;&gt;com.sohu.inputmethod.sogou/.SogouIME&lt;/string&gt;+ &lt;string name=&quot;def_input_method&quot; translatable=&quot;false&quot;&gt;com.sohu.inputmethod.sogou/.SogouIME&lt;/string&gt; &lt;!-- Comma-separated list of bluetooth, wifi, and cell. --&gt; &lt;string name=&quot;def_airplane_mode_radios&quot; translatable=&quot;false&quot;&gt;cell,bluetooth,wifi,nfc,wimax&lt;/string&gt; &lt;string name=&quot;airplane_mode_toggleable_radios&quot; translatable=&quot;false&quot;&gt;bluetooth,wifi,nfc&lt;/string&gt;diff --git a/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java b/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.javaindex be664ae..0bb063c 100644--- a/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java+++ b/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java@@ -2463,6 +2463,13 @@ class DatabaseHelper extends SQLiteOpenHelper &#123; loadSetting(stmt, Settings.Secure.LOCATION_PROVIDERS_ALLOWED, mUtils.getStringValue(Settings.Secure.LOCATION_PROVIDERS_ALLOWED, R.string.def_location_providers_allowed));+ + // Added by Younix+ loadStringSetting(stmt, Settings.Secure.ENABLED_INPUT_METHODS,+ R.string.enabled_input_methods);+ loadStringSetting(stmt, Settings.Secure.DEFAULT_INPUT_METHOD,+ R.string.def_input_method);+ // End Added String wifiWatchList = SystemProperties.get(&quot;ro.com.android.wifi-watchlist&quot;); 这里不同版本的 Android 可能 loadStringSetting 的实现不一样.可以自己看下 loadStringSetting 的实现然后传参. 补充:MTK平台FAQ汇总如果按照如上的步骤没有修改成功，请参考如下步骤进行检查修改：（1）检查是否成功预置输入法：FAQ13232（2）检查下setting– language&amp;input 界面，该输入法前面的勾是否选上，没有选上说明此输入法没有被enable，请参考FAQ08909来enable；（3）检查是否发生语言切换，如果有切换则会恢复默认输入法，若不想因语言变化导致恢复，请参考FAQ12213，FAQ06663（4）修改默认输入法FAQ04327 06663【描述】切换系统语言后默认输入法会自动切换到latin输入法，或者系统预置的默认输入法不能生效【解法】KK、L、M 的解决方案： 可以在文件inputmethodmanagerservice.java中在构造函数InputMethodManagerService中的最后面，将接收语言改变广播的事件注释掉：12345678910final IntentFilter filter = new IntentFilter(); filter.addAction(Intent.ACTION_LOCALE_CHANGED); mContext.registerReceiver( new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; synchronized(mMethodMap) &#123; //resetStateIfCurrentLocaleChangedLocked();//将此行注释掉 &#125; &#125; &#125;, filter); 这样就可以了。 12213[DESCRIPTION]一些版本设置默认输入法不成功，是因为KK比较晚的版本和之后的版本把默认输入法的代码搬到了InputMethodManagerService.java中。[SOLUTION]首先查看InputMethodManagerService.java中的systemRunning函数中是否有下面红色的代码，如果有则把红色后面蓝色的语句注释掉即可。如果没有红色代码可以参考FAQ06663。123456789101112131415161718192021222324252627if (!mImeSelectedOnBoot) &#123; Slog.w(TAG, &quot;Reset the default IME as \\&quot;Resource\\&quot; is ready here.&quot;); /// M: Loading preinstalled ime from feature option. @&#123; String preInstalledImeName = IMEFeatureOption.DEFAULT_INPUT_METHOD; Slog.i(TAG, &quot;IMEFeatureOption defaultIME : &quot; + preInstalledImeName); if (preInstalledImeName != null) &#123; InputMethodInfo preInstalledImi = null; for (InputMethodInfo imi : mMethodList) &#123; Slog.i(TAG, &quot;mMethodList service info : &quot; + imi.getServiceName()); if (preInstalledImeName.equals(imi.getServiceName())) &#123; preInstalledImi = imi; break; &#125; &#125; if (preInstalledImi != null) &#123; setInputMethodLocked(preInstalledImi.getId(), NOT_A_SUBTYPE_ID); &#125; else &#123; Slog.w(TAG, &quot;Set preinstall ime as default fail.&quot;); resetDefaultImeLocked(mContext); &#125; &#125; /// @&#125; resetStateIfCurrentLocaleChangedLocked(); InputMethodUtils.setNonSelectedSystemImesDisabledUntilUsed( mContext.getPackageManager(), mSettings.getEnabledInputMethodListLocked()); &#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 App中调用init.rc中的服务，从而运行shell脚本","slug":"Android_App/[Android6.0] App中调用init.rc中的服务，从而运行shell脚本","date":"2017-08-05T15:01:05.000Z","updated":"2018-11-08T03:22:43.103Z","comments":true,"path":"2017/08/05/Android_App/[Android6.0] App中调用init.rc中的服务，从而运行shell脚本/","link":"","permalink":"http://iyounix.com/2017/08/05/Android_App/[Android6.0] App中调用init.rc中的服务，从而运行shell脚本/","excerpt":"","text":"OS: Android6.0Hardware: RK3399 需求希望在 Android App 中添加 SPDIF 测试功能。走 Android Audio Manager 太麻烦了。所以希望直接通过 shell 脚本，调用 tinyplay 命令来进行。 实现init.rcInit.rc 中添加 spdiftest 服务1234service spdiftest /system/bin/spdif-test class main disabled oneshot device.mk工程 Device.mk 文件（rk3399_mid.mk）中添加123PRODUCT_COPY_FILES += \\ device/rockchip/rk3399/rk3399_mid/test/spdif-test:system/bin/spdif-test \\ device/rockchip/rk3399/rk3399_mid/test/test-music.wav:system/media/audio/test-music.wav Spdif-test 实际为测试脚本Test-music.wav 实际为测试音频 测试脚本测试脚本 spdif-test 如下1234567891011121314151617181920212223242526272829#!/system/bin/sh #LOG_FILE=/data/spdif-test.log #check input #if [ $# -lt 1 ] ; then #echo &quot;[spdif-test] not wav file to play!&quot; &gt;&gt; $LOG_FILE #exit 1 #fi # test music file : /system/media/audio/test-music.wav # wait $2 seconds #if [ $# -eq 2 ] ; then # echo &quot;[spdif-test] sleep $2 seconds&quot; &gt;&gt; $LOG_FILE # sleep $2 #fi # play wav file # echo &quot;[spdif-test] start play , wav file is $WAV_FILE&quot; &gt;&gt; $LOG_FILE tinymix -D 0 &quot;Stereo DAC MIXL DAC L1 Switch&quot; 1 tinymix -D 0 &quot;Stereo DAC MIXR DAC R1 Switch&quot; 1 tinymix -D 0 &quot;OUT MIXL DAC L1 Switch&quot; 1 tinymix -D 0 &quot;OUT MIXR DAC R1 Switch&quot; 1 tinymix -D 0 &quot;HPOVOL L Switch&quot; 1 tinymix -D 0 &quot;HPOVOL R Switch&quot; 1 tinymix -D 0 &quot;HPO MIX HPVOL Switch&quot; 1 tinymix -D 0 &quot;HPO L Playback Switch&quot; 1 tinymix -D 0 &quot;HPO R Playback Switch&quot; 1 tinyplay /system/media/audio/test-music.wav -D 1 -d 0 App 中利用 SystemProperties 调用在 App 中通过 SystemProperties.set(“ctl.start”,”spdiftest”);调用 spdiftest 服务（实际是 spdif-test 脚本) 1234private void setSpdifOn() throws IOException &#123; SystemProperties.set(&quot;ctl.start&quot;,&quot;spdiftest&quot;); Log.v(TAG, &quot;Call System Service &apos;spdiftest&apos; in init.rc to test SPDIF.&quot;);&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Linux 下访问 NAS 服务器","slug":"Environment/[Ubuntu] Linux下访问NAS服务器","date":"2017-08-05T15:01:05.000Z","updated":"2018-11-08T02:09:31.729Z","comments":true,"path":"2017/08/05/Environment/[Ubuntu] Linux下访问NAS服务器/","link":"","permalink":"http://iyounix.com/2017/08/05/Environment/[Ubuntu] Linux下访问NAS服务器/","excerpt":"","text":"NAS 一定搭建了 SAMBA 服务（CIFS）。1sudo mount -t cifs //服务器IP/服务器文件夹 -o username=你的帐号,password=你的密码 /home/挂载点 如果 NAS 开启了 NFS ，-t 也可以指定 NFS。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"Linux 以 SPI 驱动模型为例分析 Linux 主机驱动与外设驱动分离模型","slug":"Android_Driver/Driver/[Linux4.4] 以 SPI 驱动模型为例分析 Linux 主机驱动与外设驱动分离模型","date":"2017-08-05T15:01:05.000Z","updated":"2018-11-08T02:48:48.980Z","comments":true,"path":"2017/08/05/Android_Driver/Driver/[Linux4.4] 以 SPI 驱动模型为例分析 Linux 主机驱动与外设驱动分离模型/","link":"","permalink":"http://iyounix.com/2017/08/05/Android_Driver/Driver/[Linux4.4] 以 SPI 驱动模型为例分析 Linux 主机驱动与外设驱动分离模型/","excerpt":"","text":"一种简单却笨拙的解决方式其实在对于一块板子，我们是可以直接操作 CPU （CPU_chip）上的 SPI Controller Register 来达到 访问 SPI 设备 （SPI_device）的目的。但是这样对于一块板子一个设备我们就要写一套驱动：12345678910\\\\writereturn_type CPUchip_write_SPIdevice(...)&#123;CPUchip_write_spi_host_ctrl_reg(ctrl);CPUchip_ write_spi_host_data_reg(buf);while(!(CPUchip_spi_host_status_reg()&amp;SPI_DATA_TRANSFER_DONE));...&#125;\\\\read... 主机驱动与设备驱动的分离思想那么对于三种 CPU 三种 SPI 设备，九种类型的组合方式，那我们就需要写 九种 驱动。这显然非常麻烦。我们发现 三种 CPU A B C 的驱动 和 三种外设 a b c 的驱动并没有关系，前者不关心外设，后者也不关心主芯片。所以就有了如下分离的模型 主控制器 A 驱动 ——| 核 心 层 core |—— 外设 a 驱动主控制器 B 驱动 ——| 主机通用驱动 |—— 外设 b 驱动主控制器 C 驱动 ——| _ API __ |—— 外设 c 驱动 而且我们的 SPI、I2C、USB、ASoC（ALSA SoC）等子系统正是以这种分离设计思想来创建的。 设备驱动设计时的分层思想前面我们将驱动分层了三层： 设备驱动 核心层 core 主机控制器驱动 设备驱动 和 主机控制器驱动 之间的交互交由 核心层 提供的接口来完成。这样大大方便了我们驱动的开发，当我们要开发或者移植一个设备的时候，我们要做的就是编写 设备驱动 部分。 在设计设备驱动的时候，内核为 同类的设备 设计了一个框架，这个框架中的核心层中实现了这个设备一些通用的功能。而且当我们不想使用这些核心层函数的时候，我们可以自行重载。1234567return_type core_funca(xxx_device * bottom_dev, param1_type param1, param1_type param2) &#123; if (bottom_dev-&gt;funca) return bottom_dev-&gt;funca(param1, param2); /* 核心层通用的funca代码 */ ... &#125; 比如在这个 core_funca 中，一开始会检查我们是否有重载这个 funca() ，如果有重载，就去调用底层的代码，否则，就采用默认的通用的核心层的。这样的话，默认的核心层的代码可以处理绝大多数的同类设备，只有少数的特殊设备需要自行重载。 再比如，如果为了实现 funca() ，对于统一类设备，我们操作流程是一致的，过程是： 通用代码 A 底层 ops1 通用代码 B 底层 ops2 通用代码 C 底层 ops3123456789101112return_type core_funca(xxx_device * bottom_dev, param1_type param1, param1_type param2) &#123; /*通用的步骤代码A */ ... bottom_dev-&gt;funca_ops1(); /*通用的步骤代码B */ ... bottom_dev-&gt;funca_ops2(); /*通用的步骤代码C */ ... bottom_dev-&gt;funca_ops3(); &#125; 这样做的好处是，具体的底层驱动不需要再实现，而只需要关心 ops1 ops2 ops3 这些底层操作，即： 设备 的 core 层. | . . . . . . . . | . . | . . . . . . . . | .实例 A . 实例 B 以 SPI 设备为例来分析 设备驱动与主控驱动分离的思想几个重要的结构体和API对 SPI 驱动模型不了解的可以参考我前面的几篇博文，这里只先提一下几个重要的结构体： spi_masterspi_master 结构体来描述一个SPI主机控制器驱动，其主要成员是 1. 主机控制器的序号（系统中可能存在多个SPI主机控制器）、2. 片选数量、3. SPI模式和时钟设置用到的函数、4. 数据传输用到的函数等。1234567891011struct spi_master &#123; struct device dev; s16 bus_num; u16 num_chipselect; /* 设置模式和时钟 */ int (*setup)(struct spi_device *spi); /* 双向数据传输 */ int (*transfer)(struct spi_device *spi, struct spi_message *mesg); void (*cleanup)(struct spi_device *spi);&#125;; 分配、注册、注销 SPI主机控制器这部分由 SPI 核心提供123struct spi_master * spi_alloc_master(struct device *host, unsigned size); int spi_register_master(struct spi_master *master); void spi_unregister_master(struct spi_master *master); spi_driverspi_driver 用以描述一个 SPI 外设驱动，可以认为是 spi_master 的 client 驱动。而且我们可以看到 它 和 platform_driver 结构体很相似。这其实几乎是一切 设备驱动 的模板。12345678struct spi_driver &#123; int (*probe)(struct spi_device *spi); int (*remove)(struct spi_device *spi); void (*shutdown)(struct spi_device *spi); int (*suspend)(struct spi_device *spi, pm_message_t mesg); int (*resume)(struct spi_device *spi); struct device_driver driver;&#125;; spi_transfer 与 spi_message对于 SPI 外设驱动。 当通过 SPI 总线进行数据传输的时候，使用了一个叫做 spi_async() 的函数来进行数据传输。通常这个函数被封装在 spi_sync() 中。 spi_async() 传输的数据就是 spi_message。 spi_message 中将包含由多个 spi_transfer 组成的 transfers。1234567891011121314struct spi_transfer &#123; const void *tx_buf; void *rx_buf; unsigned len; dma_addr_t tx_dma; dma_addr_t rx_dma; unsigned cs_change:1; u8 bits_per_word; u16 delay_usecs; u32 speed_hz; struct list_head transfer_list;&#125;; 一次完整的传输可能包含一个或多个 spi_transfer，他们的首地址被加入 transfers 的链表，然后被装在一个 spi_message 中。1234567891011121314struct spi_message &#123; struct list_head transfers; struct spi_device *spi; unsigned is_dma_mapped:1; /* 完成被一个callback报告 */ void (*complete)(void *context); void *context; unsigned actual_length; int status; struct list_head queue; void *state;&#125;; 传输的流程为123456789// 初始化 spi_messagespi_message_init() // 将 spi_transfer 添加到 spi_message 中void spi_message_add_tail(struct spi_transfer *t, struct spi_message *m); /*发起一次 spi_message 的方式 有 同步 和 异步 两种 */ // 使用同步API时，会阻塞等待这个消息被处理完。同步操作时使用的API是：int spi_sync(struct spi_device *spi, struct spi_message *message);// 使用异步API时，不会阻塞等待这个消息被处理完，但是可以在spi_message的complete字段挂接一个回调函数，当消息被处理完成后，该函数会被调用。异步操作时使用的API是：int spi_async(struct spi_device *spi, struct spi_message *message); 一个实例1234567891011121314151617181920212223242526static inline intspi_write(struct spi_device *spi, const u8 *buf, size_t len)&#123; struct spi_transfer t = &#123; .tx_buf = buf, .len = len, &#125;; struct spi_message m; spi_message_init(&amp;m); spi_message_add_tail(&amp;t, &amp;m); return spi_sync(spi, &amp;m);&#125;static inline intspi_read(struct spi_device *spi, u8 *buf, size_t len)&#123; struct spi_transfer t = &#123; .rx_buf = buf, .len = len, &#125;; struct spi_message m; spi_message_init(&amp;m); spi_message_add_tail(&amp;t, &amp;m); return spi_sync(spi, &amp;m);&#125; BSP 板级文件注册方式SPI core 在 kernel/driver/spi/spi.c 当中，在其中实现了 spi_setup() 等成员函数。 和platform_driver对应着一个platform_device一样，spi_driver也对应着一个spi_device；platform_device需要在BSP的板文件中添加板信息数据，而spi_device也同样需要。spi_device的板信息用spi_board_info结构体描述，该结构体记录SPI外设使用的主机控制器序号、片选序号、数据比特率、SPI传输模式（即CPOL、CPHA）等。然后在Linux启动过程中，在机器的init_machine()函数中，会通过如下语句注册这些spi_board_info：spi_register_board_info(xxx_spi_board_info,ARRAY_SIZE(xxx_spi_board_info));这一点和启动时通过platform_add_devices()添加platform_device非常相似。 DTS 设备树注册方式我们 SPI 设备驱动中，通过 of_match_table 添加匹配的 .dts 中的相关节点的 compatible 属性， 和 DeviceTree 中设备节点 compatible 属性进行匹配。 另外还有一种别名匹配，我们知道 compatible 属性的组织形式为,。别名其实就是去掉 compatible 属性中逗号前的manufacturer前缀。根据这一点，可查看drivers/spi/spi.c的源代码，函数 spi_match_device() 暴露了更多的细节，如果别名出现在设备 spi_driver 的 id_table 里面，或者别名与spi_driver的name字段相同，SPI设备和驱动都可以匹配上。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"Ubuntu 服务器添加硬盘方法","slug":"Environment/[Ubuntu] 服务器添加硬盘方法","date":"2017-08-05T15:01:05.000Z","updated":"2018-11-08T02:10:18.519Z","comments":true,"path":"2017/08/05/Environment/[Ubuntu] 服务器添加硬盘方法/","link":"","permalink":"http://iyounix.com/2017/08/05/Environment/[Ubuntu] 服务器添加硬盘方法/","excerpt":"","text":"[TOC] 服务器容量 10 T 竟然只剩 50G 不到了～于是公司加了 500 G 的普通硬盘用于存放不常用的源码。 环境：Linux ubuntu 3.11.0-15-generic #25~precise1-Ubuntu SMP Thu Jan 30 17:39:31 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux 以下是步骤： 查看当前硬盘状况12$ df -h $ ls -l /dev/sd* 可以看到 sdb 是我们的第二块硬盘 1$ fdisk -l 可以看到Disk /dev/sdb doesn’t contain a valid partition table我们看到 sdb 还未挂载。 添加分区1$ sudo fdisk sdb 按 m 帮助可以看到用法 依次输入n //添加分区p //主要分区 //p表示主要 e表示拓展1 //起始分区号1 //起始扇区 //我这里填的是 2048+500 //最后的扇区W //确认 之后我们就可以在 /dev 下看到 sdb1 的存在了 分区格式化将分区设置为 ext4 格式1$ mkfs -t ext4 /dev/sdb1 执行完这条命令需要等待一下，格式化分区 挂载分区到用户目录比如我们需要挂载这个 sdb1 分区到 用户 atu 的 atusoftware 目录下：在 root 用户下执行12# mkdir /home/atu/atusoftware# mount /dev/sdb1 /home/atu/atusoftware 执行服务器开机自动挂载修改 /etc/fstab 文件1$sudo vi /etc/fstab 添加如下内容1/dev/sdb1 /home/atu/softwaredata ext4 defaults 0 0 该行内容表达的意思是 &lt; file system&gt; 什么文件系统 &lt; mount point&gt; 挂载点在哪 &lt; type&gt; 文件系统的类型呢 &lt; options&gt; 选项，一般填默认 defaults &lt; dump&gt; 是否要备份文件系统，1 备份 0 不备份 &lt; pass&gt; 以什么顺序检查文件系统，0 不检查 点击这里有一篇 /etc/fstab 详解 至此，重新登录 ssh atu@[IP] 可以正常访问下面的 atusoftware 目录。scp 也可以正常上传下载东西。 完。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"Ubuntu 在终端中利用Wget/aria2下载百度云资源","slug":"Environment/[Ubuntu] 在终端中利用Wget下载百度云资源","date":"2017-08-05T15:01:05.000Z","updated":"2018-11-08T02:10:00.552Z","comments":true,"path":"2017/08/05/Environment/[Ubuntu] 在终端中利用Wget下载百度云资源/","link":"","permalink":"http://iyounix.com/2017/08/05/Environment/[Ubuntu] 在终端中利用Wget下载百度云资源/","excerpt":"","text":"OS: Ubuntu16.04Tools: Baiduyun、Wget 需求Linux 下暂时没有好用的 百度云应用。利用 Chrome 浏览器直接下载百度云大文件不支持断点续传，一旦失败就要重头开始下。所以考虑采用 Wget 来下载资源。 another way is using BaiduExporter + aria2, Verrrrrrrry Good. 步骤比如我现在下载 windows7 的镜像。 百度云地址是 ：https://pan.baidu.com/s/1jIhvmrc 1. 获取链接点击 下载 Ctrl + J 进入 Chrome 的下载管理器，查看其真实下载地址的链接： 中间的地址就是真实的地址。右键复制。1https://d11.baidupcs.com/file/91d7089992e41c2ed7017521e6efca6f?bkt=p3-0000eb279d3adf2c1d1267e23789d078b33d&amp;xcode=ee54de7d24eb85e9b28459f49768aa8ef20ac5b0ff7c90640b2977702d3e6764&amp;fid=2288450327-250528-699849965031568&amp;time=1497174234&amp;sign=FDTAXGERLBHS-DCb740ccc5511e5e8fedcff06b081203-daZ89sIbCMzSqrQr0WMEIvK2owo%3D&amp;to=d11&amp;size=4092624896&amp;sta_dx=4092624896&amp;sta_cs=895&amp;sta_ft=iso&amp;sta_ct=5&amp;sta_mt=5&amp;fm2=MH,Yangquan,Netizen-anywhere,,guangdong,ct&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=0000eb279d3adf2c1d1267e23789d078b33d&amp;sl=76480590&amp;expires=8h&amp;rt=sh&amp;r=896598456&amp;mlogid=3751180020012367572&amp;vuk=28420&amp;vbdid=1640506990&amp;fin=YLMF_GHOST_WIN7_X64_AQWD.iso&amp;fn=YLMF_GHOST_WIN7_X64_AQWD.iso&amp;rtype=1&amp;iv=0&amp;dp-logid=3751180020012367572&amp;dp-callid=0.1.1&amp;hps=1&amp;csl=80&amp;csign=QAYtCvA3moi4oLKno0uhupHAU9A%3D&amp;by=themis 2. 利用 wget 命令下载参照如下格式开始下载： 1wget -c --referer=百度云短链接 -O 文件名 &quot;真实链接&quot; 所以我们下载的命令为： 1wget -c --referer=https://pan.baidu.com/s/1jIhvmrc -O windows7_64.iso &quot;https://d11.baidupcs.com/file/91d7089992e41c2ed7017521e6efca6f?bkt=p3-0000eb279d3adf2c1d1267e23789d078b33d&amp;xcode=ee54de7d24eb85e9b28459f49768aa8ef20ac5b0ff7c90640b2977702d3e6764&amp;fid=2288450327-250528-699849965031568&amp;time=1497174234&amp;sign=FDTAXGERLBHS-DCb740ccc5511e5e8fedcff06b081203-daZ89sIbCMzSqrQr0WMEIvK2owo%3D&amp;to=d11&amp;size=4092624896&amp;sta_dx=4092624896&amp;sta_cs=895&amp;sta_ft=iso&amp;sta_ct=5&amp;sta_mt=5&amp;fm2=MH,Yangquan,Netizen-anywhere,,guangdong,ct&amp;newver=1&amp;newfm=1&amp;secfm=1&amp;flow_ver=3&amp;pkey=0000eb279d3adf2c1d1267e23789d078b33d&amp;sl=76480590&amp;expires=8h&amp;rt=sh&amp;r=896598456&amp;mlogid=3751180020012367572&amp;vuk=28420&amp;vbdid=1640506990&amp;fin=YLMF_GHOST_WIN7_X64_AQWD.iso&amp;fn=YLMF_GHOST_WIN7_X64_AQWD.iso&amp;rtype=1&amp;iv=0&amp;dp-logid=3751180020012367572&amp;dp-callid=0.1.1&amp;hps=1&amp;csl=80&amp;csign=QAYtCvA3moi4oLKno0uhupHAU9A%3D&amp;by=themis&quot; 最后开始下载的界面如下： BaiduExporter + aria2useage:https://blog.icehoney.me/posts/2015-01-31-Aria2-downloadhttps://github.com/acgotaku/BaiduExporter 12$ sudo apt install aria2$ git clone https://github.com/acgotaku/BaiduExporter.git 123456# modified config file $ vi BaiduExporter/aria2c/aria2.conf#文件保存路径, 默认为当前启动位置-- dir=D:\\Downloads++ dir=/home/younix/Downloads/Baiduyun/ 12# point config file which you want to use$ aria2c --conf-path=/home/younix/WorkTools/BaiduExporter/aria2c/aria2.conf Open BaiduyunWebsite and click “ 导出下载” done.","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"Android6.0 RK3399 插上 HDMI 时开机解锁锁屏后死机","slug":"Android_Driver/Debug/[Android6.0][RK3399][BUG] 插上 HDMI 时开机解锁锁屏后死机","date":"2017-07-01T15:33:05.000Z","updated":"2018-11-08T02:52:27.730Z","comments":true,"path":"2017/07/01/Android_Driver/Debug/[Android6.0][RK3399][BUG] 插上 HDMI 时开机解锁锁屏后死机/","link":"","permalink":"http://iyounix.com/2017/07/01/Android_Driver/Debug/[Android6.0][RK3399][BUG] 插上 HDMI 时开机解锁锁屏后死机/","excerpt":"","text":"Platform: RK3399OS: Android 6.0Kernel: Linux4.4Version: v2017.03 现象插上 HDMI 情况下开机，解锁锁屏，会死机。 Kernel 出现如下 log 信息：12345[ 18.415959] rk322x-lcdc vop0: intr post buf empty![ 18.416010] rk322x-lcdc vop0: intr post buf empty![ 18.432623] rk322x-lcdc vop0: intr post buf empty![ 18.432666] rk322x-lcdc vop0: intr post buf empty![ 18.449288] rk322x-lcdc vop0: intr post buf empty! Android 出现如下异常12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420501-18 09:13:49.558 E/Zygote ( 215): Exit zygote because system server (499) has terminated01-18 09:13:49.562 E/DisplayManager( 1465): Could not get display ids from display manager.01-18 09:13:49.562 E/DisplayManager( 1465): android.os.DeadObjectException01-18 09:13:49.562 E/DisplayManager( 1465): at android.os.BinderProxy.transactNative(Native Method)01-18 09:13:49.562 E/DisplayManager( 1465): at android.os.BinderProxy.transact(Binder.java:503)01-18 09:13:49.562 E/DisplayManager( 1465): at android.hardware.display.IDisplayManager$Stub$Proxy.getDisplayIds(IDisplayManager.java:295)01-18 09:13:49.562 E/DisplayManager( 1465): at android.hardware.display.DisplayManagerGlobal.getDisplayIds(DisplayManagerGlobal.java:154)01-18 09:13:49.562 E/DisplayManager( 1465): at android.hardware.display.DisplayManager.getDisplays(DisplayManager.java:284)01-18 09:13:49.562 E/DisplayManager( 1465): at android.media.MediaRouter$Static.getAllPresentationDisplays(MediaRouter.java:320)01-18 09:13:49.562 E/DisplayManager( 1465): at android.media.MediaRouter$RouteInfo.choosePresentationDisplay(MediaRouter.java:1868)01-18 09:13:49.562 E/DisplayManager( 1465): at android.media.MediaRouter$RouteInfo.updatePresentationDisplay(MediaRouter.java:1858)01-18 09:13:49.562 E/DisplayManager( 1465): at android.media.MediaRouter$Static.startMonitoringRoutes(MediaRouter.java:140)01-18 09:13:49.562 E/DisplayManager( 1465): at android.media.MediaRouter.&lt;init&gt;(MediaRouter.java:720)01-18 09:13:49.562 E/DisplayManager( 1465): at android.app.SystemServiceRegistry$7.createService(SystemServiceRegistry.java:193)01-18 09:13:49.562 E/DisplayManager( 1465): at android.app.SystemServiceRegistry$7.createService(SystemServiceRegistry.java:192)01-18 09:13:49.562 E/DisplayManager( 1465): at android.app.SystemServiceRegistry$CachedServiceFetcher.getService(SystemServiceRegistry.java:790)01-18 09:13:49.562 E/DisplayManager( 1465): at android.app.SystemServiceRegistry.getSystemService(SystemServiceRegistry.java:743)01-18 09:13:49.562 E/DisplayManager( 1465): at android.app.ContextImpl.getSystemService(ContextImpl.java:1365)01-18 09:13:49.562 E/DisplayManager( 1465): at android.content.ContextWrapper.getSystemService(ContextWrapper.java:627)01-18 09:13:49.562 E/DisplayManager( 1465): at com.android.keyguard.KeyguardDisplayManager.&lt;init&gt;(KeyguardDisplayManager.java:41)01-18 09:13:49.562 E/DisplayManager( 1465): at com.android.systemui.keyguard.KeyguardViewMediator.setupLocked(KeyguardViewMediator.java:561)01-18 09:13:49.562 E/DisplayManager( 1465): at com.android.systemui.keyguard.KeyguardViewMediator.start(KeyguardViewMediator.java:616)01-18 09:13:49.562 E/DisplayManager( 1465): at com.android.systemui.SystemUIApplication.startServicesIfNeeded(SystemUIApplication.java:139)01-18 09:13:49.562 E/DisplayManager( 1465): at com.android.systemui.SystemUIService.onCreate(SystemUIService.java:31)01-18 09:13:49.562 E/DisplayManager( 1465): at android.app.ActivityThread.handleCreateService(ActivityThread.java:2883)01-18 09:13:49.562 E/DisplayManager( 1465): at android.app.ActivityThread.-wrap4(ActivityThread.java)01-18 09:13:49.562 E/DisplayManager( 1465): at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1430)01-18 09:13:49.562 E/DisplayManager( 1465): at android.os.Handler.dispatchMessage(Handler.java:102)01-18 09:13:49.562 E/DisplayManager( 1465): at android.os.Looper.loop(Looper.java:148)01-18 09:13:49.562 E/DisplayManager( 1465): at android.app.ActivityThread.main(ActivityThread.java:5426)01-18 09:13:49.562 E/DisplayManager( 1465): at java.lang.reflect.Method.invoke(Native Method)01-18 09:13:49.562 E/DisplayManager( 1465): at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:772)01-18 09:13:49.562 E/DisplayManager( 1465): at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:662)01-18 09:13:49.566 E/DisplayManager( 1465): Could not get display information from display manager.01-18 09:13:49.566 E/DisplayManager( 1465): android.os.DeadObjectException01-18 09:13:49.566 E/DisplayManager( 1465): at android.os.BinderProxy.transactNative(Native Method)01-18 09:13:49.566 E/DisplayManager( 1465): at android.os.BinderProxy.transact(Binder.java:503)01-18 09:13:49.566 E/DisplayManager( 1465): at android.hardware.display.IDisplayManager$Stub$Proxy.getDisplayInfo(IDisplayManager.java:273)01-18 09:13:49.566 E/DisplayManager( 1465): at android.hardware.display.DisplayManagerGlobal.getDisplayInfo(DisplayManagerGlobal.java:119)01-18 09:13:49.566 E/DisplayManager( 1465): at android.hardware.display.DisplayManagerGlobal.getCompatibleDisplay(DisplayManagerGlobal.java:178)01-18 09:13:49.566 E/DisplayManager( 1465): at android.hardware.display.DisplayManager.getOrCreateDisplayLocked(DisplayManager.java:326)01-18 09:13:49.566 E/DisplayManager( 1465): at android.hardware.display.DisplayManager.addPresentationDisplaysLocked(DisplayManager.java:314)01-18 09:13:49.566 E/DisplayManager( 1465): at android.hardware.display.DisplayManager.getDisplays(DisplayManager.java:291)01-18 09:13:49.566 E/DisplayManager( 1465): at android.media.MediaRouter$Static.getAllPresentationDisplays(MediaRouter.java:320)01-18 09:13:49.566 E/DisplayManager( 1465): at android.media.MediaRouter$RouteInfo.choosePresentationDisplay(MediaRouter.java:1868)01-18 09:13:49.566 E/DisplayManager( 1465): at android.media.MediaRouter$RouteInfo.updatePresentationDisplay(MediaRouter.java:1858)01-18 09:13:49.566 E/DisplayManager( 1465): at android.media.MediaRouter$Static.startMonitoringRoutes(MediaRouter.java:140)01-18 09:13:49.566 E/DisplayManager( 1465): at android.media.MediaRouter.&lt;init&gt;(MediaRouter.java:720)01-18 09:13:49.566 E/DisplayManager( 1465): at android.app.SystemServiceRegistry$7.createService(SystemServiceRegistry.java:193)01-18 09:13:49.566 E/DisplayManager( 1465): at android.app.SystemServiceRegistry$7.createService(SystemServiceRegistry.java:192)01-18 09:13:49.566 E/DisplayManager( 1465): at android.app.SystemServiceRegistry$CachedServiceFetcher.getService(SystemServiceRegistry.java:790)01-18 09:13:49.566 E/DisplayManager( 1465): at android.app.SystemServiceRegistry.getSystemService(SystemServiceRegistry.java:743)01-18 09:13:49.566 E/DisplayManager( 1465): at android.app.ContextImpl.getSystemService(ContextImpl.java:1365)01-18 09:13:49.566 E/DisplayManager( 1465): at android.content.ContextWrapper.getSystemService(ContextWrapper.java:627)01-18 09:13:49.566 E/DisplayManager( 1465): at com.android.keyguard.KeyguardDisplayManager.&lt;init&gt;(KeyguardDisplayManager.java:41)01-18 09:13:49.566 E/DisplayManager( 1465): at com.android.systemui.keyguard.KeyguardViewMediator.setupLocked(KeyguardViewMediator.java:561)01-18 09:13:49.566 E/DisplayManager( 1465): at com.android.systemui.keyguard.KeyguardViewMediator.start(KeyguardViewMediator.java:616)01-18 09:13:49.566 E/DisplayManager( 1465): at com.android.systemui.SystemUIApplication.startServicesIfNeeded(SystemUIApplication.java:139)01-18 09:13:49.566 E/DisplayManager( 1465): at com.android.systemui.SystemUIService.onCreate(SystemUIService.java:31)01-18 09:13:49.566 E/DisplayManager( 1465): at android.app.ActivityThread.handleCreateService(ActivityThread.java:2883)01-18 09:13:49.566 E/DisplayManager( 1465): at android.app.ActivityThread.-wrap4(ActivityThread.java)01-18 09:13:49.566 E/DisplayManager( 1465): at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1430)01-18 09:13:49.566 E/DisplayManager( 1465): at android.os.Handler.dispatchMessage(Handler.java:102)01-18 09:13:49.566 E/DisplayManager( 1465): at android.os.Looper.loop(Looper.java:148)01-18 09:13:49.566 E/DisplayManager( 1465): at android.app.ActivityThread.main(ActivityThread.java:5426)01-18 09:13:49.566 E/DisplayManager( 1465): at java.lang.reflect.Method.invoke(Native Method)01-18 09:13:49.566 E/DisplayManager( 1465): at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:772)01-18 09:13:49.566 E/DisplayManager( 1465): at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:662)01-18 09:13:49.567 E/DisplayManager( 1465): Could not get display information from display manager.01-18 09:13:49.567 E/DisplayManager( 1465): android.os.DeadObjectException01-18 09:13:49.567 E/DisplayManager( 1465): at android.os.BinderProxy.transactNative(Native Method)01-18 09:13:49.567 E/DisplayManager( 1465): at android.os.BinderProxy.transact(Binder.java:503)01-18 09:13:49.567 E/DisplayManager( 1465): at android.hardware.display.IDisplayManager$Stub$Proxy.getDisplayInfo(IDisplayManager.java:273)01-18 09:13:49.567 E/DisplayManager( 1465): at android.hardware.display.DisplayManagerGlobal.getDisplayInfo(DisplayManagerGlobal.java:119)01-18 09:13:49.567 E/DisplayManager( 1465): at android.hardware.display.DisplayManagerGlobal.getCompatibleDisplay(DisplayManagerGlobal.java:178)01-18 09:13:49.567 E/DisplayManager( 1465): at android.hardware.display.DisplayManager.getOrCreateDisplayLocked(DisplayManager.java:326)01-18 09:13:49.567 E/DisplayManager( 1465): at android.hardware.display.DisplayManager.addPresentationDisplaysLocked(DisplayManager.java:314)01-18 09:13:49.567 E/DisplayManager( 1465): at android.hardware.display.DisplayManager.getDisplays(DisplayManager.java:292)01-18 09:13:49.567 E/DisplayManager( 1465): at android.media.MediaRouter$Static.getAllPresentationDisplays(MediaRouter.java:320)01-18 09:13:49.567 E/DisplayManager( 1465): at android.media.MediaRouter$RouteInfo.choosePresentationDisplay(MediaRouter.java:1868)01-18 09:13:49.567 E/DisplayManager( 1465): at android.media.MediaRouter$RouteInfo.updatePresentationDisplay(MediaRouter.java:1858)01-18 09:13:49.567 E/DisplayManager( 1465): at android.media.MediaRouter$Static.startMonitoringRoutes(MediaRouter.java:140)01-18 09:13:49.567 E/DisplayManager( 1465): at android.media.MediaRouter.&lt;init&gt;(MediaRouter.java:720)01-18 09:13:49.567 E/DisplayManager( 1465): at android.app.SystemServiceRegistry$7.createService(SystemServiceRegistry.java:193)01-18 09:13:49.567 E/DisplayManager( 1465): at android.app.SystemServiceRegistry$7.createService(SystemServiceRegistry.java:192)01-18 09:13:49.567 E/DisplayManager( 1465): at android.app.SystemServiceRegistry$CachedServiceFetcher.getService(SystemServiceRegistry.java:790)01-18 09:13:49.567 E/DisplayManager( 1465): at android.app.SystemServiceRegistry.getSystemService(SystemServiceRegistry.java:743)01-18 09:13:49.567 E/DisplayManager( 1465): at android.app.ContextImpl.getSystemService(ContextImpl.java:1365)01-18 09:13:49.567 E/DisplayManager( 1465): at android.content.ContextWrapper.getSystemService(ContextWrapper.java:627)01-18 09:13:49.567 E/DisplayManager( 1465): at com.android.keyguard.KeyguardDisplayManager.&lt;init&gt;(KeyguardDisplayManager.java:41)01-18 09:13:49.567 E/DisplayManager( 1465): at com.android.systemui.keyguard.KeyguardViewMediator.setupLocked(KeyguardViewMediator.java:561)01-18 09:13:49.567 E/DisplayManager( 1465): at com.android.systemui.keyguard.KeyguardViewMediator.start(KeyguardViewMediator.java:616)01-18 09:13:49.567 E/DisplayManager( 1465): at com.android.systemui.SystemUIApplication.startServicesIfNeeded(SystemUIApplication.java:139)01-18 09:13:49.567 E/DisplayManager( 1465): at com.android.systemui.SystemUIService.onCreate(SystemUIService.java:31)01-18 09:13:49.567 E/DisplayManager( 1465): at android.app.ActivityThread.handleCreateService(ActivityThread.java:2883)01-18 09:13:49.567 E/DisplayManager( 1465): at android.app.ActivityThread.-wrap4(ActivityThread.java)01-18 09:13:49.567 E/DisplayManager( 1465): at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1430)01-18 09:13:49.567 E/DisplayManager( 1465): at android.os.Handler.dispatchMessage(Handler.java:102)01-18 09:13:49.567 E/DisplayManager( 1465): at android.os.Looper.loop(Looper.java:148)01-18 09:13:49.567 E/DisplayManager( 1465): at android.app.ActivityThread.main(ActivityThread.java:5426)01-18 09:13:49.567 E/DisplayManager( 1465): at java.lang.reflect.Method.invoke(Native Method)01-18 09:13:49.567 E/DisplayManager( 1465): at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:772)01-18 09:13:49.567 E/DisplayManager( 1465): at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:662)01-18 09:13:49.569 E/DisplayManager( 1465): Could not get display information from display manager.01-18 09:13:49.569 E/DisplayManager( 1465): android.os.DeadObjectException01-18 09:13:49.569 E/DisplayManager( 1465): at android.os.BinderProxy.transactNative(Native Method)01-18 09:13:49.569 E/DisplayManager( 1465): at android.os.BinderProxy.transact(Binder.java:503)01-18 09:13:49.569 E/DisplayManager( 1465): at android.hardware.display.IDisplayManager$Stub$Proxy.getDisplayInfo(IDisplayManager.java:273)01-18 09:13:49.569 E/DisplayManager( 1465): at android.hardware.display.DisplayManagerGlobal.getDisplayInfo(DisplayManagerGlobal.java:119)01-18 09:13:49.569 E/DisplayManager( 1465): at android.hardware.display.DisplayManagerGlobal.getCompatibleDisplay(DisplayManagerGlobal.java:178)01-18 09:13:49.569 E/DisplayManager( 1465): at android.hardware.display.DisplayManager.getOrCreateDisplayLocked(DisplayManager.java:326)01-18 09:13:49.569 E/DisplayManager( 1465): at android.hardware.display.DisplayManager.addPresentationDisplaysLocked(DisplayManager.java:314)01-18 09:13:49.569 E/DisplayManager( 1465): at android.hardware.display.DisplayManager.getDisplays(DisplayManager.java:293)01-18 09:13:49.569 E/DisplayManager( 1465): at android.media.MediaRouter$Static.getAllPresentationDisplays(MediaRouter.java:320)01-18 09:13:49.569 E/DisplayManager( 1465): at android.media.MediaRouter$RouteInfo.choosePresentationDisplay(MediaRouter.java:1868)01-18 09:13:49.569 E/DisplayManager( 1465): at android.media.MediaRouter$RouteInfo.updatePresentationDisplay(MediaRouter.java:1858)01-18 09:13:49.569 E/DisplayManager( 1465): at android.media.MediaRouter$Static.startMonitoringRoutes(MediaRouter.java:140)01-18 09:13:49.569 E/DisplayManager( 1465): at android.media.MediaRouter.&lt;init&gt;(MediaRouter.java:720)01-18 09:13:49.569 E/DisplayManager( 1465): at android.app.SystemServiceRegistry$7.createService(SystemServiceRegistry.java:193)01-18 09:13:49.569 E/DisplayManager( 1465): at android.app.SystemServiceRegistry$7.createService(SystemServiceRegistry.java:192)01-18 09:13:49.569 E/DisplayManager( 1465): at android.app.SystemServiceRegistry$CachedServiceFetcher.getService(SystemServiceRegistry.java:790)01-18 09:13:49.569 E/DisplayManager( 1465): at android.app.SystemServiceRegistry.getSystemService(SystemServiceRegistry.java:743)01-18 09:13:49.569 E/DisplayManager( 1465): at android.app.ContextImpl.getSystemService(ContextImpl.java:1365)01-18 09:13:49.569 E/DisplayManager( 1465): at android.content.ContextWrapper.getSystemService(ContextWrapper.java:627)01-18 09:13:49.569 E/DisplayManager( 1465): at com.android.keyguard.KeyguardDisplayManager.&lt;init&gt;(KeyguardDisplayManager.java:41)01-18 09:13:49.569 E/DisplayManager( 1465): at com.android.systemui.keyguard.KeyguardViewMediator.setupLocked(KeyguardViewMediator.java:561)01-18 09:13:49.569 E/DisplayManager( 1465): at com.android.systemui.keyguard.KeyguardViewMediator.start(KeyguardViewMediator.java:616)01-18 09:13:49.569 E/DisplayManager( 1465): at com.android.systemui.SystemUIApplication.startServicesIfNeeded(SystemUIApplication.java:139)01-18 09:13:49.569 E/DisplayManager( 1465): at com.android.systemui.SystemUIService.onCreate(SystemUIService.java:31)01-18 09:13:49.569 E/DisplayManager( 1465): at android.app.ActivityThread.handleCreateService(ActivityThread.java:2883)01-18 09:13:49.569 E/DisplayManager( 1465): at android.app.ActivityThread.-wrap4(ActivityThread.java)01-18 09:13:49.569 E/DisplayManager( 1465): at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1430)01-18 09:13:49.569 E/DisplayManager( 1465): at android.os.Handler.dispatchMessage(Handler.java:102)01-18 09:13:49.569 E/DisplayManager( 1465): at android.os.Looper.loop(Looper.java:148)01-18 09:13:49.569 E/DisplayManager( 1465): at android.app.ActivityThread.main(ActivityThread.java:5426)01-18 09:13:49.569 E/DisplayManager( 1465): at java.lang.reflect.Method.invoke(Native Method)01-18 09:13:49.569 E/DisplayManager( 1465): at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:772)01-18 09:13:49.569 E/DisplayManager( 1465): at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:662)01-18 09:13:49.570 E/DisplayManager( 1465): Failed to get Wifi display status.01-18 09:13:49.570 E/DisplayManager( 1465): android.os.DeadObjectException01-18 09:13:49.570 E/DisplayManager( 1465): at android.os.BinderProxy.transactNative(Native Method)01-18 09:13:49.570 E/DisplayManager( 1465): at android.os.BinderProxy.transact(Binder.java:503)01-18 09:13:49.570 E/DisplayManager( 1465): at android.hardware.display.IDisplayManager$Stub$Proxy.getWifiDisplayStatus(IDisplayManager.java:462)01-18 09:13:49.570 E/DisplayManager( 1465): at android.hardware.display.DisplayManagerGlobal.getWifiDisplayStatus(DisplayManagerGlobal.java:355)01-18 09:13:49.570 E/DisplayManager( 1465): at android.hardware.display.DisplayManager.getWifiDisplayStatus(DisplayManager.java:469)01-18 09:13:49.570 E/DisplayManager( 1465): at android.media.MediaRouter$Static.startMonitoringRoutes(MediaRouter.java:144)01-18 09:13:49.570 E/DisplayManager( 1465): at android.media.MediaRouter.&lt;init&gt;(MediaRouter.java:720)01-18 09:13:49.570 E/DisplayManager( 1465): at android.app.SystemServiceRegistry$7.createService(SystemServiceRegistry.java:193)01-18 09:13:49.570 E/DisplayManager( 1465): at android.app.SystemServiceRegistry$7.createService(SystemServiceRegistry.java:192)01-18 09:13:49.570 E/DisplayManager( 1465): at android.app.SystemServiceRegistry$CachedServiceFetcher.getService(SystemServiceRegistry.java:790)01-18 09:13:49.570 E/DisplayManager( 1465): at android.app.SystemServiceRegistry.getSystemService(SystemServiceRegistry.java:743)01-18 09:13:49.570 E/DisplayManager( 1465): at android.app.ContextImpl.getSystemService(ContextImpl.java:1365)01-18 09:13:49.570 E/DisplayManager( 1465): at android.content.ContextWrapper.getSystemService(ContextWrapper.java:627)01-18 09:13:49.570 E/DisplayManager( 1465): at com.android.keyguard.KeyguardDisplayManager.&lt;init&gt;(KeyguardDisplayManager.java:41)01-18 09:13:49.570 E/DisplayManager( 1465): at com.android.systemui.keyguard.KeyguardViewMediator.setupLocked(KeyguardViewMediator.java:561)01-18 09:13:49.570 E/DisplayManager( 1465): at com.android.systemui.keyguard.KeyguardViewMediator.start(KeyguardViewMediator.java:616)01-18 09:13:49.570 E/DisplayManager( 1465): at com.android.systemui.SystemUIApplication.startServicesIfNeeded(SystemUIApplication.java:139)01-18 09:13:49.570 E/DisplayManager( 1465): at com.android.systemui.SystemUIService.onCreate(SystemUIService.java:31)01-18 09:13:49.570 E/DisplayManager( 1465): at android.app.ActivityThread.handleCreateService(ActivityThread.java:2883)01-18 09:13:49.570 E/DisplayManager( 1465): at android.app.ActivityThread.-wrap4(ActivityThread.java)01-18 09:13:49.570 E/DisplayManager( 1465): at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1430)01-18 09:13:49.570 E/DisplayManager( 1465): at android.os.Handler.dispatchMessage(Handler.java:102)01-18 09:13:49.570 E/DisplayManager( 1465): at android.os.Looper.loop(Looper.java:148)01-18 09:13:49.570 E/DisplayManager( 1465): at android.app.ActivityThread.main(ActivityThread.java:5426)01-18 09:13:49.570 E/DisplayManager( 1465): at java.lang.reflect.Method.invoke(Native Method)01-18 09:13:49.570 E/DisplayManager( 1465): at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:772)01-18 09:13:49.570 E/DisplayManager( 1465): at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:662)01-18 09:13:49.574 D/AndroidRuntime( 1465): Shutting down VM--------- beginning of crash01-18 09:13:49.575 E/AndroidRuntime( 1465): FATAL EXCEPTION: main01-18 09:13:49.575 E/AndroidRuntime( 1465): Process: com.android.systemui, PID: 146501-18 09:13:49.575 E/AndroidRuntime( 1465): java.lang.RuntimeException: Unable to create service com.android.systemui.SystemUIService: java.lang.NullPointerException: Attempt to invoke interface method &apos;android.media.AudioRoutesInfo android.media.IAudioService.startWatchingRoutes(android.media.IAudioRoutesObserver)&apos; on a null object reference01-18 09:13:49.575 E/AndroidRuntime( 1465): at android.app.ActivityThread.handleCreateService(ActivityThread.java:2893)01-18 09:13:49.575 E/AndroidRuntime( 1465): at android.app.ActivityThread.-wrap4(ActivityThread.java)01-18 09:13:49.575 E/AndroidRuntime( 1465): at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1430)01-18 09:13:49.575 E/AndroidRuntime( 1465): at android.os.Handler.dispatchMessage(Handler.java:102)01-18 09:13:49.575 E/AndroidRuntime( 1465): at android.os.Looper.loop(Looper.java:148)01-18 09:13:49.575 E/AndroidRuntime( 1465): at android.app.ActivityThread.main(ActivityThread.java:5426)01-18 09:13:49.575 E/AndroidRuntime( 1465): at java.lang.reflect.Method.invoke(Native Method)01-18 09:13:49.575 E/AndroidRuntime( 1465): at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:772)01-18 09:13:49.575 E/AndroidRuntime( 1465): at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:662)01-18 09:13:49.575 E/AndroidRuntime( 1465): Caused by: java.lang.NullPointerException: Attempt to invoke interface method &apos;android.media.AudioRoutesInfo android.media.IAudioService.startWatchingRoutes(android.media.IAudioRoutesObserver)&apos; on a null object reference01-18 09:13:49.575 E/AndroidRuntime( 1465): at android.media.MediaRouter$Static.startMonitoringRoutes(MediaRouter.java:155)01-18 09:13:49.575 E/AndroidRuntime( 1465): at android.media.MediaRouter.&lt;init&gt;(MediaRouter.java:720)01-18 09:13:49.575 E/AndroidRuntime( 1465): at android.app.SystemServiceRegistry$7.createService(SystemServiceRegistry.java:193)01-18 09:13:49.575 E/AndroidRuntime( 1465): at android.app.SystemServiceRegistry$7.createService(SystemServiceRegistry.java:192)01-18 09:13:49.575 E/AndroidRuntime( 1465): at android.app.SystemServiceRegistry$CachedServiceFetcher.getService(SystemServiceRegistry.java:790)01-18 09:13:49.575 E/AndroidRuntime( 1465): at android.app.SystemServiceRegistry.getSystemService(SystemServiceRegistry.java:743)01-18 09:13:49.575 E/AndroidRuntime( 1465): at android.app.ContextImpl.getSystemService(ContextImpl.java:1365)01-18 09:13:49.575 E/AndroidRuntime( 1465): at android.content.ContextWrapper.getSystemService(ContextWrapper.java:627)01-18 09:13:49.575 E/AndroidRuntime( 1465): at com.android.keyguard.KeyguardDisplayManager.&lt;init&gt;(KeyguardDisplayManager.java:41)01-18 09:13:49.575 E/AndroidRuntime( 1465): at com.android.systemui.keyguard.KeyguardViewMediator.setupLocked(KeyguardViewMediator.java:561)01-18 09:13:49.575 E/AndroidRuntime( 1465): at com.android.systemui.keyguard.KeyguardViewMediator.start(KeyguardViewMediator.java:616)01-18 09:13:49.575 E/AndroidRuntime( 1465): at com.android.systemui.SystemUIApplication.startServicesIfNeeded(SystemUIApplication.java:139)01-18 09:13:49.575 E/AndroidRuntime( 1465): at com.android.systemui.SystemUIService.onCreate(SystemUIService.java:31)01-18 09:13:49.575 E/AndroidRuntime( 1465): at android.app.ActivityThread.handleCreateService(ActivityThread.java:2883)01-18 09:13:49.575 E/AndroidRuntime( 1465): ... 8 more01-18 09:13:49.576 E/AndroidRuntime( 1465): Error reporting crash01-18 09:13:49.576 E/AndroidRuntime( 1465): android.os.DeadObjectException01-18 09:13:49.576 E/AndroidRuntime( 1465): at android.os.BinderProxy.transactNative(Native Method)01-18 09:13:49.576 E/AndroidRuntime( 1465): at android.os.BinderProxy.transact(Binder.java:503)01-18 09:13:49.576 E/AndroidRuntime( 1465): at android.app.ActivityManagerProxy.handleApplicationCrash(ActivityManagerNative.java:4440)01-18 09:13:49.576 E/AndroidRuntime( 1465): at com.android.internal.os.RuntimeInit$UncaughtHandler.uncaughtException(RuntimeInit.java:90)01-18 09:13:49.576 E/AndroidRuntime( 1465): at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:693)01-18 09:13:49.576 E/AndroidRuntime( 1465): at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:690) 解决方法Vop 的问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950--- a/arch/arm64/boot/dts/rockchip/rk3399-sapphire-excavator-edp.dts+++ b/arch/arm64/boot/dts/rockchip/rk3399-sapphire-excavator-edp.dts@@ -78,7 +78,7 @@ &amp;hdmi_rk_fb &#123; status = &quot;okay&quot;;- rockchip,hdmi_video_source = &lt;DISPLAY_SOURCE_LCDC1&gt;;+ rockchip,hdmi_video_source = &lt;DISPLAY_SOURCE_LCDC0&gt;; &#125;; &amp;hdmi_sound &#123;@@ -227,8 +227,12 @@ #include &lt;dt-bindings/display/screen-timing/lcd-F402.dtsi&gt; &#125;; -&amp;vopb_rk_fb &#123;+&amp;vopl_rk_fb &#123; status = &quot;okay&quot;;+ rockchip,prop = &lt;PRMRY&gt;;+ assigned-clocks = &lt;&amp;cru DCLK_VOP1_DIV&gt;;+ assigned-clock-parents = &lt;&amp;cru PLL_CPLL&gt;;+ power_ctr: power_ctr &#123; rockchip,debug = &lt;0&gt;; lcd_en: lcd-en &#123;@@ -253,6 +257,9 @@ &#125;; &#125;; -&amp;vopl_rk_fb &#123;+&amp;vopb_rk_fb &#123; status = &quot;okay&quot;;+ rockchip,prop = &lt;EXTEND&gt;;+ assigned-clocks = &lt;&amp;cru DCLK_VOP0_DIV&gt;;+ assigned-clock-parents = &lt;&amp;cru PLL_NPLL&gt;; &#125;;diff --git a/include/dt-bindings/clock/rk3399-cru.h b/include/dt-bindings/clock/rk3399-cru.hindex 0fc9e7a..d32ce01 100644--- a/include/dt-bindings/clock/rk3399-cru.h+++ b/include/dt-bindings/clock/rk3399-cru.h@@ -16,7 +16,7 @@ #ifndef _DT_BINDINGS_CLK_ROCKCHIP_RK3399_H #define _DT_BINDINGS_CLK_ROCKCHIP_RK3399_H -/* #define RK3399_TWO_PLL_FOR_VOP */+#define RK3399_TWO_PLL_FOR_VOP /* core clocks */ #define PLL_APLLL 1 1234567891011121314151617181920diff --git a/include/configs/rk33plat.h b/include/configs/rk33plat.hindex 1d52381..6aab13a 100755--- a/include/configs/rk33plat.h+++ b/include/configs/rk33plat.h@@ -319,7 +319,6 @@ #define CONFIG_ROCKCHIP_DW_MIPI_DSI #define CONFIG_ROCKCHIP_ANALOGIX_DP #define CONFIG_ROCKCHIP_DW_HDMI-#define CONFIG_RK_HDMI #endif #if defined(CONFIG_RKCHIP_RK3368)@@ -351,7 +350,7 @@ #endif /* CONFIG_LCD */ -+#define CONFIG_RK_VOP_DUAL_ANY_FREQ_PLL /* more config for charge */ #ifdef CONFIG_UBOOT_CHARGE","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android6.0 RK3399 开机前几秒串口打印异常问题","slug":"Android_Driver/Debug/[Android6.0][RK3399] 开机前几秒串口打印异常问题","date":"2017-07-01T15:33:05.000Z","updated":"2018-11-08T02:51:14.718Z","comments":true,"path":"2017/07/01/Android_Driver/Debug/[Android6.0][RK3399] 开机前几秒串口打印异常问题/","link":"","permalink":"http://iyounix.com/2017/07/01/Android_Driver/Debug/[Android6.0][RK3399] 开机前几秒串口打印异常问题/","excerpt":"","text":"问题现象开机 0-3 s 串口打印异常，log 大致如下： 123456 CPLWC�+lH�ؐL)�������ꁳ�ݵ��&#125;�ɽ����������\u001f����r���͑�����j郵���\u0002rŽ��Ց����͕͕͑͑́\u0002 с���ɕ��́�Â��j��\u0002\u0002\u0002�r�ʺ���¢��oꁵ������\u0002j������������\u0002�:�UŠ���r��\u0002:¥�jR� [ 1.973752] resource: 0x000c00000 -- 0x001c00000 (16 MB)[ 1.973761] kernel: 0x001c00000 -- 0x002c00000 (16 MB)[ 1.973769] boot: 0x002c00000 -- 0x004c00000 (32 MB)[ 1.973777] recovery: 0x004c00000 -- 0x006c00000 (32 MB) 调试步骤抓取串口波形在 0-3s 串口波形异常。 检查上电 APIO4 = 3.0VPMUIO2 = 3.0V 参考 rk 文档kernel/Documentation/devicetree/bindings/power/rockchip-io-domain.txt设置方法如下：12345678Possible supplies for rk3399:- bt656-supply: The supply connected to APIO2_VDD.- audio-supply: The supply connected to APIO5_VDD.- sdmmc-supply: The supply connected to SDMMC0_VDD.- gpio1830 The supply connected to APIO4_VDD.Possible supplies for rk3399 pmu-domains:- pmu1830-supply:The supply connected to PMUIO2_VDD. 检查 dts 中的设置为 1234567891011121314&amp;io_domains &#123; status = &quot;okay&quot;; bt656-supply = &lt;&amp;vcc_3v0&gt;; /* bt656_gpio2ab_ms */ audio-supply = &lt;&amp;vcca1v8_codec&gt;; /* audio_gpio3d4a_ms */ sdmmc-supply = &lt;&amp;vcc_sd&gt;; /* sdmmc_gpio4b_ms */ gpio1830-supply = &lt;&amp;vcc_3v0&gt;; /* gpio1833_gpio4cd_ms */&#125;;&amp;pmu_io_domains &#123; status = &quot;okay&quot;; pmu1830-supply = &lt;&amp;vcc_3v0&gt;;&#125;; 正确无误。 获取 kernel 起来后实际配置的 pmu io 电压12root@rk3399_mid:/ # io -4 -r 0xFF320180ff320180: 00000100 所以实际起作用是 3v，没问题。 获取开机阶段实际配置的 pmu io 电压获取 uboot 阶段中寄存器的配置可以这样做，在如下地方添加打印12345678void __iomem *base_addr;unsigned long p_addr = 0x????????;unsigned long size = 0x??;base_addr = ioremap(p_addr , size );printk(&quot;lml#####: gpio0_A0&apos;s direction = 0x%x&quot;, readl(base_addr));iounmap(base_addr); 但是我们串口有问题啊！添加了打印也看不到任何信息。 没辙！ 检查 PMUIO2 power domain 部分电压是否正常 既然为 3.0V 需要上拉电阻来进行驱动强度选择。 所以这个 R90029 应该贴了才行。但是实际没贴。 贴上后串口打印正常。问题解决。","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"OpenGL 创建一个窗口","slug":"VR/OpenGL/[OpenGL]创建一个窗口","date":"2017-06-06T15:01:05.000Z","updated":"2018-11-08T01:59:30.148Z","comments":true,"path":"2017/06/06/VR/OpenGL/[OpenGL]创建一个窗口/","link":"","permalink":"http://iyounix.com/2017/06/06/VR/OpenGL/[OpenGL]创建一个窗口/","excerpt":"","text":"代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//GLEW 的库#include &lt;GL/glew.h&gt; //GLFW 的库，处理窗口和键盘的消息#include &lt;glfw3.h&gt; GLFWwindow* window;////三维数学的库#include &lt;glm/glm.hpp&gt; using namespace glm;int main( void )&#123; //初始化 GLFW if( !glfwInit() ) &#123; fprintf( stderr, \"Failed to initialize GLFW\\n\" ); getchar(); return -1; &#125; //设置一些 hint //glfwWindowHint(int hint, int mode); glfwWindowHint(GLFW_SAMPLES, 4); glfwWindowHint(GLFW_RESIZABLE,GL_FALSE); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); //set Vision to 3.3 glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // To make MacOS happy; should not be needed glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // Open a window and create its OpenGL context window = glfwCreateWindow( 1024, 768, \"HelloWorld\", NULL, NULL); if( window == NULL )&#123; fprintf( stderr, \"Failed to open GLFW window. If you have an Intel GPU, they are not 3.3 compatible. Try the 2.1 version of the tutorials.\\n\" ); getchar(); glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); // Initialize GLEW if (glewInit() != GLEW_OK) &#123; fprintf(stderr, \"Failed to initialize GLEW\\n\"); getchar(); glfwTerminate(); //destory all remain return -1; &#125; // Ensure we can capture the escape key being pressed below // 确保当某些键按下的时候，后面 glfwGetKey 可以获得 GLFW_PRESS glfwSetInputMode(window, GLFW_STICKY_KEYS, GL_TRUE); // Dark blue background // glClearColor(0.0f, 0.0f, 0.4f, 0.0f); // glClearColor(Red, Green, Blue, 0.0f); // 为色彩缓冲区指定用于清除的值 glClearColor(0.0f, 0.0f, 0.0f, 0.0f); do&#123; //执行清除色彩缓冲区的任务 glClear( GL_COLOR_BUFFER_BIT ); // Swap buffers glfwSwapBuffers(window); glfwPollEvents(); &#125; // Check if the ESC key was pressed or the window was closed while( glfwGetKey(window, GLFW_KEY_ESCAPE ) != GLFW_PRESS &amp;&amp; glfwWindowShouldClose(window) == 0 ); // Close OpenGL window and terminate GLFW glfwTerminate(); return 0;&#125; API 分析glfwSetInputMode设置特定窗口的输入模式1void glfwSetInputMode ( GLFWwindow * window, int mode, int value ) mode 可以为 GLFW_CURSOR, GLFW_STICKY_KEYS or GLFW_STICKY_MOUSE_BUTTONS.当 mode = GLFW_CURSORvalue 为GLFW_CURSOR_NORMAL makes the cursor visible and behaving normally. 让光标可见，且正常GLFW_CURSOR_HIDDEN makes the cursor invisible when it is over the client area of the window but does not restrict the cursor from leaving. 当光标到窗口区域的时候，光标隐藏GLFW_CURSOR_DISABLED hides and grabs the cursor, providing virtual and unlimited cursor movement. This is useful for implementing for example 3D camera controls. 强行夺取光标，光标消失当 mode = GLFW_STICKY_KEYSvalue 为GLFW_TRUE 使能粘滞键。确保按键将会使 glfwGetKey returns GLFW_PRESS。它常常被用在你只关注键是否被按下，而不关注键什么时候按下或者以什么顺序按下时。GLFW_FALSE 禁能粘滞键。当 mode = GLFW_STICKY_MOUSE_BUTTONSvalue 为GLFW_TRUE 使能鼠标粘滞键。确保鼠标按钮将会使 glfwGetMouseButton returns GLFW_PRESS。GLFW_FALSE 禁能鼠标粘滞键。 glClearColor &amp; glClear1void glClearColor(GLclampf red,GLclampf green,GLclampf blue,GLclampf alpha) 设置颜色缓冲区颜色为（红，绿，蓝，透明）1void glClear(GLbitfield mask); 执行清理命令GLbitfield mask：可以使用 | 运算符组合不同的缓冲标志位，表明需要清除的缓冲GL_COLOR_BUFFER_BIT: 当前可写的颜色缓冲 glClearColorGL_DEPTH_BUFFER_BIT: 深度缓冲 glClearDepthGL_ACCUM_BUFFER_BIT: 累积缓冲 glClearAccumGL_STENCIL_BUFFER_BIT: 模板缓冲 glClearStencil glfwSwapBuffers &amp; glfwPollEventsglfwSwapBuffersThis function swaps the front and back buffers of the specified window when rendering with OpenGL or OpenGL ES. 交换前后端缓冲区？不懂——&gt;[OpenGL中的缓冲区] OpenGL 在绘制图元时，先是在一个缓冲区中完成渲染，然后再把渲染结果交换到屏幕上。我们把这两个缓冲区称为前颜色缓冲区（屏幕）和后颜色缓冲区。glfwPollEventsThis function processes only those events that are already in the event queue and then returns immediately. Processing events will cause the window and input callbacks associated with those events to be called.作用是 Processes all pending events. glfwGetKey1int glfwGetKey（GLFWwindow * window, int key ) 返回上一次特定窗口中某个按键的状态（按下GLFW_PRESS 或者 释放GLFW_RELEASE）12while( glfwGetKey(window, GLFW_KEY_ESCAPE ) != GLFW_PRESS &amp;&amp; glfwWindowShouldClose(window) == 0 ); 获取 windows 窗口 ESC 键的状态 如果没有按下返回 GLFW_RELEASE 不会进入 &amp;&amp; 后面的判断 如果有被按下返回 GLFW_PRESS 就进入后面的判断 执行 glfwWindowShouldClose 指令，返回 close flag 0 &amp;&amp; 0 ，跳出 while 循环 参考glfw 若干函数列表：http://blog.csdn.net/ccsdu2004/article/details/3838184OpenGL 中的缓冲区：http://blog.csdn.net/Haohan_Meng/article/details/25246519","categories":[],"tags":[{"name":"VR","slug":"VR","permalink":"http://iyounix.com/tags/VR/"}]},{"title":"OpenGL 创建一个三角形","slug":"VR/OpenGL/[OpenGL]创建一个三角形","date":"2017-06-06T15:01:05.000Z","updated":"2018-11-08T02:00:50.510Z","comments":true,"path":"2017/06/06/VR/OpenGL/[OpenGL]创建一个三角形/","link":"","permalink":"http://iyounix.com/2017/06/06/VR/OpenGL/[OpenGL]创建一个三角形/","excerpt":"","text":"Platform: Ubuntu16.04IDE: QT5Tools: OpenGL3 [TOC] 代码tutorial02_red_triangle123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135// Include standard headers#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;// Include GLEW#include &lt;GL/glew.h&gt;// Include GLFW#include &lt;glfw3.h&gt;GLFWwindow* window;// Include GLM#include &lt;glm/glm.hpp&gt;using namespace glm;#include &lt;common/shader.hpp&gt;int main( void )&#123; // Initialise GLFW if( !glfwInit() ) &#123; fprintf( stderr, \"Failed to initialize GLFW\\n\" ); getchar(); return -1; &#125; glfwWindowHint(GLFW_SAMPLES, 4); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // To make MacOS happy; should not be needed glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // Open a window and create its OpenGL context window = glfwCreateWindow( 1024, 768, \"Tutorial 02 - Red triangle\", NULL, NULL); if( window == NULL )&#123; fprintf( stderr, \"Failed to open GLFW window. If you have an Intel GPU, they are not 3.3 compatible. Try the 2.1 version of the tutorials.\\n\" ); getchar(); glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); // Initialize GLEW glewExperimental = true; // Needed for core profile if (glewInit() != GLEW_OK) &#123; fprintf(stderr, \"Failed to initialize GLEW\\n\"); getchar(); glfwTerminate(); return -1; &#125; // Ensure we can capture the escape key being pressed below glfwSetInputMode(window, GLFW_STICKY_KEYS, GL_TRUE); // Dark blue background glClearColor(0.0f, 0.0f, 0.4f, 0.0f); //1. 生成顶点数组 VAO GLuint VertexArrayID; glGenVertexArrays(1, &amp;VertexArrayID); //2. 绑定 VAO glBindVertexArray(VertexArrayID); // Create and compile our GLSL program from the shaders GLuint programID = LoadShaders( \"SimpleVertexShader.vertexshader\", \"SimpleFragmentShader.fragmentshader\" ); // 三角形三个顶点的坐标(-1,-1,0),(1,-1,0),(0,1,0) static const GLfloat g_vertex_buffer_data[] = &#123; -1.0f, -1.0f, 0.0f, 1.0f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f, &#125;; //3. 产生缓冲区对象 VBOs GLuint vertexbuffer; glGenBuffers(1, &amp;vertexbuffer); //4. 激活（绑定）缓冲区对象 glBindBuffer(GL_ARRAY_BUFFER, vertexbuffer); //5. 用数据分配和初始化缓冲区对象 //void glBufferData(GLenum target, 是GL_ARRAY_BUFFER()（顶点数据）或GL_ELEMENT_ARRAY_BUFFER(索引数据) // GLsizeiptr size 缓冲区对象字节数, // const GLvoid * data用于拷贝缓冲区对象数据的指针, // GLenum usage); glBufferData(GL_ARRAY_BUFFER, sizeof(g_vertex_buffer_data), g_vertex_buffer_data, GL_STATIC_DRAW); // 设置清除颜色为 蓝色 glClearColor(0.0f, 0.5f, 0.5f, 0.0f); do&#123; // 执行清除任务 glClear( GL_COLOR_BUFFER_BIT ); // Use our shader glUseProgram(programID); // 1rst attribute buffer : vertices //6. 定义存放顶点数据的数组 //void glEnableVertexAttribArray( GLuint index); //index：指定了需要启用的顶点属性数组的索引 glEnableVertexAttribArray(0); // ？？又绑定一次？ glBindBuffer(GL_ARRAY_BUFFER, vertexbuffer); // 给对应的顶点属性数组指定数据 glVertexAttribPointer( 0, // attribute 0. No particular reason for 0, but must match the layout in the shader. 3, // size GL_FLOAT, // type GL_FALSE, // normalized? 0, // stride (void*)0 // array buffer offset ); // Draw the triangle ! glDrawArrays(GL_TRIANGLES, 0, 3); // 3 indices starting at 0 -&gt; 1 triangle glDisableVertexAttribArray(0); // Swap buffers glfwSwapBuffers(window); glfwPollEvents(); &#125; // Check if the ESC key was pressed or the window was closed while( glfwGetKey(window, GLFW_KEY_ESCAPE ) != GLFW_PRESS &amp;&amp; glfwWindowShouldClose(window) == 0 ); // Cleanup VBO glDeleteBuffers(1, &amp;vertexbuffer); glDeleteVertexArrays(1, &amp;VertexArrayID); glDeleteProgram(programID); // Close OpenGL window and terminate GLFW glfwTerminate(); return 0;&#125; fragmentshader123456789101112#version 330 core// Ouput dataout vec3 color;void main()&#123; // Output color = red color = vec3(1,0,0);&#125; vertexshader1234567891011#version 330 core// Input vertex data, different for all executions of this shader.layout(location = 0) in vec3 vertexPosition_modelspace;void main()&#123; gl_Position.xyz = vertexPosition_modelspace; gl_Position.w = 1.0;&#125; API 分析顶点数组对象 VAOVAO，是这样一种方式：把对象信息直接存储在图形卡中，而不是在当我们需要的时候传输到图形卡。使用方法123456// 顶点数组对象 VertexArrayIDGLuint VertexArrayID;// 产生 VAO （数量，存放产生 VAO 对象的名称）void glGenVertexArrays(GLsizei n, GLuint *arrays);// 绑定 VAO（要绑定的顶点数组的名字）void glBindVertexArray(GLuint array); 这个必须在任何其他OpenGL调用前完成。 屏幕坐标系右手定则：面对电脑，指向右边是 X，指向上边是 Y，指向背后是 Z。 Bug 集锦Error：The program has unexpectedly finished.现象：程序中已经正确包含glew相关的头文件和库文件，glew也已经通过glewInit()正确初始化，程序运行到glGenVertexArrays处时仍然出现运行时错误：.exe（某opengl可执行程序）中的0x**（某内存地址） 处有未处理的异常： Ox**: Access violation解决方案： 在glewInit()之前加上glewExperimental = true;Reason:GLEW obtains information on the supported extensions from the graphics driver. Experimental or pre-release drivers, however, might not report every available extension through the standard mechanism, in which case GLEW will report it unsupported. To circumvent this situation, the glewExperimental global switch can be turned on by setting it to GL_TRUE before calling glewInit(), which ensures that all extensions with valid entry points will be exposed. ### 参考VBO，VAO 介绍：http://blog.csdn.net/xiajun07061225/article/details/7628146","categories":[],"tags":[{"name":"VR","slug":"VR","permalink":"http://iyounix.com/tags/VR/"}]},{"title":"OpenGL 一些基本概念和基于状态的方法","slug":"VR/OpenGL/[OpenGL]一些基本概念和基于状态的方法","date":"2017-06-06T15:01:05.000Z","updated":"2018-11-08T02:00:05.133Z","comments":true,"path":"2017/06/06/VR/OpenGL/[OpenGL]一些基本概念和基于状态的方法/","link":"","permalink":"http://iyounix.com/2017/06/06/VR/OpenGL/[OpenGL]一些基本概念和基于状态的方法/","excerpt":"","text":"Platform: Ubuntu16.04IDE: QT5Tools: OpenGL3 [TOC] 前言——基于状态在写 OpenGL 的 “Hello World” （三角形） 的时候，非常困扰！gen、bind、active、 都不知道自己是在干什么。后来查到 OpenGL 和 C++、C# 等面向对象的语言不通，OpenGL 大多数函数使用的是 基于状态 的方法。 即 大多数OpenGL对象都需要在使用前把该对象绑定到context上。 Context顾名思义，就好像一篇文章的上下文上下文。可以把它理解成 包含了所有 OpenGL 状态的对象。 OpenGL 对象可以把 OpenGL对象 理解成一个状态的集合。（其实还包括其他的数据，但是我们这里只关注状态）但是 OpenGL对象 的状态 和 Context 的状态并不重合， 只有当 OpenGL对象 绑定（bind）到 context 上时，OpenGL对象 的状态才会映射到 Context 的状态。绑定（bind）后，如果我们改变 Context 状态，这个 OpenGL对象 也会被影响。绑定（bind）后，这些依赖 Context 状态的函数，也将会使用存储在这个 OpenGL对象 上的数据。 OpenGL 对象包含以下一些类型：Buffer Objects，Vertex Array Objects，Textures，Framebuffer Objects等等。我们等下会讲到Vertex Array Objects这个对象。 这些对象有三个重要的函数： 12345void glGen*(GLsizei n, GLuint *objects); //负责生成一个对象的name。而name就是这个对象的引用。void glDelete*(GLsizei n, const GLuint *objects); //负责销毁一个对象。void glBind*(GLenum target, GLuint object); //将对象绑定到context上。 图形名词像素（pixel）像素是我们显示器上的最小可见元素。我们系统中的像素被存储在一个帧缓存（framebuffer）中。帧缓存是一块由图形硬件管理的内存空间，用于供给给我们的显示设备。 模型（Models）/ 对象（Objects）这里两者的含义是一样的。指从几何图元——点、线、三角形中创建的东西，由顶点指定。 渲染（Rendering）计算机从模型到创建一张图像的过程。OpenGL仅仅是其中一个渲染系统。它是一个基于光栅化的系统，其他的系统还有光线追踪（但有时也会用到OpenGL）等。 Shaders这是一类特殊的函数，是在图形硬件（GPU）上执行的。我们可以理解成，Shader是一些为图形处理单元（GPU）编译的小程序。OpenGL包含了编译工具来把我们编写的 Shader 源代码编译成可以在GPU上运行的代码。在 OpenGL 中，我们可以使用四种shader阶段。最常见的就是 vertex shaders——它们可以处理顶点数据；以及fragment shaders，它们处理光栅化后生成的fragments。vertex shaders 和 fragment shaders是每个OpenGL程序必不可少的部分。 OpenGL 的命名规范OpenGL里面的函数长得都有一个特点，都是由“gl”开头的，然后紧跟一个或多个大写字母（例如，glBindVertexArray()）。而且所有的OpenGL函数都长这样。 在程序里面还有一些函数是“glut”开头的，这是来自OpenGL实用工具（OpenGL Utility Toolkit）——GLUT。这是一个非常流行的跨平台工具，可以用于打开窗口、管理输入等操作。同样，还有一个函数，glewInit()，它来自GLEW库。GLUT和GLEW就是龙书所用的两个库了。 和OpenGL函数的命名规范类似，在display()函数里见到的GL_COLOR_BUFFER_BIT这样的常量，也是OpenGL定义的。它们由GL_开头，实用下划线来分割字符。它们的定义就是通过OpenGL头文件（glcorearb.h和glewt.h）里面的#define指令定义的。 OpenGL为了跨平台还自己定义了一系列数据类型，如GLfloat。而且，因为OpenGL是一个“C”语言库，它不使用函数重载来解决不同类型的数据问题，而是使用函数命名规范来组织不同的函数。例如，后面我们会碰到一个函数叫glUniform*()，这个函数有很多形式，例如，glUniform2f()和glUniform3fv。这些函数名字后面的后缀——2f和3fv，提供了函数的参数信息。例如，2f中的2表示有两个数据将会传递给函数，f表示这两个参数的类型是GLfloat。而3fv中最后的v，则是vector的简写，表明这三个GLfloat将以vector的形式传递给函数，而不是三个独立的参数。 GL 中 顶点 是怎么传到 GLSL 的？答案是创建顶点流（Vertex Stream） 我们负责创建这个顶点流，然后只需要告诉OpenGL怎样解读它就可以了。为了渲染一个对象，我们必须使用一个shader program。而这个program会定义一系列顶点属性，例如上一篇文章中 Vertex Shader中的gl_Position 一行。这些属性决定了我们需要传递哪些顶点数据。每一个属性对应了一个数组，并且这些数据的维度都必须相等，即是一一对应的关系。 VAO 和 VBOOpenGL 使用 VAO 来实现上述管理顶点数据的作用，以及 VBO 来存放真正的顶点数据。","categories":[],"tags":[{"name":"VR","slug":"VR","permalink":"http://iyounix.com/tags/VR/"}]},{"title":"VR Cardboard Treasure Hunter 代码分析","slug":"VR/[VR] Cardboard Treasure Hunter 代码分析","date":"2017-06-05T15:01:05.000Z","updated":"2018-11-08T02:01:33.258Z","comments":true,"path":"2017/06/05/VR/[VR] Cardboard Treasure Hunter 代码分析/","link":"","permalink":"http://iyounix.com/2017/06/05/VR/[VR] Cardboard Treasure Hunter 代码分析/","excerpt":"","text":"Manifest file1234567891011121314151617181920212223&lt;manifest ... &lt;uses-permission android:name=\"android.permission.NFC\" /&gt; &lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" /&gt; &lt;uses-permission android:name=\"android.permission.VIBRATE\" /&gt; ... &lt;uses-sdk android:minSdkVersion=\"19\" android:targetSdkVersion=\"23\"/&gt; &lt;uses-feature android:glEsVersion=\"0x00020000\" android:required=\"true\" /&gt; &lt;application ... &lt;activity android:name=\".MainActivity\" android:screenOrientation=\"landscape\"&gt; ... &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;category android:name=\"com.google.intent.category.CARDBOARD\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; Extend GvrActivityGvrActivity 是最基本的 activity，它提供了 Google VR 设备的简单集成。它暴露时间来和 VR 进行交互，并且处理创建 VR 渲染的一些细节。 GvrActivity 是沉浸模式（ immersive mode），系统 UI 被隐藏，内容将会占据整个屏幕。这是 VR app 的要求，因为只有 activity 全屏的情况下 GvrView 才会渲染。 MainActivity extends GvrActivity，implements GvrView.StereoRenderer。GvrView.StereoRenderer 这个接口是为渲染器设计的，它将会委托所有的立体渲染细节给视图。接口器应该简单的渲染一个视图，因为他们常常变换参数。所有的立体渲染和畸变校正细节都是从渲染器中抽象出来的，并由内部视图管理。 Define a GvrView所有用户接口元素都是用 View 实现的。Google VR SDK 提供了 GvrView，用来进行 VR 渲染。 123456&lt;com.google.vr.sdk.base.GvrView android:id=\"@+id/gvr_view\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:layout_alignParentTop=\"true\" android:layout_alignParentLeft=\"true\" /&gt; 主 activity 中的 onCreate() 里面来初始化。1234567891011121314151617/** * Sets the view to our GvrView and initializes the transformation matrices * we will use to render our scene. */@Overridepublic void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.common_ui); GvrView gvrView = (GvrView) findViewById(R.id.gvr_view); // Associate a GvrView.StereoRenderer with gvrView. gvrView.setRenderer(this); // Associate the gvrView with this activity. setGvrView(gvrView); // Initialize other objects here. ...&#125; Render View一旦你得到了 GvrView 并将它和 渲染器（Renderer） 关联，接下来将它与 activity 关联。Google VR 支持两种渲染器（Renderer），最快的方法还是采用 GvrView.StereoRenderer，它包括了以下方法 onNewFrame(), called every time that app renders. onDrawEye(), called for each eye with different eye parameters. 用法和 OpenGL 应用类似。 Implement onNewFrame在渲染单个眼睛之前，使用onNewFrame（）方法来对渲染逻辑进行编码。任何不特定于单个视图的 每帧操作 都应在此处发生。这是更新模型的好地方。在这个片段中，变量 mHeadView 包含头的位置。该值需要保存以供稍后使用，以判断用户是否正在查看宝藏:12345678910/** * Prepares OpenGL ES before we draw a frame. * @param headTransform The head transformation in the new frame. */@Overridepublic void onNewFrame(HeadTransform headTransform) &#123; ... headTransform.getHeadView(mHeadView, 0); ...&#125; Implement onDrawEyeonDrawEye（）接口来执行每眼配置。 下面的代码展示了如何获得 视图转化为矩阵、透视转换为矩阵。你要确保是低延迟。Eye 对象包括了 眼睛的变换和投影矩阵。12345678910111213141516171819202122232425/** * Draws a frame for an eye. * * @param eye The eye to render. Includes all required transformations. */@Overridepublic void onDrawEye(Eye eye) &#123; GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT); ... // Apply the eye transformation to the camera. Matrix.multiplyMM(mView, 0, eye.getEyeView(), 0, mCamera, 0); // Set the position of the light Matrix.multiplyMV(mLightPosInEyeSpace, 0, mView, 0, LIGHT_POS_IN_WORLD_SPACE, 0); // Build the ModelView and ModelViewProjection matrices // for calculating cube position and light. float[] perspective = eye.getPerspective(Z_NEAR, Z_FAR); Matrix.multiplyMM(mModelView, 0, mView, 0, mModelCube, 0); Matrix.multiplyMM(mModelViewProjection, 0, perspective, 0, mModelView, 0); drawCube(); // Draw the rest of the scene. ...&#125; 事件的顺序是 Treasure 进入 Eye 的区域 应用投影矩阵，这为指定的眼睛提供渲染场景。 Google VR SDK 自动应用畸变算法，来渲染最终的场景。 Rendering spatial audioonCreate（）方法初始化3D音频引擎。 GvrAudioEngine的构造函数中的第二个参数允许用户指定定义空间化保真度的渲染模式。12gvrAudioEngine = new GvrAudioEngine(this, GvrAudioEngine.RenderingMode.BINAURAL_HIGH_QUALITY); 要在用户暂停应用程序时禁用音频，并在恢复时再次启用，请分别在onPause（）和onResume（）函数调用gvrAudioEngine.pause（）;和gvrAudioEngine.resume（）。声音文件可在播放期间流式传输或在播放前预先载入内存。此预加载应在单独的线程上执行，以避免主线程的阻塞。12345678new Thread( new Runnable() &#123; @Override public void run() &#123; gvrAudioEngine.preloadSoundFile(SOUND_FILE); &#125; &#125;) .start(); 可以使用createSoundObject（）在任何时间创建，定位和播放声音对象。从相同的预加载声音文件可以创建任意数量的声音对象。如果声音没有预先加载，声音文件将在播放时从磁盘流出。1234567// Start spatial audio playback of SOUND_FILE at the model postion. The returned// sourceId handle allows for repositioning the sound object whenever the cube// position changes.sourceId = gvrAudioEngine.createSoundObject(SOUND_FILE);gvrAudioEngine.setSoundObjectPosition( sourceId, modelPosition[0], modelPosition[1], modelPosition[2]);gvrAudioEngine.playSound(sourceId, true /* looped playback */); sourceId句柄可用于在运行时重新定位声音。12345// Update the sound location to match it with the new cube position.if (sourceId != GvrAudioEngine.INVALID_ID) &#123; gvrAudioEngine.setSoundObjectPosition( sourceId, modelPosition[0], modelPosition[1], modelPosition[2]);&#125; 在onNewFrame方法中，我们得到一个表示用户头部最新位置的四元数，并将它传递给 setHeadRotation（）以更新 gvrAudioEngine 12345// Update the 3d audio engine with the most recent head rotation.headTransform.getQuaternion(headRotation, 0);gvrAudioEngine.setHeadRotation( headRotation[0], headRotation[1], headRotation[2], headRotation[3]);Calls to gvrAudioEngine.update() should be made once per frame. Handling inputsCardboard Viewers 包含使用了触摸模拟器的触发按钮（Trigger Button）。当您拉动触发器时，Viewwer 触摸您的手机屏幕。这些触发事件由Google VR SDK为您检测。 要在用户拉动触发器时提供 自定义行为，要在 activity 中重写 GvrActivity.onCardboardTrigger（）。在寻宝应用程序中，例如，当你找到一个宝藏并拉动触发器，立方体移动到一个新的地方。123456789101112/** * Called when the Cardboard trigger is pulled. */@Overridepublic void onCardboardTrigger() &#123; if (isLookingAtObject()) &#123; hideObject(); &#125; // Always give user feedback mVibrator.vibrate(50);&#125;","categories":[],"tags":[{"name":"VR","slug":"VR","permalink":"http://iyounix.com/tags/VR/"}]},{"title":"VR 应用开发入门基本知识(Oculus/Cardboard/Daydream)","slug":"VR/[VR] 应用开发入门基本知识","date":"2017-06-05T15:01:05.000Z","updated":"2018-11-08T02:00:29.695Z","comments":true,"path":"2017/06/05/VR/[VR] 应用开发入门基本知识/","link":"","permalink":"http://iyounix.com/2017/06/05/VR/[VR] 应用开发入门基本知识/","excerpt":"","text":"近两天搜集 VR 开发的相关资料。整理如下，也算是对希望进入 VR 应用开发的初学者有个指引与规划的作用。 [TOC] 技术概览VR 核心技术体现在以下几个方面：全立体显示（3D 显示）：包括反畸变算法、多图像处理运动追踪：利用陀螺仪 GyroscopeSensor 加速度计 G-Sensor 等来感应我们身体移动和头部转动输入设备：触摸板、手柄、无线体感设备、手势识别利用手柄的典型方案比如 HTC 的 Vive、Sony 的 PS VR无线体感设备比如 雷射的 Hydra、Sixense 的 STEM手势识别感应设备比如 Leap Motion 和 Nimble VR具体哪种方式会成为未来 VR 的 “鼠标” 暂时还不明朗。开发工具：OpenGL 提供的 API、Unity3D 引擎 等 三种解决方案VR 设备代表性的目前有 Oculus Rift、GearVR、谷歌盒子他们分别采用了三种解决方案： 分体机（Oculus Rift ） 一体机（Gear VR） VR 盒子（Cardboard）Oculus RiftOculus Rift 是 Oculus 开发的一款头显。要使用它，我们还需要拥有一款强大的主机。GearVR有的人会说 GearVR 是插入手机的 VR 盒子呢～ 但是实际上 GearVR 是属于一体机的。从技术上来说，因为 GearVR 的产生实际是 Oculus 提供的一种便携式解决方案。它结合了 Oculus 的光学技术、头部追踪技术以及三星的 OLED 高分辨率屏等。运用了头盔中内置陀螺仪传感器而不是采用的手机中的传感器，这实际上是所有一体机的设计模式。从市场上来说，我们一般也是将 GearVR 与一体机来进行比较的，而且 GearVR + 三星手机 比市场上大多数 3000元以下的一体机的体验都要好。Cardboard谷歌纸盒 实际上是 Google 开放的一种规格。我们只需要下载安装 Google 纸盒支持的应用程序，然后将手机放在纸盒中运行就可以了。现在市面上很多的 VR 盒子都是参考 Cardboard 的规格来设计的。 实际上还有 Google 的 Daydream。 “Cardboard上的应用主要是有趣的短视频体验， 几乎没有任何交互。但是 Daydream 则相反， 主要是提供沉浸式高度交互性的内容。” 但是 Daydream 暂时还未正式发布，暂时不表。 VR 应用的分类在不同类型的应用中我们所用到的开发技术也有所区别。 浏览器现在浏览器已经开始慢慢支持 VR。我们可以运用 HTML5、WebGL、JavaScript 这些技术快速开发 VR 应用。并且这些应用的跨平台性还很不错。 视频视频和游戏完全不同。我们知道 游戏中的图像大都是合成的，但是 VR 视频的内容是拍摄的现实世界的内容。这方面涉及的知识属于 “3D 录像”（facebook 有开源一个 利用17个摄像头实现全景录像的项目，surround360，大家可以去 Github 上面自己瞅～）。 游戏、VR OS、普通应用本文主要讨论的，同时也是行业内一般所称的 VR 应用指的是 VR 中的普通应用（比如设置菜单、图库、播放器），主题，以及 VR 游戏等。采用的开发工具多为 Unity3D。但是根据不同的平台（一体机、分体机、VR 盒子），也会有一些差异，在后面将会具体的描述。 三种方案中对应的开发工具前文有说现在 VR 产品的表现形式大致有三种： 分体机（Oculus Rift ） 一体机（Gear VR） VR 盒子（Cardboard） 后面逐一列一下他们分别用到的具体开发工具。 分体机以 Oculus Rift 为例，我们需要 VR 硬件设备（DK2） 下载 运行库 下载 Oculus 的 SDK。这个需要你去 Oculus 官网上注册帐号，然后填写你使用的平台的相关信息。 我们要开发 Oculus Rift 的桌面端 VR 应用可以参考这两篇文章Oculus 开发环境配置（基于 Unity）Oculus Unity 开发指南 一体机以 GearVR 为例。硬件上我们需要一部 S6 或者 Note4 以上的三星手机，软件上我们需要 下载 Oculus 的移动端 SDK（后面简称 移动端SDK） 注册一个账户，然后1）在顶部导航栏选择Downloads页面。2）在SDK下拉选项中选择SDK:MOBILE。3）点击最新移动端SDK链接。4）同意使用许可协议。5）下载SDK的压缩包。 下载 Android 的 SDK我是在 Android Studio 中下载的 SDK，你也可以在 Android 官网 SDK 下载界面 下载。 生成 Oculus 签名文件我们需要签名文件才可以让应用在你的手机上运行，因为通过移动端 SDK 构建的 VR 应用需要一个唯一的签名才可以调用更底层的API。在 Oculus开发者官网 上可以进行签名文件的生成。有 Android 设备调试经验的应该了解 adb，我们将 adb devices 获取到的 id 复制到上面的网站相应区域，然后可以获取签名文件。 采用 Unity 开发 GearVR 应用。可以参考这一篇文章。 VR 盒子以 Google Cardboard 为例，Google 为 Cardboard 提供了两套 SDK，一套用作 Android 原生开发，一套用作 Unity3D 引擎开发。 这里是一个基于 Cardboard SDK 利用 Unity3D 开发的小例子这里是一个开发 Google VR 的简要教程 ，这个博客后面两篇文章还介绍了两个 Google 开源的项目（VR 全景图播放器、VR 视频播放器） 其他知识点因为我并非专业 VR 应用开发者，在搜集资料的时候也碰到一些概念不大了解。所以归纳总结如下，如果有误还请指出，谢谢～ OpenGL 与 Unity3DOpenGL 是一个相对底层的框架。会提供一系列函数框架作为 API 提供给开发者使用。Unity3D 是一个跨平台的游戏引擎。解决的是游戏制作人通过什么东西来做游戏的问题。本身包含很多游戏相关的功能，比如绘图，播动画，放音乐，联网等等。 Unity会用到OpenGL来绘制它要绘制的2D、3D图形。这两者的关系，好比汽车与它的引擎，汽车一定需要引擎，但是引擎可不知道它被用在哪个汽车上(via 周华)。 Unity3DUnity3D 是一个很强大的游戏引擎，并且它是我们制作 VR 应用的首选方案(via MichaelLiew)。Unity结合Oculus的SDK提供了一整套的VR开发解决方案，其中还包括示例场景和入门教程。 Unity3D 的学习资料 这里 的一套比较好。","categories":[],"tags":[{"name":"VR","slug":"VR","permalink":"http://iyounix.com/tags/VR/"}]},{"title":"Android6.0 使用 repo 更新某个指定 git 仓库","slug":"Android_App/[Android6.0] 使用 repo 更新某个指定 git 仓库","date":"2017-04-05T15:01:05.000Z","updated":"2018-11-08T03:24:03.599Z","comments":true,"path":"2017/04/05/Android_App/[Android6.0] 使用 repo 更新某个指定 git 仓库/","link":"","permalink":"http://iyounix.com/2017/04/05/Android_App/[Android6.0] 使用 repo 更新某个指定 git 仓库/","excerpt":"","text":"[TOC] repo 同步整个项目1repo sync repo 同步单个项目同步单个文件的方式就是1repo sync &lt;project&gt; \\ 即为 manifest 中的 name 或者 path。 我们打开 .repo/manifest.xml ，有类似如下代码123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;manifest&gt; &lt;remote fetch=&quot;.&quot; name=&quot;aosp&quot; review=&quot;https://10.10.10.29&quot;/&gt; &lt;remote fetch=&quot;.&quot; name=&quot;rk&quot; review=&quot;https://10.10.10.29&quot;/&gt; &lt;default remote=&quot;aosp&quot; revision=&quot;refs/tags/android-6.0.1_r63&quot; sync-j=&quot;4&quot;/&gt; &lt;project name=&quot;android/RKDocs&quot; path=&quot;RKDocs&quot; remote=&quot;rk&quot; revision=&quot;rk3399/box/android-6.0&quot;/&gt; &lt;project name=&quot;android/RKTools&quot; path=&quot;RKTools&quot; remote=&quot;rk&quot; revision=&quot;ce0d44915d3b13cc556ff607dde745f71965ccc3&quot; upstream=&quot;rk3399/box/android-6.0&quot;/&gt; &lt;project name=&quot;rk/RKNanoC&quot; path=&quot;RKNanoC&quot; remote=&quot;rk&quot; revision=&quot;master&quot;/&gt; &lt;project groups=&quot;pdk-cw-fs,pdk-fs&quot; name=&quot;android/device/common&quot; path=&quot;device/common&quot; remote=&quot;rk&quot; revision=&quot;6482b0e4219edbbb3da2c6e77ce7c2ba22e55ba9&quot; upstream=&quot;rk32/mid/6.0/develop&quot;/&gt; &lt;project groups=&quot;pdk&quot; name=&quot;android/device/generic/arm64&quot; path=&quot;device/generic/arm64&quot; revision=&quot;39249053f37b7f9633eb406af3dbedfea7bf8b3e&quot; upstream=&quot;refs/tags/android-6.0.1_r63&quot;/&gt; 比如只要同步 RKDocs 仓库中的内容：1repo sync RKDocs 或者1repo sync android/RKDocs","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android5.1 RK3288 build.sh脚本分析","slug":"Android_Sys/[Android5.1][RK3288]build.sh脚本分析","date":"2016-12-31T15:33:05.000Z","updated":"2018-11-08T02:20:07.843Z","comments":true,"path":"2016/12/31/Android_Sys/[Android5.1][RK3288]build.sh脚本分析/","link":"","permalink":"http://iyounix.com/2016/12/31/Android_Sys/[Android5.1][RK3288]build.sh脚本分析/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#!/bin/bashsource build/envsetup.sh &gt;/dev/null &amp;&amp; setpathsTARGET_PRODUCT=`get_build_var TARGET_PRODUCT`# source environment and chose target productDEVICE=`get_build_var TARGET_PRODUCT`BUILD_VARIANT=`get_build_var TARGET_BUILD_VARIANT`UBOOT_DEFCONFIG=rk3288_defconfigKERNEL_DEFCONFIG=rockchip_defconfig KERNEL_DTS=rk3288-tb_8846PACK_TOOL_DIR=RKTools/linux/Linux_Pack_FirmwareIMAGE_PATH=rockdev/Image-$TARGET_PRODUCTexport PROJECT_TOP=`gettop`lunch $DEVICE-$BUILD_VARIANTPLATFORM_VERSION=`get_build_var PLATFORM_VERSION`DATE=$(date +%Y%m%d.%H%M)STUB_PATH=\"$KERNEL_DTS\"_\"$PLATFORM_VERSION\"_\"$DATE\"_RELEASE_TEST#STUB_PATH=rk3288-tb_8846_STUB_PATH=\"$(echo $STUB_PATH | tr '[:lower:]' '[:upper:]')\"export STUB_PATH=$PROJECT_TOP/$STUB_PATHexport STUB_PATCH_PATH=$STUB_PATH/PATCHES# build ubootecho \"start build uboot\"cd u-boot &amp;&amp; make distclean &amp;&amp; make $UBOOT_DEFCONFIG &amp;&amp; make -j32 &amp;&amp; cd -if [ $? -eq 0 ]; then echo \"Build uboot ok!\"else echo \"Build uboot failed!\" exit 1fi# build kernelecho \"start build kernel\"cd kernel &amp;&amp; make $KERNEL_DEFCONFIG &amp;&amp; make $KERNEL_DTS.img -j32 &amp;&amp; cd -if [ $? -eq 0 ]; then echo \"Build kernel ok!\"else echo \"Build kernel failed!\" exit 1fi# build androidecho \"start build android\"make installcleanmake -j32if [ $? -eq 0 ]; then echo \"Build android ok!\"else echo \"Build android failed!\" exit 1fi# mkimage.shecho \"make and copy android images\"./mkimage.shif [ $? -eq 0 ]; then echo \"Make image ok!\"else echo \"Make image failed!\" exit 1ficp -f $IMAGE_PATH/* $PACK_TOOL_DIR/rockdev/Image/# copy images to rockdevecho \"copy u-boot images\"cp u-boot/uboot.img $PACK_TOOL_DIR/rockdev/Image/cp u-boot/RK3288UbootLoader* $PACK_TOOL_DIR/rockdev/RK3288UbootLoader.binecho \"copy kernel images\"cp kernel/resource.img $PACK_TOOL_DIR/rockdev/Imagecp kernel/kernel.img $PACK_TOOL_DIR/rockdev/Imageecho \"copy manifest.xml\"cp manifest.xml $IMAGE_PATH/manifest_$&#123;DATE&#125;.xmlcd RKTools/linux/Linux_Pack_Firmware/rockdev &amp;&amp; ./mkupdate.shif [ $? -eq 0 ]; then echo \"Make update image ok!\"else echo \"Make update image failed!\" exit 1ficd -mkdir -p $STUB_PATH#Generate patches.repo/repo/repo forall -c '[ \"$REPO_REMOTE\" = \"rk\" -a \"$REPO_RREV\" != \"refs/tags/android-4.4.4_r2\" ] &amp;&amp; &#123; REMOTE_DIFF=`git log $REPO_REMOTE/$REPO_RREV..HEAD`; LOCAL_DIFF=`git diff`; [ -n \"$REMOTE_DIFF\" ] &amp;&amp; &#123; mkdir -p $STUB_PATCH_PATH/$REPO_PATH/; git format-patch $REPO_REMOTE/$REPO_RREV..HEAD -o $STUB_PATCH_PATH/$REPO_PATH; &#125; || :; [ -n \"$LOCAL_DIFF\" ] &amp;&amp; &#123; mkdir -p $STUB_PATCH_PATH/$REPO_PATH/; git reset HEAD ./; git diff &gt; $STUB_PATCH_PATH/$REPO_PATH/local_diff.patch; &#125; || :; &#125;'#Copy stubscp manifest.xml $STUB_PATH/manifest_$&#123;DATE&#125;.xmlmkdir -p $STUB_PATCH_PATH/kernelcp kernel/.config $STUB_PATCH_PATH/kernelmkdir -p $STUB_PATH/IMAGES/#mv $PACK_TOOL_DIR/rockdev/Image/* $STUB_PATH/IMAGES/mv RKTools/linux/Linux_Pack_Firmware/rockdev/update.img $STUB_PATH/IMAGES/mv $PACK_TOOL_DIR/rockdev/RK3288UbootLoader.bin $STUB_PATH/IMAGES/cp $PACK_TOOL_DIR/rockdev/parameter $STUB_PATH/IMAGES/cp $STUB_PATH/IMAGES/update.img rockdev/Image-$TARGET_PRODUCT##Save build command infoecho \"UBOOT: defconfig: $UBOOT_DEFCONFIG\" &gt;&gt; $STUB_PATH/build_cmd_infoecho \"KERNEL: defconfig: $KERNEL_DEFCONFIG, dts: $KERNEL_DTS\" &gt;&gt; $STUB_PATH/build_cmd_infoecho \"ANDROID:$DEVICE-$BUILD_VARIANT\" &gt;&gt; $STUB_PATH/build_cmd_info","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Mipi LCD 的基础知识","slug":"Android_Driver/Device/[Device] Mipi LCD 的基础知识","date":"2016-12-31T15:33:05.000Z","updated":"2018-11-08T02:58:03.797Z","comments":true,"path":"2016/12/31/Android_Driver/Device/[Device] Mipi LCD 的基础知识/","link":"","permalink":"http://iyounix.com/2016/12/31/Android_Driver/Device/[Device] Mipi LCD 的基础知识/","excerpt":"","text":"基础知识LCD（Liquid Crystal Display）即液晶显示器。根据驱动方式 分为 静态驱动、简单矩阵驱动、主动矩阵驱动。简单矩阵驱动 分为 扭转向阵列（TN） 和 超扭转时向列型（STN）。主动矩阵驱动 以 薄膜式晶体管（TFT） 为主。 我们作为驱动工程师，关注的点在于 屏 的时序。时序图中VCLK 为 像素时钟信号（用于锁存图像数据的像素时钟）HSYNC 为 行同步信号VSYNC 为 帧同步信号VDEN 为 数据有效标志信号VD 为 图像的数据信号PCLK/DCLK 为 点时钟 dot CLK VSYNC 是 帧同步信号，每发出一个脉冲，意味着新的一屏图像数据开始发送。HSYNC 是 行同步信号，每发出一个脉冲，意味着新的一行图像资料开始发送。在 帧同步 和 行同步 头尾 都必须留有回扫时间。 LCD 控制器中我们需要设置一些参数。VBP（vertical back porch） 上边界 帧切换回扫时间VFP（vertical front porch） 下边界 帧切换回扫时间HBP（horizontal back porch）左边界 行切换回扫时间HFP（horizontal front porch）右边界 行切换回扫时间HS（hsync，horizontal pulse width）水平同步信号，行同步本身需要的时间VS（vsync，vertical pulse width）垂直同步信号，帧同步本身需要的时间H_VALUE/V_VALUE 表示横向分辨率 和 纵向分辨率。 且这些参数遵循如下公式：HBP + Hsync + HFP + Xres = HP(horizontal period)VBP + Vsync + VFP + Yres = VP(vertical period) 了解了这些知识就可以开始 LCD 的移植了。 调试流程常见问题和解决方法","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"TypeC 基础知识","slug":"Android_Driver/Device/[Device] TypeC 基础知识","date":"2016-12-31T15:33:05.000Z","updated":"2018-11-08T02:59:10.836Z","comments":true,"path":"2016/12/31/Android_Driver/Device/[Device] TypeC 基础知识/","link":"","permalink":"http://iyounix.com/2016/12/31/Android_Driver/Device/[Device] TypeC 基础知识/","excerpt":"","text":"[TOC] TypeC 基本特性 正反插 速度快 10Gbps 引脚定义 TX/RX 两组差分信号用来进行数据传输。 CC1 和 CC2 作用： 区分正反面 区分 DFP （Host）和 UFP（Device） 配置 VBUS，有 USB TypeC 和 USB Power Delivery 两种模式 配置 Vconn，当线缆中有芯片时，一个 CC 传输信号，一个 CC 变成供电 Vconn 配置其他模式，比如接音频时、dp时、pcie时 等等。 Vbus 电源 和 GND 都有 4 个，这也是为何可以达到 100W 的原因。最高可以支持 20V/5A，但是需要 USB PD 芯片的支持。 SUB1 和 SUB2 （Side band use），在一些特殊的传输模式下才会使用。 D+ D- 用来兼容 USB 之前的标准。 TypeC 如何确定充电方向TypeC 设备有三种形式：DFP（Downstream Facing Port）：只能作 Source（Host），比如充电器。UFP（Upstream Facing Port）：只能作 Sink（Device），比如 U盘、鼠标、键盘、老款的手机（UFP TypeC 头的手机）。DRP：两者都可以作。比如新款的手机（DRP TypeC头的手机），平板，笔记本。 所以，如果我们手上有一个 TypeC 的手机，有可能有两种情况： 手机上是 UFP 的 C 母头。无论是接到充电器还是电脑，都会被充电。 手机上是 DRP 的 C 母头。2.1 插到充电器，因为充电器只能作 DFP，所以手机会切换为 UFP，进而被充电2.2 插到笔记本、另一台手机 或是 充电宝：2.2.1 手机、电脑、充电宝 会随机当 host 和 sink，每次插拔后角色互换（前提是支持 PD 协议）2.2.2 手机、电脑、充电宝 有一方有作为 host 端的偏好设定。此时有偏好设定的一方会称为 host 端。 注：偏好设定是最新的 TypeC 规范中对 DRP 部分的描述，新增了两种类型： DRP try source：和DRP或者DRP try sink相连时，会连成Source。 DRP try sink：和DRP或者DRP try source相连时，会连成sink。 TypeC 确定设备类型的原理usb 模式 根据 CC 引脚区分 DFP （Host） 和 UFP （Device）。 在 DFP 的 CC pin 有上拉电阻 Rp（阻值不确定，后面会说） ，在 UFP 的 CC pin 有下拉电阻 Rd 5.1k。没有连接的时候，DFP VBUS 没有输出。连接时，CC pin 相连，DFP 的 CC 会检测到 UFP 的下拉电阻 Rd，此时表示连接上了，DFP 就会打开 VBUS 电源，输出电源给 UFP。希望能提供原始文档。 具体哪个 CC pin 检测到下拉电阻，就决定了插入方向，顺便切换 RX/TX。 UFP 的下拉电阻 Rd = 5.1 kDFP 的上拉电阻 Rp 阻值不确定，因为需要这个电阻来确定 USB TypeC 的几种供电模式。当 Rp 值不同，CC pin 检测到的电压就不同，进而控制 DFP 使用哪种供电模式。 虽然有两个 CC，但是实际在不含芯片的线缆中只有一根 CC 线，含芯片的线缆也不是两根 CC 线，是一根 CC 线，一根 Vconn 用来给芯片供电（3.3V或者5V），此时 CC 端下拉电阻 Ra = 800-1.2k 欧 音频配件模式两个 CC pin 都接了下拉电阻 &lt;= Ra 时，DFP 进入音频配件模式，左右声道、mic 都具备 DP 模式 和 PCIe 模式USB PD 是在 CC pin 上传输，PD 有个 VDB（Vendor defined message ）功能，定义了 Device 端 ID，读到了支持 DP 或者 PCIe 的装置，就进入 alternate 模式。 如果 DFP 认到 device 为 DP，便切换 MUX/Configuration Switch，让 Type-C USB3.1 信号脚改为传输 DP 信号。AUX 辅助由 Type-C 的 SBU1,SUB2 来传。HPD 是检测脚，和 CC 差不多，所以共用。 而 DP 有 lane0-3 四组差分信号， Type-C 有 RX/TX1-2 也是四组差分信号，所以完全替代没问题。而且在 DP 协议里的替代模式，可以 USB 信号和 DP 信号同时传输，RX/TX1 传输 USB 数据，RX/TX2 替换为 lane0,1 两组数据传输，此时可支持到 4k。 如果 DFP 认到 device 为 DP，便切换 MUX/Configuration Switch，让 Type-C USB3.1 信号脚改为传输 PCIe 信号。同样的，PCIe 使用 RX/TX2 和 SBU1,SUB2 来传输数据，RX/TX1 传输 USB 数据。 这样的好处就是一个接口同时使用两种设备，当然了，转换线就可以做到，不用任何芯片。","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Mipi 接口 和 LVDS 接口区别","slug":"Android_Driver/Device/[Device] Mipi 接口 和 LVDS 接口区别","date":"2016-12-31T15:33:05.000Z","updated":"2018-11-08T02:58:15.989Z","comments":true,"path":"2016/12/31/Android_Driver/Device/[Device] Mipi 接口 和 LVDS 接口区别/","link":"","permalink":"http://iyounix.com/2016/12/31/Android_Driver/Device/[Device] Mipi 接口 和 LVDS 接口区别/","excerpt":"","text":"http://bbs.elecfans.com/jishu_887561_1_1.html 主要区别： LVDS接口只用于传输视频数据，MIPI DSI不仅能够传输视频数据，还能传输控制指令； LVDS接口主要是将RGB TTL信号按照SPWG/JEIDA格式转换成LVDS信号进行传输，MIPI DSI接口则按照特定的握手顺序和指令规则传输屏幕控制所需的视频数据和控制数据。 液晶屏有RGB TTL、LVDS、MIPI DSI接口，这些接口区别于信号的类型（种类），也区别于信号内容。RGB TTL接口信号类型是TTL电平，信号的内容是RGB666或者RGB888还有行场同步和时钟；LVDS接口信号类型是LVDS信号（低电压差分对），信号的内容是RGB数据还有行场同步和时钟；MIPI DSI接口信号类型是LVDS信号，信号的内容是视频流数据和控制指令。","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android5.1 RK3288 SPI 设备驱动模型（Ad714x CapTouch 驱动分析）","slug":"Android_Driver/Driver/[Android5.1][RK3288] SPI 设备驱动模型（Ad714x CapTouch 驱动分析）","date":"2016-12-31T15:33:05.000Z","updated":"2018-11-08T02:33:18.837Z","comments":true,"path":"2016/12/31/Android_Driver/Driver/[Android5.1][RK3288] SPI 设备驱动模型（Ad714x CapTouch 驱动分析）/","link":"","permalink":"http://iyounix.com/2016/12/31/Android_Driver/Driver/[Android5.1][RK3288] SPI 设备驱动模型（Ad714x CapTouch 驱动分析）/","excerpt":"","text":"之前有归纳过传统 board-info 形式下的 spi 驱动模型：Linux 内核中 SPI 设备驱动模型（Platform设备驱动方式）。 但是这里代码的环境是 Android5.1。所以我们先来分析一下 DTS。 DTS根据硬件工程师给出的信息，这颗 GSensor 接到 Spi0 上，我们可以看一下 DTS 中的信息：12345678910#spi0spi0: spi@70a00000&#123; compatible = \"sprd, sprd-spi\"; interrupts = &lt;0 7 0x0&gt; reg = &lt;0x70a00000 0x1000&gt; clock-names = \"clk_spi0\"; #address-cells = &lt;1&gt;; #size-cells = &lt;0&gt;;&#125;;# spi1... SPI 部分驱动这种 SPI 类的 Sensor 一般会将驱动分为两个部分，一部分是 CHIP_spi.c 一部分是 CHIP.c。 CHIP_spi.cCHIP_spi_driver在 CHIP_SPI.c 中完成的任务是 CHIP_spi_read 及 CHIP_spi_write 等回调函数的实现。SPI 协议驱动有些类似平台设备驱动：123456789static struct spi_driver ad714x_spi_driver = &#123; .driver = &#123; .name = \"ad714x_captouch\", .owner = THIS_MODULE, .pm = &amp;ad714x_spi_pm, &#125;, .probe = ad714x_spi_probe, .remove = ad714x_spi_remove,&#125;; module_spi_driver() 宏内核将调用 module_spi_driver() 这个宏来注册和卸载 spi 设备，这个 module_spi_driver 是专门针对于 spi 架构定义的。在 include/linux/spi/spi.h 中，我们可以看到：1234567891011281 /**282 * module_spi_driver() - Helper macro for registering a SPI driver283 * @__spi_driver: spi_driver struct284 *285 * Helper macro for SPI drivers which do not do anything special in module286 * init/exit. This eliminates a lot of boilerplate. Each module may only287 * use this macro once, and calling it replaces module_init() and module_exit()288 */289 #define module_spi_driver(__spi_driver) \\290 module_driver(__spi_driver, spi_register_driver, \\291 spi_unregister_driver) 可以还可以往下去追看 module_driver() 这个宏 ，它将 spi_register/unregister_driver() 与 module_init 和 module_exit 封装了起来。所以说实际上 module_spi_driver() 和 module_init/exit 几乎是没有区别的。之所以直接将其封装的原因是因为这个 SPI 设备本身是不可插拔的，也就不需要 init 和 exit 的过程，系统上电就直接注册了。 CHIP_spi_probe()12345678910111213141516171819202122232425static int ad714x_spi_probe(struct spi_device *spi)&#123; // struct CHIP_chip 被定义在 .h 文件中，其中封装了 CHIP_platform_data、CHIP_driver_data、device 等结构体，以及一些回调函数 // 我们可以将其理解为 spi_device 的封装 struct ad714x_chip *chip; int err; spi-&gt;bits_per_word = 8; //定义每个字传输的 bit 数 err = spi_setup(spi); // 配置 SPI 的通信相关的信息，实现在 driver/spi/spi.c 中 if (err &lt; 0) return err; // 将我们实现的 CHIP_spi_read 和 CHIP_spi_write 传到 CHIP.c 文件中的主 probe 中 // 在 主 probe 中调用 read 和 write 来进行和从设备的通信，主 probe() 我们在下一段分析 chip = ad714x_probe(&amp;spi-&gt;dev, BUS_SPI, spi-&gt;irq, ad714x_spi_read, ad714x_spi_write); if (IS_ERR(chip)) return PTR_ERR(chip); spi_set_drvdata(spi, chip); //=&gt; dev_set_drvdata(&amp;spi-&gt;dev,chip) //=&gt; spi-&gt;dev-&gt;driver_data = chip return 0;&#125; 抽象出来就是12345678910111213141516static int __devinit CHIP_spi_probe(struct spi_device *spi) &#123; struct CHIP *chip; struct CHIP_platform_data *pdata; //也可以将这个封装到上面的 CHIP 里面 /* assuming the driver req一个\"spi_masteruires board-specific data: */ pdata = &amp;spi-&gt;dev.platform_data; if (!pdata) return -ENODEV; /* get memory for driver\\'s per-chip state */ chip = kzalloc(sizeof *chip, GFP_KERNEL); if (!chip) return -ENOMEM; spi_set_drvdata(spi, chip); ... etc return 0;中 &#125; 其中的主 probe 放到后面去分析。其中的 spi_setup() 中可以修改 spi_device 特征，如传输模式、字长或时钟速率。 CHIP_spi_read / CHIP_spi_write先介绍一下 struct spi_message123456789101112789 struct spi_message &#123;790 struct list_head transfers;792 struct spi_device *spi; ...814 /* for optional use by whatever driver currently owns the815 * spi_message ... between calls to中 spi_async and then later816 * complete(), that's the spi_master controller driver.817 */818 struct list_head queue;821 /* list of spi_res reources when the spi message is processed */822 struct list_head resources;##### spi_message 823 &#125;; 一个 message 是一次数据交换的原子请求， spi_message 是多个 spi_transfer 结构组成，这些 spi_transfer 通过一个链表 transfers 组织在一起。具体可以看这篇博文：SPI 数据传输的队列化。spi_message 结构有一个链表头字段 transfers。spi_transfer 结构包含一个链表头字段 transfer_list。通过这两个链表头字段，所有属于这次 message 传输的 transfer 都会挂在 spi_messages.transfers 下。我们通过 spi_message_add_tail 来向 spi_message 结构中添加一个 spi_transfer 结构。然后调用 spi_async 同步 或者 spi_sync 异步来发起一个 message 传输请求，通常 spi_async 或 spi_sync 由将被封装在 read 和 write 中。 1234567891011121314151617181920212223242526272829303132333435363738//read 有四个参数//1. 之前封装了 device 的结构体//2. 需要读取的寄存器//3. 用来接受数据的 data//4. 传输的字节数static int ad714x_spi_read(struct ad714x_chip *chip,源码 unsigned short reg, unsigned short *data, size_t len)&#123; struct spi_device *spi = to_spi_device(chip-&gt;dev);//利用 container_of 将封装的 dev 提取出来 struct spi_message message; struct spi_transfer xfer[2]; // SPI 控制器 和 协议驱动 之间的 I/O 接口 int i; int error; spi_message_init(&amp;message); // 先初始化 message memset(xfer, 0, sizeof(xfer)); chip-&gt;xfer_buf[0] = cpu_to_be16(AD714x_SPI_CMD_PREFIX | AD714x_SPI_READ | reg); xfer[0].tx_buf = &amp;chip-&gt;xfer_buf[0]; xfer[0].len = sizeof(chip-&gt;xfer_buf[0]); spi_message_add_tail(&amp;xfer[0], &amp;message); xfer[1].rx_buf = &amp;chip-&gt;xfer_buf[1]; xfer[1].len = sizeof(chip-&gt;xfer_buf[1]) * len; spi_message_add_tail(&amp;xfer[1], &amp;message); error = spi_sync(spi, &amp;message);//调用spi_sync 来发起 message 传输请求 if (unlikely(error)) &#123; dev_err(chip-&gt;dev, \"SPI read error: %d\\n\", error); return error; &#125; for (i = 0; i &lt; len; i++) data[i] = be16_to_cpu(chip-&gt;xfer_buf[i + 1]); return 0;&#125; 123456789101112131415161718192021222324252627282930// 三个参数// 1. 封装了 device 的结构体// 2. 要写入的寄存器// 3. 要写入的数据static int ad714x_spi_write(struct ad714x_chip *chip, unsigned short reg, unsigned short data)&#123; struct spi_device *spi = to_spi_device(chip-&gt;dev); int error; chip-&gt;xfer_buf[0] = cpu_to_be16(AD714x_SPI_CMD_PREFIX | reg); chip-&gt;xfer_buf[1] = cpu_to_be16(data); error = spi_write(spi, (u8 *)chip-&gt;xfer_buf, 2 * sizeof(*chip-&gt;xfer_buf)); /* 这里的 spi_write 等价于 struct spi_transfer t = &#123; .tx_buf = chip-&gt;xfer_buf, .len = 2*sizeof(*chip-&gt;xfer_buf), &#125;; struct spi_message m; spi_message_init(&amp;m); spi_message_add_tail(&amp;t,&amp;m); return spi_sync(spi, &amp;m); */ if (unlikely(error)) &#123; dev_err(chip-&gt;dev, \"SPI write error: %d\\n\", error); return error; &#125; return 0;&#125; CHIP.c之前我们在 CHIP_spi_probe() 中可以注意到，有如下代码12chip = ad714x_probe(&amp;spi-&gt;dev, BUS_SPI, spi-&gt;irq, ad714x_spi_read, ad714x_spi_write); 这里 CHIP_probe() 的定义在 CHIP.c我们来读一下 CHIP_probe() 的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227// 有 5 个参数// 1. device// 2. 总线类型// 3. 中断号// 4. 5. read 和 write 的实现函数（封装了 spi_async）// 代码太长，我们直接看哪些地方调用了 read 和 write，其他的地方省略struct ad714x_chip *ad714x_probe(struct device *dev, u16 bus_type, int irq, ad714x_read_t read, ad714x_write_t write)&#123; int i, alloc_idx; int error; struct input_dev *input[MAX_DEVICE_NUM]; struct ad714x_platform_data *plat_data = dev-&gt;platform_data; struct ad714x_chip *ad714x; void *drv_mem; unsigned long irqflags; struct ad714x_button_drv *bt_drv; struct ad714x_slider_drv *sd_drv; struct ad714x_wheel_drv *wl_drv; struct ad714x_touchpad_drv *tp_drv; if (irq &lt;= 0) &#123; dev_err(dev, \"IRQ not configured!\\n\"); error = -EINVAL; goto err_out; &#125; if (dev-&gt;platform_data == NULL) &#123; dev_err(dev, \"platform data for ad714x doesn't exist\\n\"); error = -EINVAL; goto err_out; &#125; ad714x = kzalloc(sizeof(*ad714x) + sizeof(*ad714x-&gt;sw) + sizeof(*sd_drv) * plat_data-&gt;slider_num + sizeof(*wl_drv) * plat_data-&gt;wheel_num + sizeof(*tp_drv) * plat_data-&gt;touchpad_num + sizeof(*bt_drv) * plat_data-&gt;button_num, GFP_KERNEL); if (!ad714x) &#123; error = -ENOMEM; goto err_out; &#125; ad714x-&gt;hw = plat_data; drv_mem = ad714x + 1; ad714x-&gt;sw = drv_mem; drv_mem += sizeof(*ad714x-&gt;sw); ad714x-&gt;sw-&gt;slider = sd_drv = drv_mem; drv_mem += sizeof(*sd_drv) * ad714x-&gt;hw-&gt;slider_num; ad714x-&gt;sw-&gt;wheel = wl_drv = drv_mem; drv_mem += sizeof(*wl_drv) * ad714x-&gt;hw-&gt;wheel_num; ad714x-&gt;sw-&gt;touchpad = tp_drv = drv_mem; drv_mem += sizeof(*tp_drv) * ad714x-&gt;hw-&gt;touchpad_num; ad714x-&gt;sw-&gt;button = bt_drv = drv_mem; drv_mem += sizeof(*bt_drv) * ad714x-&gt;hw-&gt;button_num; ad714x-&gt;read = read; ad714x-&gt;write = write; ad714x-&gt;irq = irq; ad714x-&gt;dev = dev; //读硬件寄存器中的 chip ID，判断具体是哪种 CapTouch error = ad714x_hw_detect(ad714x); if (error) goto err_free_mem; /* initialize and request sw/hw resources */ ad714x_hw_init(ad714x); mutex_init(&amp;ad714x-&gt;mutex); /* * Allocate and register AD714X input device */ alloc_idx = 0; /* a slider uses one input_dev instance */ if (ad714x-&gt;hw-&gt;slider_num &gt; 0) &#123; struct ad714x_slider_plat *sd_plat = ad714x-&gt;hw-&gt;slider; for (i = 0; i &lt; ad714x-&gt;hw-&gt;slider_num; i++) &#123; sd_drv[i].input = input[alloc_idx] = input_allocate_device(); if (!input[alloc_idx]) &#123; error = -ENOMEM; goto err_free_dev; &#125; __set_bit(EV_ABS, input[alloc_idx]-&gt;evbit); __set_bit(EV_KEY, input[alloc_idx]-&gt;evbit); __set_bit(ABS_X, input[alloc_idx]-&gt;absbit); __set_bit(BTN_TOUCH, input[alloc_idx]-&gt;keybit); input_set_abs_params(input[alloc_idx], ABS_X, 0, sd_plat-&gt;max_coord, 0, 0); input[alloc_idx]-&gt;id.bustype = bus_type; input[alloc_idx]-&gt;id.product = ad714x-&gt;product; input[alloc_idx]-&gt;id.version = ad714x-&gt;version; input[alloc_idx]-&gt;name = \"ad714x_captouch_slider\"; input[alloc_idx]-&gt;dev.parent = dev; error = input_register_device(input[alloc_idx]); if (error) goto err_free_dev; alloc_idx++; &#125; &#125; /* a wheel uses one input_dev instance */ if (ad714x-&gt;hw-&gt;wheel_num &gt; 0) &#123; struct ad714x_wheel_plat *wl_plat = ad714x-&gt;hw-&gt;wheel; for (i = 0; i &lt; ad714x-&gt;hw-&gt;wheel_num; i++) &#123; wl_drv[i].input = input[alloc_idx] = input_allocate_device(); if (!input[alloc_idx]) &#123; error = -ENOMEM; goto err_free_dev; &#125; __set_bit(EV_KEY, input[alloc_idx]-&gt;evbit); __set_bit(EV_ABS, input[alloc_idx]-&gt;evbit); __set_bit(ABS_WHEEL, input[alloc_idx]-&gt;absbit); __set_bit(BTN_TOUCH, input[alloc_idx]-&gt;keybit); input_set_abs_params(input[alloc_idx], ABS_WHEEL, 0, wl_plat-&gt;max_coord, 0, 0); input[alloc_idx]-&gt;id.bustype = bus_type; input[alloc_idx]-&gt;id.product = ad714x-&gt;product; input[alloc_idx]-&gt;id.version = ad714x-&gt;version; input[alloc_idx]-&gt;name = \"ad714x_captouch_wheel\"; input[alloc_idx]-&gt;dev.parent = dev; error = input_register_device(input[alloc_idx]); if (error) goto err_free_dev; alloc_idx++; &#125; &#125; /* a touchpad uses one input_dev instance */ if (ad714x-&gt;hw-&gt;touchpad_num &gt; 0) &#123; struct ad714x_touchpad_plat *tp_plat = ad714x-&gt;hw-&gt;touchpad; for (i = 0; i &lt; ad714x-&gt;hw-&gt;touchpad_num; i++) &#123; tp_drv[i].input = input[alloc_idx] = input_allocate_device(); if (!input[alloc_idx]) &#123; error = -ENOMEM; goto err_free_dev; &#125; __set_bit(EV_ABS, input[alloc_idx]-&gt;evbit); __set_bit(EV_KEY, input[alloc_idx]-&gt;evbit); __set_bit(ABS_X, input[alloc_idx]-&gt;absbit); __set_bit(ABS_Y, input[alloc_idx]-&gt;absbit); __set_bit(BTN_TOUCH, input[alloc_idx]-&gt;keybit); input_set_abs_params(input[alloc_idx], ABS_X, 0, tp_plat-&gt;x_max_coord, 0, 0); input_set_abs_params(input[alloc_idx], ABS_Y, 0, tp_plat-&gt;y_max_coord, 0, 0); input[alloc_idx]-&gt;id.bustype = bus_type; input[alloc_idx]-&gt;id.product = ad714x-&gt;product; input[alloc_idx]-&gt;id.version = ad714x-&gt;version; input[alloc_idx]-&gt;name = \"ad714x_captouch_pad\"; input[alloc_idx]-&gt;dev.parent = dev; error = input_register_device(input[alloc_idx]); if (error) goto err_free_dev; alloc_idx++; &#125; &#125; /* all buttons use one input node */ if (ad714x-&gt;hw-&gt;button_num &gt; 0) &#123; struct ad714x_button_plat *bt_plat = ad714x-&gt;hw-&gt;button; input[alloc_idx] = input_allocate_device(); if (!input[alloc_idx]) &#123; error = -ENOMEM; goto err_free_dev; &#125; __set_bit(EV_KEY, input[alloc_idx]-&gt;evbit); for (i = 0; i &lt; ad714x-&gt;hw-&gt;button_num; i++) &#123; bt_drv[i].input = input[alloc_idx]; __set_bit(bt_plat[i].keycode, input[alloc_idx]-&gt;keybit); &#125; input[alloc_idx]-&gt;id.bustype = bus_type; input[alloc_idx]-&gt;id.product = ad714x-&gt;product; input[alloc_idx]-&gt;id.version = ad714x-&gt;version; input[alloc_idx]-&gt;name = \"ad714x_captouch_button\"; input[alloc_idx]-&gt;dev.parent = dev; error = input_register_device(input[alloc_idx]); if (error) goto err_free_dev; alloc_idx++; &#125; irqflags = plat_data-&gt;irqflags ?: IRQF_TRIGGER_FALLING; irqflags |= IRQF_ONESHOT; error = request_threaded_irq(ad714x-&gt;irq, NULL, ad714x_interrupt_thread, irqflags, \"ad714x_captouch\", ad714x); if (error) &#123; dev_err(dev, \"can't allocate irq %d\\n\", ad714x-&gt;irq); goto err_unreg_dev; &#125; return ad714x; err_free_dev: dev_err(dev, \"failed to setup AD714x input device %i\\n\", alloc_idx); input_free_device(input[alloc_idx]); err_unreg_dev: while (--alloc_idx &gt;= 0) input_unregister_device(input[alloc_idx]); err_free_mem: kfree(ad714x); err_out: return ERR_PTR(error);&#125;EXPORT_SYMBOL(ad714x_probe); 参考： 内核源码 /kernel/driver/spi/spi.c spi.h2.这个没有纠结于代码实现，归纳了Linux内核对 SPI 的支持方法。还有抽象出来说如何实现 SPI 驱动： http://linux.it.net.cn/m/view.php?aid=188523.这个以 一个 eeprom 的代码来进行分析 SPI 总线 http://www.cnblogs.com/jason-lu/p/3165327.html","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android5.1 RK3288 LCD (Mipi) 调试方法及问题汇总","slug":"Android_Driver/Driver/[Android5.1][RK3288] LCD (Mipi) 调试方法及问题汇总","date":"2016-12-31T15:33:05.000Z","updated":"2018-11-08T02:39:55.074Z","comments":true,"path":"2016/12/31/Android_Driver/Driver/[Android5.1][RK3288] LCD (Mipi) 调试方法及问题汇总/","link":"","permalink":"http://iyounix.com/2016/12/31/Android_Driver/Driver/[Android5.1][RK3288] LCD (Mipi) 调试方法及问题汇总/","excerpt":"","text":"调试流程设置 dts 中的参数 并 配置管脚仿造平台的其他 lcd-*-mipi.dtsi 编写 lcd-xxx-mipi.dtsi 后 需要在 主 dts 文件中包含这个 dtsi1#include “lcd-xxx-mipi.dtsi“ 先看屏的手册里面的关键信息有 分辨率（540×960） 接口（2条lanes）12345678910111213141516171819## MIPI Host配置disp_mipi_init: mipi_dsi_init&#123; compatible = \"rockchip,mipi_dsi_init\"; /* 是否要在 dtsi 中初始化 1 0 */ rockchip,screen_init = &lt;1&gt;; /* 要几条数据 lane ，根据原理图和 mipi 规格书*/ rockchip,dsi_lane = &lt;2&gt;; /* ddr clk 一条 lane 的传输速率 Mbits/s */ /* 100 + H_total×V_total×fps×3（一个rgb为3字节）×8（8bits）/lanes */ /* 这里的 total 指的是 sync + front + back + active */ /* 比如 H_total = Hsync + HFP(hfront-proch) + HBP(hback-porch) + Hactive */ rockchip,dsi_hs_clk = &lt;1000&gt;; /* 单mipi 还是双 mipi*/ rockchip,mipi_dsi_num = &lt;1&gt;;&#125;; 看原理图，完成管脚的配置可以看到，我这里只用到了 LCD_RST，没有用到 LCD_EN （是 VCC_LCD）,说明是默认使能的，也没有 LCD_CS所以进行如下配置123456789101112131415161718## 屏电源控制配置disp_mipi_power_ctr: mipi_power_ctr &#123; compatible = &quot;rockchip,mipi_power_ctr&quot;; mipi_lcd_rst:mipi_lcd_rst&#123; compatible = &quot;rockchip,lcd_rst&quot;; rockchip,gpios = &lt;&amp;gpio2 GPIO_B7 GPIO_ACTIVE_LOW&gt;; rockchip,delay = &lt;100&gt;; &#125;; /* // 配置 lcd_en GPIO 哪一路 ，有可能没有 LCD_EN 那么就是 VCC 常供电 mipi_lcd_en:mipi_lcd_en &#123; compatible = &quot;rockchip,lcd_en&quot;; rockchip,gpios = &lt;&amp;gpio0 GPIO_C1 GPIO_ACTIVE_HIGH&gt;; rockchip,delay = &lt;100&gt;; &#125;; */ //还可能有片选 cs&#125;; 根据屏的规格书 完成 timings 配置垂直方向的信息：重要的参数有 垂直同步信号 VFP VBP VS 对应填充到屏参中的 Vfront-proch Vback-proch Vsync-len同样水平方向的信息：要注意的是， HS HBP HFP 虽然最小值是 5，但是不能设置的这么低因为后面还有两条要求，HBLK = HS + HBP + HFP &gt;= 24 且 HS + HBP &gt; 19所以最初设置 HS = HBP = HFP = 1012345678910111213141516171819202122232425// lcd-xxx-mipi.dtsi 中的 屏参disp_timings: display-timings &#123; native-mode = &lt;&amp;timing0&gt;; compatible = \"rockchip,display-timings\"; timing0: timing0 &#123; screen-type = &lt;SCREEN_MIPI&gt;; //单mipi SCREEN_MIPI 双mipi SCREEN_DUAL_MIPI lvds-format = &lt;LVDS_8BIT_2&gt;; //不用配置 out-face = &lt;OUT_P888&gt;; //屏的接线格式 //配置颜色，可为OUT_P888（24位）、OUT_P666（18位）或者OUT_P565（16位） clock-frequency = &lt;120000000&gt;; //dclk频率，看规格书，或者 H×V×fps hactive = &lt;540&gt;; //水平有效像素 vactive = &lt;960&gt;; //垂直有效像素 hback-porch = &lt;80&gt;; //水平同步信号 hfront-porch = &lt;81&gt;; //水平同步信号 vback-porch = &lt;21&gt;; vfront-porch = &lt;21&gt;; hsync-len = &lt;10&gt;; //水平同步信号 vsync-len = &lt;3&gt;; hsync-active = &lt;0&gt;; //hync 极性控制 置 1 反转极性 vsync-active = &lt;0&gt;; de-active = &lt;0&gt;; //DEN 极性控制 pixelclk-active = &lt;0&gt;; //dclk 极性控制 swap-rb = &lt;0&gt;; //设 1 反转颜色 swap-rg = &lt;0&gt;; swap-gb = &lt;0&gt;; 背光部分在 rk3288-tb_8846.dts 中还需要打开 mipi 相关的通道 并 配置背光相关的信息。首先根据这颗背光 IC 的 datasheet我们了解到 EN 拉高时背光使能，拉低时背光禁能; FB 接受反馈信号，动态控制背光亮度我们知道这颗背光芯片有两种调光方式一是 EN 输入 PWM 信号进行调光二是 EN 使能后，通过 FB 获得反馈信号进行调光。根据我们的原理图BL_EN 是普通的 GPIO ，LCDC_BL 是支持 PWM 输出的管脚，所以得知我们硬件采用的是第二种调光方式123456789101112131415161718backlight &#123; compatible = \"pwm-backlight\"; pwms = &lt;&amp;pwm0 0 25000&gt;; //在这里配置采用的是 pwm0 还是 pwm1 brightness-levels = &lt;255 254 253 252 251 250 249 248 247 246 245 244 243 242 241 240 239 238 237 236 235 234 233 232 231 230 229 228 227 226 225 224 223 222 221 220 219 218 217 216 215 214 213 212 211 210 209 208 207 206 205 204 203 202 201 200 199 198 197 196 195 194 193 192 191 190 189 188 187 186 185 184 183 182 181 180 179 178 177 176 175 174 173 172 171 170 169 168 167 166 165 164 163 162 161 160 159 158 157 156 155 154 153 152 151 150 149 148 147 146 145 144 143 142 141 140 139 138 137 136 135 134 133 132 131 130 129 128 127 126 125 124 123 122 121 120 119 118 117 116 115 114 113 112 111 110 109 108 107 106 105 104 103 102 101 100 99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0&gt;; default-brightness-level = &lt;200&gt;; enable-gpios = &lt;&amp;gpio7 GPIO_A2 GPIO_ACTIVE_HIGH&gt;; //BL_EN 背光使能管脚 &#125;; LCD 初始化序列 cmds最后如果有初始化序列的，打开之前的 screen-init = &lt; 1 &gt; ，并且填充初始化序列1234567891011121314## 屏初始化序列disp_mipi_init_cmds: screen-on-cmds &#123; compatible = &quot;rockchip,screen-on-cmds&quot;; /*rockchip,cmd_debug = &lt;1&gt;; rockchip,on-cmds1 &#123; //指的是一条初始化命令 compatible = &quot;rockchip,on-cmds&quot;; rockchip,cmd_type = &lt;LPDT&gt;; //命令是在 low power（LPDT）还是 high speed（HSDT）下发送 rockchip,dsi_id = &lt;2&gt;; //选择通过哪个mipi发送 0==》单mipi0 1==》mipi1 2==》双mipi0+1 rockchip,cmd = &lt;0x05 0x01&gt;; //初始化命令 //第一个字节 DSI 数据类型; 第二个字节为 LCD 的 CMD; 后面为指令内容 rockchip,cmd_delay = &lt;0&gt;; &#125;; */&#125;; 值得一讲的是 cmd，一般屏厂或者FAE都会给出初始化序列。比如这里我拿到的是 MTK 平台的 LCD 初始化代码：1234data_array[0]=0x00043902;data_array[1]=0x8983FFB9;dsi_set_cmdq(&amp;data_array, 2, 1);MDELAY(10); 分析得知array[0] 中 04 代表要传输的字节数，3902 代表传输的是长包数据//MTK平台 3900 代表不传值 3905 表示传一个数据 3902 表示传多个数据array[1] 中的参数全部为传输的参数，而且正确的传参数据为 B9 FF 83 89所以移植到 RK 平台就是：12345678rockchip,on-cmds1 &#123; compatible = &quot;rockchip,on-cmds&quot;; rockchip,cmd_type = &lt;LPDT&gt;; rockchip,dsi_id = &lt;0&gt;; rockchip,cmd = &lt;0x39 0xB9 0xFF 0x83 0x89&gt;; //0x39 为 DSI 数据类型、 0xB9 为LCD CMD、后面为参数 rockchip,cmd_delay = &lt;10&gt;;&#125; 我们根据 这块 lcd 的 规格书，也能够验证结果初始化命令参数的正确性： 另外值得一说的是大部分初始化代码的最后一般都是 exit_sleep 和 display_on。1234567891011121314rockchip,on-cmds15 &#123; compatible = &quot;rockchip,on-cmds&quot;; rockchip,cmd_type = &lt;LPDT&gt;; rockchip,dsi_id = &lt;0&gt;; rockchip,cmd = &lt;0x05 dcs_exit_sleep_mode&gt;; rockchip,cmd_delay = &lt;120&gt;; &#125;; rockchip,on-cmds16 &#123; compatible = &quot;rockchip,on-cmds&quot;; rockchip,cmd_type = &lt;LPDT&gt;; rockchip,dsi_id = &lt;0&gt;; rockchip,cmd = &lt;0x05 dcs_set_display_on&gt;; rockchip,cmd_delay = &lt;100&gt;; &#125;; 这里 dcs_exit_sleep_mode dcs_set_display_on 在 drivers/video/rockchip/transmitter/mipi_dsi.h 中有定义12#define dcs_set_display_on 0x29#define dcs_exit_sleep_mode 0x11 所以表示的 0x05 0x11 表示的含义为，短包传输 发送 exit_sleep_mode 命令这两个命令后的延时**相当重要**！！务必确认好。 打开 config根据 RK 手册中的要求make menuconfig打开三个宏这里也可以顺手把 LVDS 的相关代码给关掉 检查电压先不要接上屏，编译完代码烧录后开机。检查原理图上各个供电管脚的电压（DVDD、IOVDD 是否为 3.3V，VDD_LCDA 是否为 5-10V，VDD_LCDK 是否为 0V），确认电压正常后，关机，上屏，结合 开机log 看能否正常开机。 调试顺序背光有没有亮背光没亮的话确认一下接上屏的时候，量一量 VDD_LCDA 的电压为多少（串联电路大概能到 20V+）没有就去检查背光电路供电电压和 backlight 相关的配置 开机 以及 从休眠状态唤醒 都没有显示内容之所以这样说是因为可能存在 休眠唤醒 能显示，但 开机 无法显示的情况如果两种情况都没有显示，那么很有可能是 cmds 或者 timing 仍然有问题 用示波器量波形看 DCLKP 的频率为多少，是否为 clock-frequence 中设置的（可能实际的会略低一点） 量 RST 是否有一个 高-低-高 的变化，没有则是 rst 设置的触发方式可能反了 在 RST 高低高后会开始传输数据，量 lanes 是否有数据输出。抓取数据需要专门的仪器，我们用示波器大致看看有没有数据输出就够了。 我在调试的时候就发现 lane 一直为低电平，没有数据传输，然后采取量 RST 发现唤醒屏后待到屏幕快灭了 RST 才会被拉高。跟代码发现 RK 平台的实现是12！你设置的触发电平你设置的触发电平 但是我设置的触发电平是 低电平有效 ACTIVE_LOW即12！ACTIVE_LOWACTIVE_LOW 即先高再低，所以是错的，改为 ACTIVE_HIGH 后正常。但是虽然填的是 ACTIVE_HIGH ，但是应该还是属于低电平有效的，这里是 RK 平台 driver 的实现有问题。修改后 lane 有数据传递了。 但是有数据传递仍然怎么样都没有显示。这时候有极大可能是 cmds 有问题。下面着重讲一下我 cmds 碰到的问题。 我碰到的 cmds 问题我当时拿到 MTK 平台参数的时候，有的参数超过了 32个字节（有个有36个字节，有个有39个字节），完成 dtsi 中 cmds 编写后烧录，板子跑飞，空指针异常。发现传递 这个超长 参数的时候有内存溢出情况。于是跟代码发现 dcs_cmd.cmds 的大小为 int cmds[32]，所以擅自想当然的将包拆成了 39 = 28+11，还将其中的延时设置为 0 。这样当然是不行的。但是一切都是基于这个拆了包的 cmds 来调，走了不少弯路。后来一切的其他参数都确定没问题了。于是去联系原厂的工程师，说平台参数大小有限制，咨询拆包是否可行。他们说建议修改 cmds[32] 改成了 cmds[400] 。修改后发现屏幕终于点亮了。终于点亮了。点亮了。 问题集锦RK 手册中已经有相当一部分很有参考价值的了。这里的一部分是自己碰到的，有的是查资料时候收集到觉得很有意义的，都放这里了。 我调试中碰到的问题 在点亮屏后刚开始有开机 logo 闪烁，向右偏移了近半个屏幕的长度，等问题。重新确认 clock-frequence 后发现少打了一个 0 。修改后解决了 闪烁，大偏移 的问题。 最初偏移还是有点大，如下图。稍微降低 hs_clk ，由 504 降低到 496 解决。 垂直方向会显示多一点内容，如下图。调整 VFP 后解决，将 VFP 增大为 15 。 下面会有黑边，如下图。稍微增大 VBP 后解决，将 VBP 增大为 15。 开机 android 最左边会被裁剪一部分，如下图。增大 HBP 后解决，将 HBP 由 10 增加到 30。至此屏幕已完美显示。其他一些杂散的需要确认的内容是否有framebuffer輸出，要是改動了display這塊的clk很有可能沒有buffer輸出的，可以通過cat /dev/graphyics/fb0查看有沒有輸出字符。（我是通过google 插件 vysor 直接连接开发板看有没有内容显示，windows 平台也可以用 total control 软件来看）数据为 8 位、16位数据为 8 位 和 16 位 的时候，写命令和数据的函数要注意变化。会发现 如果 参数为 8 位的时候， 传输模式会自动由 LP 模式 变成 HS 模式。显示偏移、图像位置偏差timing 中的参数设置有误。优先确认。看着图像调节前扫、回扫进行左右上下移动白屏随机出现白屏有可能是静电问题，把LCD拿到头发上擦几下，如果很容易出现白屏那肯定就是静电问题了。另外一个在有Backend IC的情况下，也有可能bypass没处理好。屏在进出睡眠或者显示过程中白屏sleep out（0x11）和 display on（0x29）之间需要 mdelay（120ms）左右。屏休眠唤醒后四周有白色痕迹检查下是不是屏的供电电源在休眠时没有关闭,导致屏上的电荷无法释放, 产生这种极化现象。花屏timing 中的参数设置有误。优先确认。花屏 还有可能是总线速度有问题开机就花屏最简单的解决方式是，在 Init 结束的地方加一个刷黑屏的功能。也可以在睡眠函数里加延时函数。屏幕抖动测时序，延时不足。适当地降低 clk，或者调节下 Vcom，确保屏供电电源波纹不大。屏幕闪动通过调节电压来稳定，一般调节的电压为VRL、VRH、VDV和VCM调节对比度VRL、VRH、VDV和VCM，这些电压也可以用来调节亮暗（对比度）也可以通过调节Gamma值来实现，要调节的对象为 PRP、PRN、VRP、VRN 等确认有没有 framebuffer 输出要是改动了display这块的clk很有可能没有buffer输出的，可以通过cat /dev/graphyics/fb0 查看有没有输出字符如果有说明是 mipi 还没有调通，如果没有说明是 fb 有问题图像颜色不正常可能时钟型号极性反了可能 VCOM 调节不正常进行 GAMMA 校正 EDP 屏调试问题汇总确保上电时序正确,先将 uboot-logo-on=0,打印 kernel log。 hw lt err检查下硬件连线,edp 屏的连接线上传输的高速的差分信号,所以对线的要求很高,要求线要包地,而且不能太长。如果硬件上的问题排查了,仍然有这样的错误,可以在 rk32_dp.c 文件中手动修改代码,得到想要的 lane 数和 lane speed:rk32_edp_probe 函数中可以修改这两个变量值:edp-&gt;video_info.link_rate= LINK_RATE_2_70GBPS;//LINK_RATE_1_62GBPSedp-&gt;video_info.lane_count = LANE_CNT4;//LANE_CNT2 max link rate:1.62Gps max number of lanes:4说明读取屏的 lane 数和 lane speed 正常,那么可以与屏的 datasheet 中对比下,看读取的结果是否是正确的,如果是正确的试着降低 dclk 的值。如果不正确可以在rk32_dp.c 文件中这样修改试下:1234567891011121314static int rk32_edp_init_training(struct rk32_edp *edp)&#123; int retval; /* * MACRO_RST must be applied after the PLL_LOCK to avoid * the DP inter pair skew issue for at least 10 us */ rk32_edp_reset_macro(edp); retval = rk32_edp_get_max_rx_bandwidth(edp, &amp;edp-&gt;link_train.link_rate);++ retval = rk32_edp_get_max_rx_lane_count(edp, &amp;edp-&gt;link_train.lane_count); edp-&gt;link_train.link_rate = LINK_RATE_2_70GBPS;//LINK_RATE_1_62GBPS edp-&gt;link_train.lane_count = LANE_CNT4;//LANE_CNT2 ...&#125; edp pll locked1234[ 1.336855] rk32-edp rk32-edp: edp pll locked[ 1.337492] rk32-edp rk32-edp: max link rate:1.62Gps max number of lanes:4[ 1.343428] rk32-edp rk32-edp: hw lt err:6[ 1.343438] rk32-edp rk32-edp: link train failed! 屏的转接排线长了,后面改短了就可以了 RGB 屏调试问题汇总8 位 串口屏蓝色无法正常显示调节 out_face 为 out_s888dumy,红色和绿色可以显示,但颜色位置是颠倒的,后面看 TRM发现 RK 平台发送红绿蓝的格式为 BGR+DUMMY屏接收的格式可能为 dummy+RGB,这样主控端发送的 B 就被认为是 dummy 舍弃了,然后只剩下 RG,B 接收的是 dummy 数据为空,后面将格式改为 dummy+rgb 后成功显示全部颜色 3128 平台 rgb 屏插入 hdmi 后 RGB 屏显示异常插入 hdmi 后系统的时钟输出直接供给 HDMI 模块,显示 720p 的数据, RGB 屏的 clk 和数据通过一个 Scaler 模块,输出的 clk 值可能有所降低,可以调试屏的 clk 参数。 spi 接口屏需要发初始化命令，代码添加位置可以在 rk_disp_pwr_enable 这个函数结束处添加屏的初始化命令。如果有下电命令的话,要在 rk_disp_pwr_disable 开始处添加。 初始化命令点亮屏，代码添加位置初始化命令添加的地方应该在 rk3288_lcdc_open 函数中的 clk 打开后添加。 感谢这段时间基本上把有些 Mipi 移植和 RK 平台 LCD 移植的文章看遍了。以下文章很有帮助。本文的问题集锦部分有一部分是将以下文章中的内容搜罗过来的：android lcd調試 高通平台lcd調試深入分析總結（mipi和rgb接口） 最后，得感谢这段时间师兄 Baker 和 Nick 的指点。还有网上两位 RK 刘哥和“llg”和“勇气” 的指点。收益颇丰。谢谢谢谢！","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android5.1 RK3288 LCD Mipi 初始化长包数据规范问题","slug":"Android_Driver/Debug/[Android5.1][RK3288] LCD Mipi 初始化长包数据规范问题","date":"2016-12-31T15:33:05.000Z","updated":"2018-11-08T02:50:55.155Z","comments":true,"path":"2016/12/31/Android_Driver/Debug/[Android5.1][RK3288] LCD Mipi 初始化长包数据规范问题/","link":"","permalink":"http://iyounix.com/2016/12/31/Android_Driver/Debug/[Android5.1][RK3288] LCD Mipi 初始化长包数据规范问题/","excerpt":"","text":"目录[TOC] 先说问题和结论问题首先是因为我出现了这样的 Bug：我的 cmds7 明明填充的是 LP 模式，但是打印中却说是 HS 模式。我在一个帖子中看到说 cmds 参数 不能为 8 和 16 的情况。于是错误地将地将两者联系起来，认为参数为 8 或者 16 的情况下，LP 模式会被转换成 HS 模式。于是希望跟着代码一探究竟。 真相但是实际上两者是没有关联的。真相是其实是可以传递 8 字节 和 16 字节的参数的。 跟踪代码发现打印 LP mode 和 HS mode 这个输出信息的代码是根据 reg[0] 来判断的1MIPI_DBG(&quot;%d command sent in %s size:%d\\n&quot;, __LINE__, regs[0] ? &quot;LP mode&quot; : &quot;HS mode&quot;, liTmp); 我出现这种情况的原因，是因为擅自错误地将一个 36 字节的参数 拆分成 28 和 8 。而后面 8 字节 cmds 的首字节 为 0x00。也就是 reg[0] = 0x00 ，所以会输出 HS mode。 正文假设我们有 8 个参数，那么 cmds 实际为 { 0x39,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88 }cmd_len = length / sizeof(u32) = 9在 video/rockchip/screen/lcd_mipi.c 中的 rk_mipi_screen_cmd_init 可以看到是调用dsi_send_packet 这个函数来进行参数传递12345678910111213141516171819//... dcs_cmd = list_entry(screen_pos, struct mipi_dcs_cmd_ctr_list, list); len = dcs_cmd-&gt;dcs_cmd.cmd_len + 1; // len = 9 + 1 = 10 for (i = 1; i &lt; len ; i++) &#123; // 将 dcs_cmd-&gt;dcs_cmd.cmds 中的 9 个参数赋值给 cmds cmds[i] = dcs_cmd-&gt;dcs_cmd.cmds[i-1]; //cmds[1-9] 被 dcs_cmd.cmds[0-8] 赋值 &#125; MIPI_SCREEN_DBG(\"dcs_cmd.name:%s\\n\", dcs_cmd-&gt;dcs_cmd.name); if (dcs_cmd-&gt;dcs_cmd.type == LPDT) &#123; cmds[0] = LPDT; //cmds[0] 表示传输数据模式的标志 1 if (dcs_cmd-&gt;dcs_cmd.dsi_id == 0) &#123; MIPI_SCREEN_DBG(\"dcs_cmd.dsi_id == 0 line=%d\\n\", __LINE__); //调用这个函数进行 mipi 通信 //这里的 cmds 中实际有 10 个字节 // 0 为 数据类型的标志 1 // 1-9 为参数 cmds[1] = 0x39 数据类型为长包数据 cmds[2-9] 为屏幕初始化参数 // len 为 10 dsi_send_packet(0, cmds, len); &#125;//... 跟代码发现在 video/rockchip/transmitter/mipi_dsi.c 中123456789101112131415int dsi_send_dcs_packet(unsigned int id, unsigned char *packet, u32 n) &#123; struct mipi_dsi_ops *ops = NULL; //printk(\"dsi_send_dcs_packet-------id=%d\\n\",id); if(id &gt; (MAX_DSI_CHIPS - 1)) return -EINVAL; ops = dsi_ops[id]; if(!ops) return -EINVAL; if(ops-&gt;dsi_send_dcs_packet) ops-&gt;dsi_send_dcs_packet(ops-&gt;dsi, packet, n); return 0;&#125;#ifdef CONFIG_MIPI_DSIEXPORT_SYMBOL(dsi_send_dcs_packet); ops-&gt;dsi_send_dcs_packet 这个实现是在 ops-&gt;的 dsi_send_dcs_packet究其根源的实现是在kernel/drivers/video/rockchip/transmitter/rk32_mipi_dsi.c的 rk32_mipi_dsi_send_packet12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//arg 是要传输的通道，默认为 0//cmds 就是 lcd dtsi 中的 cmds // 这里假设为&#123; 0x39,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88 &#125;//length 就是 cmds 的长度 // 这里为 10static int rk32_mipi_dsi_send_packet(void *arg, unsigned char cmds[], u32 length)&#123; struct dsi *dsi = arg; unsigned char *regs; u32 type, liTmp = 0, i = 0, j = 0, data = 0; if (rk32_dsi_get_bits(dsi, gen_cmd_full) == 1) &#123; MIPI_TRACE(\"gen_cmd_full\\n\"); return -1; &#125; regs = kmalloc(0x400, GFP_KERNEL); if (!regs) &#123; printk(\"request regs fail!\\n\"); return -ENOMEM; &#125; memcpy(regs, cmds, length); //regs 现在为 cmds 中的内容了 liTmp = length - 2; //liTmp = 10 - 2 = 8 type = regs[1]; //type = regs[1] = cmds[1] = 0x39 （采用长包模式传输） switch (type) &#123; //0x39 即 DTYPE_DCS_LWRITE //... case DTYPE_DCS_LWRITE: rk32_dsi_set_bits(dsi, regs[0], dcs_lw_tx); // 设置标志位，根据 regs[0] 设置寄存器 dcs_lw_tx 中的标志 for (i = 0; i &lt; liTmp; i++) &#123; // 0-7 依次给 regs[0]-regs[7] 赋值，这8个值便是屏幕初始化的内容 // &#123;0x11,0x22,0x33,0x44,0x55.0x66,0x77,0x88&#125; regs[i] = regs[i+2]; &#125; for (i = 0; i &lt; liTmp; i++) &#123; j = i % 4; //0 1 2 3 0 1 2 3 data |= regs[i] &lt;&lt; (j * 8); //data | (regs[0] &lt;&lt; 0) //data | (regs[1] &lt;&lt; 8) //data | (regs[2] &lt;&lt; 16) //data | (regs[3] &lt;&lt; 24) // 8 个字节的内容被组合成两个 data // 0x44332211 0x88776655 if (j == 3 || ((i + 1) == liTmp)) &#123; //每当组成的 data 满了的时候，或者是所有的参数都填充了的时候 if (rk32_dsi_get_bits(dsi, gen_pld_w_full) == 1) &#123; MIPI_TRACE(\"gen_pld_w_full :%d\\n\", i); break; &#125; rk32_dsi_set_bits(dsi, data, GEN_PLD_DATA); MIPI_DBG(\"write GEN_PLD_DATA:%d, %08x\\n\", i, data); data = 0; //清空 data，开始下个 data 的传输 &#125; &#125; data = type;//data = 0x39 data |= (liTmp &amp; 0xffff) &lt;&lt; 8; //0x0839 //如果是 16 字节的话为 0x1039（16 的16进制是 0x10） break; //... &#125; MIPI_DBG(\"%d command sent in %s size:%d\\n\", __LINE__, regs[0] ? \"LP mode\" : \"HS mode\", liTmp); //这里就会打印究竟是什么模式来传输 //reg[0] 正是代表了 屏幕参数初始化的第一个字节！ //它的含义是这块屏 IC 的 CMD！ //0x11 0x22 0x33 0x44... 0x88 表示执行 0x11 这个 CMD，参数为 0x22 到 0x88 //那为什么 8 个字节就会变成 HS mode 呢， //看我所传输的 cmds7 可以发现要传输的第一个参数为 0x00，所以被判别为 HS mode MIPI_DBG(\"write GEN_HDR:%08x\\n\", data); rk32_dsi_set_bits(dsi, data, GEN_HDR); i = 10; while (!rk32_dsi_get_bits(dsi, gen_cmd_empty) &amp;&amp; i--) &#123; MIPI_DBG(\".\"); udelay(10); &#125; udelay(10); kfree(regs); return 0;&#125; 至此，疑问解决了。看 LCD 的 datasheet 也可以发现，像之前所说的，在 commond mode 的时候，这个参数，也就是 屏IC 的 CMD，是不会为 0x00 的。只有在 video mode 下才可能为 0x00。 而参数为 8 字节 和 16 字节 其实都可以，只要不超过 struct dsc_cmd 中定义的大小 400 ，就够了。","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"Android5.1 RK3288 Framebuffer 设备驱动","slug":"Android_Driver/Driver/[Android5.1][RK3288] Framebuffer 设备驱动","date":"2016-12-31T15:33:05.000Z","updated":"2018-11-08T02:32:44.077Z","comments":true,"path":"2016/12/31/Android_Driver/Driver/[Android5.1][RK3288] Framebuffer 设备驱动/","link":"","permalink":"http://iyounix.com/2016/12/31/Android_Driver/Driver/[Android5.1][RK3288] Framebuffer 设备驱动/","excerpt":"","text":"概念FrameBuffer 的意思是，帧缓冲。Frame 帧：你所看到的屏幕的图像，或者在一个窗口中的图像，就叫一帧。Buffer 缓冲：一段RAM，用来暂存图像数据，这些数据会被直接写入到显示设备。帧缓冲就相当于介于 图形操作 和 图像输出中间的一个中间人。将程序对图形数据的处理操作，反馈到显示输出上。显卡（显存中的数据） 帧缓冲（程序对其中的数据进行处理） 显示器（输出图像）帧缓冲可用于，实现原先视频卡并不支持的分辨率:显卡可能并不支持你当前某个更大分辨率的显示器，但是可以通过帧缓冲获取显卡的显存中的数据，处理之后，实现更大的分辨率的图像，然后将数据直接输出到显示器上。 驱动分析1.Framebuffer帧缓冲设备1) 重要结构Framebuffer 驱动在 Linux 中是标准的显示设备的驱动。 对于 **PC 系统**，它是显卡的驱动 ； 对于**嵌入式SOC处理器系统**，它是 LCD 控制器或者其他显示控制器的驱动。 同时该设备属于一个字符设备，在文件系统中设备节点是 /dev/fbx。 一个系统可以有多个显示设备，最常见的有 /dev/fb0 /dev/fb1 ,如果在/dev目录下没有发现这个文件，那么需要去修改 Linux 系统中相应的配置脚本。 在**安卓系统**中，Framebuffer设备驱动的主设备号通常为 29 ，次设备号递增而生成。 在此，我借用某内核驱动大牛GQB做的驱动框架图做分析，如有侵权，请联系我删除，谢谢！ Framebuff的结构框架和实现： 我们可以先来看看在framebuffer驱动框架中相关的重要数据结构：123456789101112131415161718struct fb_ops &#123; struct module *owner; //检查可变参数并进行设置 int (*fb_check_var)(struct fb_var_screeninfo *var, struct fb_info *info); //根据设置的值进行更新，使之有效 int (*fb_set_par)(struct fb_info *info); //设置颜色寄存器 int (*fb_setcolreg)(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp, struct fb_info *info); //显示空白 int (*fb_blank)(int blank, struct fb_info *info); //矩形填充 void (*fb_fillrect) (struct fb_info *info, const struct fb_fillrect *rect); //复制数据 void (*fb_copyarea) (struct fb_info *info, const struct fb_copyarea *region); //图形填充 void (*fb_imageblit) (struct fb_info *info, const struct fb_image *image);&#125;; 这个结构体记录了这个设备驱动的全部相关的信息，其中就包括设备的设置参数，状态，还有对应底层硬件操作的回调函数。在Linux中，每一个帧缓冲设备都必须对应一个fb_info，fb_info在/linux/fb.h中：123456789101112131415struct fb_info &#123; int node;//驱动的次设备号 struct fb_var_screeninfo var; /* Current var 结构体成员记录用户可修改的显示控制器参数,包括屏幕分辨率还有每个像素点的位数 */ struct fb_fix_screeninfo fix; /* Current fix */ struct fb_videomode *mode; /* current mode */ struct fb_ops *fbops; struct device *device; /* This is the parent */ struct device *dev; /* This is this fb device */ char __iomem *screen_base; /* Virtual address */ unsigned long screen_size; /* Amount of ioremapped VRAM or 0 */ ……&#125;; 2) fbmem.c和其它的内核代码中的字符驱动类似，同样，如果你要使用这个驱动，你必须去注册这个设备驱动。显示驱动的分析都是由 drivers/video/fbmem.c 开始 。我们可以发现 fbmem.c 里定义 register_framebuffer/unregister_framebuffer 由分析可以得知，drivers/video/rockchip/lcdc/rk3288_lcdc.c 中的 probe 函数(rk3288_lcdc_probe)中有调用 rk_fb_registerdrivers/video/rockchip/rk_fb.c 中的 rk_fb_register 调用 register_framebuffer注册了一个平台总线设备的驱动程序。 编写framebuffer用户态程序需要以下步骤:1、初始化framebuffer2、向framebuffer写数据3、退出framebuffer1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;#define RGB(r,g,b)((r&lt;&lt;16)|(g&lt;&lt;8)|b)#define WIDTH 1280#define HIGHT 1024static int Frame_fd ;static int *FrameBuffer = NULL ;static int W , H ;//写framebufferint Write_FrameBuffer(const char *buffer);int main(void)&#123; 1、设置长宽，打开fb设备 W = 1024 ; H = 768 ; Frame_fd = open(\"/dev/fb0\" , O_RDWR); if(-1 == Frame_fd)&#123;perror(\"open frame buffer fail\");return -1 ; &#125; 2、对framebuffer进行内存映射mmap //头文件 &lt;sys/mman.h&gt; //函数原型：void* mmap(void* start,size_t length,int prot,int flags,int fd,off_t offset); //start：映射区的开始地址，设置为0时表示由系统决定映射区的起始地址。 //length：映射区的长度。//长度单位是 以字节为单位，不足一内存页按一内存页处理 //prot：期望的内存保护标志，不能与文件的打开模式冲突。是以下的某个值，可以通过or运算合理地组合在一起 //flags:相关的标志，就跟open函数的标志差不多的，自己百度去查 //fd：有效的文件描述词。一般是由open()函数返回，其值也可以设置为-1，此时需要指定flags参数中的MAP_ANON,表明进行的是匿名映射。 //off_toffset：被映射对象内容的起点。 //PROT_READ //页内容可以被读取 //PROT_WRITE //页可以被写入 //MAP_SHARED //与其它所有映射这个对象的进程共享映射空间。对共享区的写入，相当于输出到文件。直到msync()或者munmap()被调用，文件实际上不会被更新。 FrameBuffer = mmap(0, 1280*1024*4 , PROT_READ | PROT_WRITE , MAP_SHARED , Frame_fd ,0 ); if(FrameBuffer == (void *)-1)&#123;perror(\"memory map fail\");return -2 ; &#125; 3、对framebuffer写数据 char buffer[WIDTH*HIGHT*3]; //我们要写入的数据 while(1) &#123; Write_FrameBuffer(buffer); printf(\"count:%d \\n\" , count++); &#125; 4、退出framebuffer munmap(FrameBuffer , W*H*4); //解除内存映射 close(Frame_fd); //关闭文件描述符 return 0 ;&#125;//写framebufferint Write_FrameBuffer(const char *buffer)&#123;int row , col ;char *p = NULL ; //遍历分辨率1024*1280的所有像素点for(row = 0 ; row &lt;1024 ; row++)&#123; for(col = 0 ; col &lt; 1280 ; col++)&#123; if((row &lt; H) &amp;&amp; (col &lt; W))&#123; p = (char *)(buffer + (row * W+ col ) * 3); //转RGB格式 FrameBuffer[row*1280+col] = RGB((unsigned char)(*(p+2)),(unsigned char)(*(p+1)),(unsigned char )(*p));&#125; &#125;&#125;return 0 ;&#125; 至此，我们的framebuffer上层调用程序就写完了，当然这个程序你看不到什么图片，只能看到一块被映射的区域，然后printf不断的在打印数据。 如果你有兴趣，可以写一个图片数据进去，这时候要用到bmp，yuyv格式的图片知识，让图片可以显示在屏幕上.","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"2016年总结","slug":"Life/InnerPath/16-12-242016年总结","date":"2016-12-24T06:05:03.000Z","updated":"2018-11-08T01:30:40.291Z","comments":true,"path":"2016/12/24/Life/InnerPath/16-12-242016年总结/","link":"","permalink":"http://iyounix.com/2016/12/24/Life/InnerPath/16-12-242016年总结/","excerpt":"","text":"今年的心路历程还是十分曲折的。正好今天是平安夜，在今天写下这一年的总结得失，再稍稍展望一下明年。今年的心路总得来说，就是想得太多，做的太少，太过于浮躁了。 还是先回头看一看之前定的 ToDoList 完成的如何了吧。 关于工作写今年写了67 篇技术文档，翻译了 2 篇 外文，创作了 12篇 个人文章。技术文档大在 CSDN 大部分是关于 RockChip 平台的 Android 驱动分析 以及 Linux 中的一些技巧。个人文章中，每三个月一篇共 5 篇是关于总结反思规划的，1 篇书评，余下的是参加一些展会、沙龙等产生的一些收获。 CSDN 博客从年初 1000 左右达到了 5 万阅读量：http://blog.csdn.net/dearsq 做回顾一下今年做过得案子： 一月还是继续做 NFC。协助客户在 海思、高通、MTK 平台上移植 NFC。产出 4 篇 NFC 的技术文档，包括驱动移植、App 开发到客户支持流程。 二月三月做 RK XM6321 的 Android 手表的 App 开发。基于 Google 的计步算法完成了一个计步 App 的开发。 四月五月做展讯 SC7731 的平板。移植了 LCD（Mipi）、TP、G-Sensor、M-Sensor、Gyro-Sensor、Camera。产出 2 篇 Mipi LCD 调试移植技术文档。 五月到十二月专注于瑞芯微 RK 的设备。调试了一个月的 RK3288 TVBOX，之后一直是做 VR 一体机。在 RK 平台调试了 LCD、Sensor、Wifi、TypeC、HDMI。主要产出 3 篇 Mipi LCD 、 1 篇 Wifi 、 1 篇 TypeC 的技术文档。 同时九月到十二月份了解了 VR 应用的开发方式。产出了 1 篇 VR 应用开发入门文档，2 篇 OpenGL 学习记录。 最大的收获可能是思维方式的转变：编程语言只是工具，应该以项目驱动，需要用什么就必须去了解什么。对于 Android 嵌入式工程师而言，了解 Framework 的知识以及 App 开发对深入理解 Android 嵌入式系统也有很大的帮助。 关于生活读今年一共读了 18 本书。年初定了十二本小说硬指标： 黑客与画家 偷影子的人 这么慢，那么美 白夜行 岛上书店 当我跑步时，我在说些什么 神们自己 天才在左，疯子在右 蔡康永的说话之道 特立独行的猫,不要让未来的你,讨厌现在的自己 格局逆袭 Stroy of Your Whole Life 这个值得一提的是，阅读方式自从 Kindle 换成 微信读书，效率极大提高。在 11 月开始到现在，一共还读了 9 本书：侦探推理科幻： 无人生还 工具类： 如何高效阅读 刻意练习 微表情心理学 via 哈里 巴尔肯 传记鸡汤类： 少有人走的路 via 腾讯是怎么长大的 via 吴晓波 周鸿祎：人生就是不停的战斗 via 陈润 小说类： 动物农场 via 乔治 奥威尔 孤独的人都要吃饱 via 张佳玮 其中比较好的值得推荐的如下： 偷影子的人（温情小说） 白夜行（侦探推理类） 神们自己（科幻小说） 刻意练习（工具学习） 腾讯是怎么长大的（传记简介） 缺点在于之前说了需要完成 12 份书评，然而实际上只完成 1 篇。读是最基本的，思是必须要养成的，写不仅是强迫自己去思的手段，也是一种很好的整理自己所获得的输入内容的一种方式。写是必须的，明年要坚持将这些摄入的知识咀嚼并输出。 炼Keep 上一共做了 2840 分钟，上半年还有在每周锻炼四五次，下半年基本就两周一次了。小肚腩以可见的速度鼓起来，也实属无奈。不过是我也并不担心这个，时间太有限了，还是要抓紧时间将技术能力提升起来，其次利用空闲时间保证体质不能太差，否则会影响工作效率。 杂游泳 花了小半年，学会了。比较有成就感。理财 拿 5000 出来玩，上半年赚了 300 ，下半年亏了 100 。这个东西比较耗费精力，上半年买股票型基金，每天都会情不自禁的去看趋势去分析，下半年图省心，买的债券型基金，正好特朗普上台，人民币大跌，小亏了 100。关于理财，也想明白了，这个还是需要刻意学习，但是不是现在。现阶段，重点在于学会预算规划便足够了。 关于她缘份这个东西，其实我是不相信的，我向来认为一切都是自己争取过来的。但是这个真的挺巧，年中的时候，她工作需要开始向我咨询我行业内的一些事情，慢慢有了很多交集。她是个认准了就一定要去干的蠢货，彼此觉得相熟恨晚，加之价值观、人生观、世界观一切都无比契合，于是就这样自然而然地在一起了。这也算是 2016 中意外的收获吧。 恩，很开心不再只身一人，不论是 2017 还是之后，接下来的路，我们将携手同行。","categories":[],"tags":[{"name":"InnerPath","slug":"InnerPath","permalink":"http://iyounix.com/tags/InnerPath/"}]},{"title":"VR创投会","slug":"Life/InnerPath/16-10-30VR创投会","date":"2016-10-30T14:05:00.000Z","updated":"2018-11-08T01:30:40.291Z","comments":true,"path":"2016/10/30/Life/InnerPath/16-10-30VR创投会/","link":"","permalink":"http://iyounix.com/2016/10/30/Life/InnerPath/16-10-30VR创投会/","excerpt":"","text":"这周末去参加了一下 “VR 创投寻鹰会”，听迅雷创始人陈皓分享了一下他的投资价值观，收获满满，这里做一个总结。 投资战略投资和创业一样，找人找钱找方向。首先是决定哪个领域，一定要聚焦。只专注于投自己擅长和了解的领域。其次是决定赛道，任何领域都可以细分为很多赛道。比如 VR头盔来讲，VR头盔就是手机厂商的赛道，他们做这个太容易。首先，产品之间有很好的整合，然后它同时还有很好的渠道，说白了，这个赛道就不属于我们这个创业企业的，这个赛场当然也不是我们早期投资人的。所以，定了这个领域之后，你必须要看它的赛道。 感想：专注。 又比如投人工智能领域，人工智能领域其实在很多领域都有非常重要的作用，其实主要看4个赛道，机器人、汽车自动驾驶、金融、医疗，这也是进一步聚焦。对于投资者而言，选好了领域和选好赛道，接下来就是聚焦，把这个赛道的所有玩家都尽可能筛选。因为如果因为没有筛选完全，不小心投的是三四名，那这个风险就相当大。 感想：历史只记得冠军。 投资战术——是否刚需刚需刚需就是 极大降低成本、极大提升效果、极大提高用户体验举例：迅雷，提升下载速度 5-10倍。搜索引擎，提升知识获取方式千万倍，原来图书馆等，现在很方便的搜索。机器人，工人工资 4 个人一年 20 万，一个机器人只需要 10 万 + 每年极少维护费。ipad，极大提升效果，没有一个消费产品能如此轻易就让人掌握。智能手表，不够刚需，测睡眠质量无用、需要每日充电。有人会说手机不也不方便要充电等，但是它极大改变了人们生活方式，是刚需。 只要这东西刚需，所有的问题都不是问题，只要这东西不刚需，那所有的问题就都是问题。 不需要担心产品好不好，只要是刚需，就不是问题。有羊毛出在猪身上的潜力。但是如果是刚需，那也一定是兵家必争之地。需要用大钱将入口把握住。 刚需不高频举例：结婚、装修。不是高频，意味着没有成为入口的这种潜力，但这个东西是刚需，那就是说要每一单都要做好，每一单都要形成口碑，这里面口碑非常重要，同时每一单必须有非常好的毛利率，每一单都要赚钱。简单讲，因为不是高频的，所以就必须得从这个事本身赚钱。 高频不刚需伪命题，如果不刚需，也不会是高频的。 投资战术——市场几何市场多大（天花板在哪），并且未来的趋势（需求）呢。举例：当年迅雷的趋势就是中国宽带互联网迅速普及的趋势。百度的趋势是网上的信息越来越多了，以前信息少的时候通过分类网站去做，但信息越来越多，就必须得做搜索。蓝领招聘，现在市场有多大用工难什么的，但是这个趋势不对。第一个他只是做工厂的，不是说这个家政保姆。首先，中国现在劳动力成本涨得非常快，美国的工厂在往越南迁，中国以前就是人便宜，但是现在都变了。中国过去的基础设施相对于东南亚国家还比较好，那现在东南亚国家包括印度，还在迅速补齐它的基础设施，而且他还能说英语。你的优势在哪？但是这还是一个小问题，更大的是未来，大家知道自动化设备问题，现在所有的工厂都特别看重，能不能做上新设备，便宜只是一方面，就是说这个成本降低更重要是提高效率。假如我要是苹果，我要在中国整一个代工厂，或者找某个零件，我发现你这工厂全是靠手工，我根本不考虑你，对吧，你做出来的螺丝，每一个都不一样，我这个怎么拧啊。自动化停车场，停车机器人，这个趋势也不对。为什么趋势不对？首先这些东西基本上就在一线城市，但所有的一线城市现在都限高。说白了，要解决停车难的问题根本就不需要停车机器人，只要停车场加价就可以了。当然这是短期的，就是说短期的政府其实是在鼓励这个共享经济，鼓励这种公共交通，不鼓励大家就是短期内的这种做法。长期来讲的话影响就更大了。自动驾驶，大家更多的会选择按需用车，大家就不买车了，他不买车，你建那么多停车场干嘛。未来很多城市停车场都会拆了盖上公园，这是一个很大的趋势。这些例子是说虽然现在这个市场的拉力赛很重要，但是更重要的是，是做这个事是否符合未来的趋势。 投资战术——盈利模式就是必须得一句话说清楚到底怎么赚钱。 投资战术——为什么是你做人人都能做的项目就不是好项目。一般来说，市场上有这样几种情况： 在行业内耕耘了很多年了，我突然发现这个机会，这个是最重要的一种，你有这个行业资源，也有这个行业背景。 有一些特别独有的资源，这些是别人没有的，那这个也有可能。 像徐小平老师看重的情怀，就是我对这个事情撒播过了很长时间，我就要解决这个问题。情怀这也是一个，但如果只是说感兴趣，这就太不充分了。 投资战术——护城河（技术壁垒）通常的护城河有几类，最明显的护城河是是网络效应和规模效应。网络效应举个例子，微信做起来了，阿里的来往，还有网易的易信都出来，但都没声音了。所以如果你做这个产品有网络效应，那你必须要不惜一切代价把它拼命往前推进。除了网络效应还有什么？举个例子，像大疆这种技术领先的，别人新产品刚出来大疆立马出一个新产品，老一代降价40%，技术服务领先。 规模效应是说，如果我们做同一件事，但是我量大，我的单位成本就低，那我就能快速推广。就是说你在护城河那块，你总得要找到一块。大家都知道在中国，特别是在这个互联网的创业，技术创新其实并不多，大多数都是商业模式，商业模式的创新，谁比谁快也只能3个月吧，如果你这个商业模式是没有壁垒的话，那就非常严重，未来会有无数人进来，最后为什么是你，这个就是一个很大的压力。 投资战术总结创业者自省的五个问题： 是否刚需 市场几何 盈利模式 为什么是你 护城河在哪 人工智能领域的机会服务型机器人在未来三年有一个大爆发。核心价值在于替代人。人工智能取代人，它取决于两个事情，不是看这个是高端还是低端，它这种取决于是你这个东西的输入是否有明确的边界以及它的输出是否标准化，而且易比较。 吴晓波把难以被机器替代的能力，称为“柔软的能力”。他总结出四种。（1）个性化服务能力。软件都是统一的算法，个性化服务很难做到。（2）人格魅力的能力。机器提供的服务，不会有人格魅力，也不会感动人心。（3）创意的能力。计算机最难以与人类竞争的，就是创造力。（4）决策领导的能力（即企业家的能力）。机器没有办法团结领导一群人，齐心协力完成一个使命。","categories":[],"tags":[{"name":"InnerPath","slug":"InnerPath","permalink":"http://iyounix.com/tags/InnerPath/"}]},{"title":"Android build 流程","slug":"Android_Sys/[Android] build 流程","date":"2016-10-01T15:33:05.000Z","updated":"2018-11-08T02:25:12.504Z","comments":true,"path":"2016/10/01/Android_Sys/[Android] build 流程/","link":"","permalink":"http://iyounix.com/2016/10/01/Android_Sys/[Android] build 流程/","excerpt":"","text":"原文地址：http://forum.xda-developers.com/showthread.php?t=2751407翻译地址：翻译者：Younix 介绍AOSP 相当复杂，也很难找到一个方法去更好地了解它。我准备尝试一种务实的方法来了解它它，分析研究一下编译的过程（build process）。在你真正的准备去学习 Android 之前，我推荐大家先读一读我的这份指南。这份指南详述了从 envsetup.sh 到 makefile 到 package 完成编译 的 整个 Android 编译过程 最初（envsetup.sh）一切都从这条命令开始1source build/envsetup.sh 它的作用简单来说就是向你的环境添加了一些命令，你可以在稍后为你的设备编译 Android 的时候使用这些命令。这些命令如下：12345678910111213141516171819202122232425262728- lunch: lunch &lt;product_name&gt;-&lt;build_variant&gt;- tapas: tapas [&lt;App1&gt; &lt;App2&gt; ...] [arm|x86|mips|armv5] [eng|userdebug|user]- croot: Changes directory to the top of the tree.- cout: Changes directory to out.- m: Makes from the top of the tree.- mm: Builds all of the modules in the current directory.- mmp: Builds all of the modules in the current directory and pushes them to the device.- mmm: Builds all of the modules in the supplied directories.- mmmp: Builds all of the modules in the supplied directories and pushes them to the device.- mma: Builds all of the modules in the current directory, and their dependencies.- mmma: Builds all of the modules in the supplied directories, and their dependencies.- cgrep: Greps on all local C/C++ files.- jgrep: Greps on all local Java files.- resgrep: Greps on all local res/*.xml files.- godir: Go to the directory containing a file.- cmremote: Add git remote for CM Gerrit Review.- cmgerrit: A Git wrapper that fetches/pushes patch from/to CM Gerrit Review.- cmrebase: Rebase a Gerrit change and push it again.- aospremote: Add git remote for matching AOSP repository.- cafremote: Add git remote for matching CodeAurora repository.- mka: Builds using SCHED_BATCH on all processors.- mkap: Builds the module(s) using mka and pushes them to the device.- cmka: Cleans and builds using mka.- repolastsync: Prints date and time of last repo sync.- reposync: Parallel repo sync using ionice and SCHED_BATCH.- repopick: Utility to fetch changes from Gerrit.- installboot: Installs a boot.img to the connected device.- installrecovery: Installs a recovery.img to the connected device. 它也会扫描一遍你源码中的 vendorsetup.sh 文件并且用这种格式将他们列出来：12345678including device/generic/armv7-a-neon/vendorsetup.shincluding device/generic/goldfish/vendorsetup.shincluding device/generic/mips/vendorsetup.shincluding device/generic/x86/vendorsetup.shincluding vendor/cm/vendorsetup.shincluding sdk/bash_completion/adb.bashincluding vendor/cm/bash_completion/git.bashincluding vendor/cm/bash_completion/repo.bash 所有的 make 相关命令只有在 source envsetup.sh 后才能使用 浏览并且执行一些 build/core 目录中的内容 会列出可选择的设备及编译项目（比如 “userdebug””user””eng”) 它也负责执行最重要的步骤。建立 Android 的编译路径并且为编译过程建立编译工具链。 它也会调用 java 并设置一些编译的参数 它将会展示默认的设备配置比如 1234add_lunch_combo aosp_arm-engadd_lunch_combo aosp_x86-engadd_lunch_combo aosp_mips-engadd_lunch_combo vbox_x86-eng 如果设备源码没有的话，它将会调用 build/tools 中的’roomservice.py’ 文件来查找并下载设备的源码。 它也包含了 CWR 和 TWRP 命令集，用来刷机。 它也提供了设备端的 Bug 报告机制，可以从开发者工作所使用的机器上直接获取到 bug reports。lunch/brunch 命令下一件事情就是使用 lunch 命令。在执行了 envsetup.sh 后，lunch 命令被添加至我们的 bash shell 编译环境中。在作出了编译工程的选择后，所选择的产品被确认了，环境变量也都设定下来了，包括：12345678export TARGET_PRODUCT=$product # The chosen productexport TARGET_BUILD_VARIANT=$variant # The chosen variantexport TARGET_BUILD_TYPE=release # Only release type is available. Use choosecombo if you want to select type.export ANDROID_BUILD_TOP=$(gettop) # The build root directory.export ANDROID_TOOLCHAIN=... # The toolchain directory for the prebuilt cross-compiler matching the target architectureexport PATH=... # Among other stuff, the prebuilt toolchain is added to PATH.export ANDROID_PRODUCT_OUT=... # Absolute path to the target product out directoryexport ANDROID_HOST_OUT=... # Absolute path to the host out directory 用法相当简单，你仅仅只用输入 lunch ，然后将会列出用此源码你可以编译的设备工程清单，或者你可以输入 lunch cm_&lt; device_name &gt;-&lt; variant_type &gt;.lunch 命令实际上确定了编译工程的编译目标，并负责锁定用来编译源码的环境变量和设备配置。其实，只有在设备树中包含有 vendorsetup.sh 的时候 lunch 命令才能被使用。vendorsetup.sh 添加了我们设备的 lunch combo（当我们执行 lunch 时出现的那个 list） make 命令make 工具的目的是自动确定这个大工程的哪些模块需要重新编译，并且发出命令集来重编译它们。有一个描述 make 的 GNU 安装的手册，是 Richard Stallman 和 McGrath 写的。下面的例子是以 C 语言为例，因为 C 是最常见的，但是你也可以将 make 用在任何能够以 shell 命令来编译的编程语言中。你可以用它来描述任何需要自动更新的任务。为了准备使用 make，我们需要编写一种叫做 makefile 的文件，这个文件描述了我们程序中各个文件的关系，并且展示了我们更新每个文件的命令。在程序中，执行文件的更新是由于某些文件的更新产生的，后者就是由某些代码编译而来的。只要有合适的 makefile 存在，每次你改变源码后，都只需要简单的执行1make 就够了。make 有能力完成所有的重编译。make 程序使用 makefile 数据库和文件的最近修改时间来确定哪些文件需要被更新。对于每一个（更新后的）文件，make 都将执行 makefile 数据库中对应的指令（commands）。 make 执行 makefile 中的命令来更新一个或者多个程序。如果没有显式地使用 -f 选项，make 将依次寻找 makefiles GNUmakefile 和 Makefile。 一般无论是 Makefile 还是 makefile 都将可以被调用（我推荐使用 Makefile，因为它在文件目录清单中最突出，就仅靠在最重要的文件 README 的旁边）。 如果一个文件被修改后，所依赖这个文件的编译结果会被 make 进行更新。同样如果这个编译结果不存在或者被修改，都将会被 make 重新编译。 Makefile 执行过程Make 命令逐行执行了 makefile 中的命令。它一边执行着每条命令，一边向标准输出写命令（除非另有直接声明，比如用了 -s 选项）。一个 Makefile 必须使用 Tab 来进行缩进。当一个命令通过 make 命令来执行。它使用的是 make 的执行环境。这个环境包括了 执行 make 命令的任何宏定义 定义在 MAKEFLAGS 变量中的所有环境变量。 注意：当 make 命令遇到以 makefile 里面的关键字相同的 起始的命令时（比如 inclue、depend），make 命令将试图打开这文件，并去处理该文件就好像这个文件本来就在 makefile 中的 include 行中一样。这个现象只在第一个 makefile 的第一个非命令行被 make 命令作为非 POSIX 目标读的时候才会发生。否则，将发生一个语法错误。注释：注释以 # 字符开始，除了 shell 命令行，其他的地方都可以用。环境：make 命令会使用 MAKEFLAGS 环境变量。 Target 规则Target 规则的格式如下: target[target…] : [prerequisite…] [;command]&lt; Tab&gt;command多个 target 和 prerequisite 用空格分开。后面的任何文本 ; （分号）和所有被认为是后续行以标签字符开头的命令被用于更新目标。如果新行不以制表符或＃字符开始，后面就是一个新的 target。您也可以在Makefile教程看这里http://mrbook.org/tutorials/make/！这是构建过程中最重要的组成部分，其中 make 文件组织编译的每个源文件，并将他们组合成有用的应用程序/二进制文件/库等。where make files are resposible for compiling almost each of the files in the source and putting them together for the useful apps/binaries/libraries etc. Build 技巧 使用 Wiki。 眼看用于构建实际的命令软件 使用“showcommands”目标上的’制作’行： $make -j4 showcommands这可以与其他一起使用make目标，以查看该版本的命令。即，’showcommands’不是目标本身，而只是为指定的生成的改性剂。 在上面的例子中，-j4是无关的 showcommands选项，并且用于执行并行 4 线程。 make target下面是你可以用它来构建系统的不同部分不同 target 的列表：make sdk - build the tools that are part of an SDK (adb, fastboot, etc.)make snod - build the system image from the current software binariesmake servicesmake runtimemake droid - make droid is the normal build.make all - make everything, whether it is included in the product definition or notmake clean - remove all built files (prepare for a new build). Same as rm -rf out/&lt; configuration&gt;/make modules - shows a list of submodules that can be built (List of all LOCAL_MODULE definitions)make &lt; local_module&gt; - make a specific module (note that this is not the same as directory name. It is the LOCAL_MODULE definition in the Android.mk file)make clean-&lt; local_module&gt; - clean a specific module Helper macros and functionsThere are some helper macros and functions that are installed when you source envsetup.sh. They are documented at the top of envesetup.sh, but here is information about a few of them: 辅助宏和函数有一些辅助宏和函数，在安装时，你 source 了 envsetup.sh。它们在 envesetup.sh 顶部有文档，但这里是有关其中的几个信息：croot - 回到目录树的根部m - execute ‘make’ from the top of the tree (even if your current directory is somewhere else)mm - builds all of the modules in the current directorymmm &lt; dir1&gt; … - build all of the modules in the supplied directoriescgrep &lt; pattern&gt; - grep on all local C/C++ filesjgrep &lt; pattern&gt; - grep on all local Java filesresgrep &lt; pattern&gt; - grep on all local res/*.xml filesgodir &lt; filename&gt; - go to the directory containing a file 加快 build你可以在 make 时使用’-j’选项，开启 make 使用多线程。根据我的经验，你的机器上有多个处理器的话你应该指定 2个或线程。如果你有2个处理器，使用’ make -j4’，如果 超线程（这意味着你有4个虚拟处理器），尝试’使-j6。您还可以指定使用’ccache的“编译器缓存，这将加快的东西，一旦你已经建立的东西第一次。要做到这一点，在shell命令行中指定的出口USE_CCACHE = 1’。（注意：是的ccache包括在库的预建的部分，并没有单独的主机上安装。） 编译单独的程序或模块如果您使用的 build/envsetup.sh，你可以使用一些定义功能去构建源码的一部分。使用“mm”或“mmm”命令来做到这一点。 “mm” 命令使东西在当前目录（和子目录）。“mmm”命令，指定要编译的目录或目录列表。‘make snod’ builds a new system image from current binaries. 在根目录运行 ‘make snod’。 设置模块特定的构建参数Android 系统中的某些代码可在它们的 build时进行定制（从构建变量独立和发布与调试选项）。您可以设置控制单个编译选项变量，无论是在环境中设置它们或直接通过他们“make”（或“m…”功能，这称之为“make”）。例如，“init”程序可以通过设置INIT_BOOTCHART变量 bootchart日志。（请参阅《 Using Bootchart on Android》了解为什么你可能想做到这一点。） 你可以做到：123$ touch system/init/init.c$ export INIT_BOOTCHART=true$ make 或者12$ touch system/init/init.c$ m INIT_BOOTCHART=true 最后，经过 makefile 组织优化后，所有进程以及构建设备的指定部分（包括二进制文件、库、app、system 文件和 “boot.img” 都可以在 out/target/product/device 目录下找到）。在 META-INF文件的实例和系统boot.img被打包成一个zip文件（其名称也由makefile文件处理）并且MD5校验也准备好了。如果你运行“brunch”命令或“lunch+ mka”命令，将生成可擦写的 zip。 Build 技巧不是并不是为了好玩。这东西可以帮助我们更深层次的看问题！ Younix 译","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"大者恒大，强者愈强","slug":"Life/InnerPath/16-09-30大者恒大，强者愈强","date":"2016-09-30T06:55:00.000Z","updated":"2018-11-08T01:30:40.291Z","comments":true,"path":"2016/09/30/Life/InnerPath/16-09-30大者恒大，强者愈强/","link":"","permalink":"http://iyounix.com/2016/09/30/Life/InnerPath/16-09-30大者恒大，强者愈强/","excerpt":"","text":"入职一年有余，标题的八个字是最强烈的感受。 因为并非科班出身，大三的时候仅仅凭着一腔热血认准了嵌入式这个行业一个猛子扎了进来。这一年，与之前在象牙塔中的遥望相比，现在对这个行业也有了或多或少更成熟的认识。除了对市场环境的一些浅略不成熟的看法之外，更多的是在技术沉淀方面的心得。同时也认识了一批行业内的前辈，前辈们不仅不吝惜地耐心传授给我技术方法，也时常会在职业规划方面指点一二。然而，和这些前辈们相处的越久，我越是能感受到自己的无力。 楔子临界点是我最近看到的两个大牛博客。 第一个是搜索资料的时候恰巧在 CSDN 上发现了一篇好文，于是马上将这个博客主页加入收藏，但是竟然发现原来已经将这个博客收藏过了。仔细一看，原来是两个月前搜索资料的时候也曾感叹于这个博主的技术水平。好奇驱使浏览了一下这两个月这位大牛在研究哪些内容。惊讶的发现他几乎每两天都能完成一篇高质量的技术博文。而且有几篇的内容都是我曾经用了一两个月时间研究的东西。 第二个是同事推荐了一个网站“酷壳网”。印象中记得大学的时候时常查东西都会搜到这个网站上的内容。我浏览了一下阅读量最高的几篇文章，惊讶的发现自己曾经看到的一些好文（《跟我一起写 Makefile》、程序员练级攻略）的出处正是这里。果断马上关注了博主陈皓的微博，又惊讶的发现原来不知道什么时候已经关注过他了。 这些巧合给人带来一种莫名的惊喜，但是惊喜之后又有些伤感。是的，伤感，我不知道为什么。自己向来自诩为一个乐观主义者，确实最近也明显感觉到自己的抱怨多了许多。是的，是因为我感受到累了，我从来不会抱怨肉体上的累，这种累更多的是精神上的。 认知差距这种精神疲惫可能是因为我发现了和强者们之间的差距。差距当然是永远存在的，但是曾经的我认为，只要自己比强者付出更多的时间，一定能够弯道超车。但是我现在意识到，你能够弯道超车的要么本来它就和你是同级车，要么他就是从别的赛道上过来的。真相就是大家都是在前进着的，而且在我们前面的人不仅速度比你快，加速度也比你快。 曾经我眼中，强者之强单纯地取决于他的知识储备。所以表面上来看，只要付出更多的时间，只是储备便一定能跟上。但是现在，我明白强者的真正之强主要在于其学习东西的效率。前面所说的第一个大牛，一个人的知识积累就如同滚雪球一样，在积累了一定的量之后，只可能越滚越快，越滚越多。在同一个领域内，后续或者交叉学科有很多都是可以参考前置学科的学习方法的。在不同的领域内，利用曾经将一门知识学到精通的方法用在新领域上，可能也是有效的。再者，强者往往已经是很努力的了（多数情况下他们甚至都没有察觉到自己的努力，兴趣或者野性驱使着他们一直奔跑），无法存在“比强者更刻苦”这种情况。 动起来解决上面这个问题的方法有两个： 承认这种现实，继续踏实地努力 想办法提升自己的“效率”，实现“加速度”的超车 后来的话这篇文章写了两周，就是写到这个地方就没有写下去了。现在来看，上面提出的两个解决方法从本质上都是有问题的。压根就不应该强调“比较”。 症结问题的症结应该是在于 自卑。 因为我发现自己时常去给第三者描绘我所认识的另一个人的成就。这恰恰是一种不自信的表现。 其实我最开始想说的是“心态”，写着写着后来发现应该是“心态”中的“盲目比较”，继续写着发现应该是“自卑”心里作祟。另外我应该还算是了解自己的，所以也不列举这一点体现在哪些地方了吧（除非后面的分析用到了）。 重新动起来找到症结后似乎陷入了一个死胡同： 不自信 ————+ 停滞不前 —————+ 眼高手低 ————+ 差距加大 ————+ 不自信 思路渐渐明朗，破局的点就在 解决眼高手低！把期待达到的目标降低一点： 脚踏实地 ————+ 差距减小 ————+ 自信 ————+ 不断前进 ————+ 脚踏实地 原来还是那个很简答的道理，告诉自己不要期待太多，只和昨天的自己比较，脚踏实地，一步一步。慢慢来，比较快。 后记这篇文章实际上写了两周，并不是在措辞上有所酝酿，实际上我也不知道自己在纠结逃避着什么。9.30 开始写，国庆动了几次笔却无从下手。就在刚才猛地看到从动笔到现在已经过了两周的时候，我才意识到自己的脚步已经停下了这么长时间。 于是强迫自己打开了编辑器，告诉自己一定要在早上完成这篇文章。神奇的是，写着写着，也没有那么抗拒了。其次，写作确实可以很好的整理自己的逻辑和思路。就像分析症结的那一部分，我最开始觉得是心态不对，不应该总是和别人进行比较。写了几段之后，着重的去强调盲目比较去了，我就知道，可能最终的症结是比较。删掉重写比较，又写了几段，无意中写道了 “发现自己喜欢说其他的人多牛多牛”，确实有这样一个现象，我就去查这样一种心态的原因。最后别人有的分析到是因为人的潜意识这样做可以降低自己不够努力的负罪感，也是不自信的一种体现。我猛的发现，就是这个。于是大概画了一下思维导图，从而发现这样一个恶性循环。而且解决这种潜意识的不自信实在太难了，于是决定从眼高手低开始解决。 就是这样一个心路历程，还是颇值得记录了，也许对以后分析问题会比较有帮助。","categories":[],"tags":[{"name":"InnerPath","slug":"InnerPath","permalink":"http://iyounix.com/tags/InnerPath/"}]},{"title":"2016Q3总结——秋日已来，硕果寥寥","slug":"Life/InnerPath/16-09-252016Q3总结——秋日已来，硕果寥寥","date":"2016-09-25T15:55:00.000Z","updated":"2018-11-08T01:30:40.291Z","comments":true,"path":"2016/09/25/Life/InnerPath/16-09-252016Q3总结——秋日已来，硕果寥寥/","link":"","permalink":"http://iyounix.com/2016/09/25/Life/InnerPath/16-09-252016Q3总结——秋日已来，硕果寥寥/","excerpt":"","text":"又是三月有余，倘若不是逼着自己现在驻足回头去看一看，估计还未发现时间如此不饶人。几月未曾提笔，总以为会语塞，但是一旦开始写起来，却又有无数话语想要倾吐。按捺住脑中萦绕的各种思绪，抽出一根叫做收获的，来看看这三个月究竟有哪些得失吧。 技术积累七月份主要在研究 SPI 设备，负责一款 SPI GSensor 的移植。七月末整理归纳了一下 NFC 的移植流程。算是为部门 NFC 技术做了一点积累。八月初玩了一下 Linux 中的互斥机制。八月中下旬负责移植一款 Mipi LCD 到 RK3288 的板子上。颇有收获。九月份负责 VR 客户的技术支持，解了一些不痛不痒的问题。主要是 Framwork 层与 Application 层的问题，着实不太感兴趣。而且对 Android 上的的着实不太了解，问题解的也比较头大。 这段时间负责的案子有 展讯SC7731 的平台，还有几颗料未移植完，转部门后就将方案转移给 Lanny 姐了。后来负责的案子是 RK3288 平台的，玩了下 BT，Wifi 的简单配置，移植了一个 Mipi 屏，移植了一个 Camera。其中 Mipi LCD 算是最有收获的。 回顾与总结回头看看当时年初规划的这座大山，看看 Q1 修改制定的路线，看看 Q2 完成的进度。又低头看看现在究竟走到了哪级台阶。再抬头看看离这座小山的山顶，和年初时完全被笼罩在云雾之中的山顶而言，现在似乎能看到云雾中若隐若现的那山顶的轮廓了。 Linux驱动的几个模块要熟知。今年要完成以下几个模块的学习 LCM（MIPI接口设备） TP（I2C） GSensor（SPI接口） MSensor（I2C接口） GyroscopeSensor（I2C接口） P/L Sensor Camera SPI 和 Camera 的两条线确实打得相当之虚啊，因为只是简单的配置问题移植，并没有深入到太多的代码细节去追究。后面还需要在实战中去继续磨练。 熟悉Linux内核中的常用知识点： 并发控制（中断屏蔽、原子操作、自旋锁、信号量、互斥体） 阻塞与非阻塞I/O（等待队列）、轮询操作 中断与时钟 I2C/SPI 两类设备的驱动模型 十二本小说硬指标。 黑客与画家 偷影子的人 这么慢，那么美 白夜行 岛上书店 当我跑步时，我在说些什么 神们自己 天才在左，疯子在右 蔡康永的说话之道 特立独行的猫,不要让未来的你,讨厌现在的自己 格局逆袭 Stroy of Your Whole Life 锻炼。指标为 Keep 上面的任务争取每天完成。 博客要继续坚持最少两周一更。这个养成习惯就好了。另外一些专业性知识也会有条理的梳理在 CSDN 上，更多的是供以后自己查阅吧。 CSDN 博客每月至少完成四篇有质量的文章。 日期 个人站点 CSDN 2016年09月 1 8 2016年08月 1 5 2016年07月 1 7 2016年06月 0 6 2016年05月 0 12 2016年04月 0 11 2016年03月 3 3 2016年02月 2 2 2016年01月 4 3 添加了第六点，目的在于需要通过系统整理知识体系来更好的在完成工作任务的过程中 高效的学习。 以上六点为接下来大半年的大致计划，一些零碎的选做任务： 开始了解理财投资相关的知识 学游泳 游泳这个算是颇为自豪的，从四月份的旱鸭子，到现在可以游 1.5 km 了。前两个月每周两次，后面每周一次，坚持的力量不可小觑。 好吧。那么，继续加油吧，做更好的自己。","categories":[],"tags":[{"name":"InnerPath","slug":"InnerPath","permalink":"http://iyounix.com/tags/InnerPath/"}]},{"title":"谈谈RD和FAE","slug":"Life/InnerPath/16-08-28谈谈RD和FAE","date":"2016-08-28T14:00:00.000Z","updated":"2018-11-08T01:30:40.291Z","comments":true,"path":"2016/08/28/Life/InnerPath/16-08-28谈谈RD和FAE/","link":"","permalink":"http://iyounix.com/2016/08/28/Life/InnerPath/16-08-28谈谈RD和FAE/","excerpt":"","text":"这段时间负责 Mipi 屏的移植，平台是在 RK3288 上。搜索资料的时候进入了 Firefly(基于3288的一块开发板)的技术支持群。与其他公司的各种 RD 大牛交流，收获颇丰。但也颇有感慨。最强烈的感受就是，FAE 和 RD 的差别。 我们公司 FAE 的尴尬定位因为现在所在的公司定位是代理商，所以我们 FAE 的职责自然就是支持客户。虽然很无奈，但是我们的工作职责就是将客户的问题经过筛选反馈给原厂。简单的让我们 FAE 处理，难的交由原厂，说白了就是一个筛子。另外可能和其他代理商不同，我们的 FAE 还需要做 CASE，就是独立的去完成方案，然后交由同仁去推广给客户。但是 FAE 是 行业鄙视链的最末端。这段时间会常常向其他公司的 RD 们请教问题（他们不知道我是 FAE），最常出现的一段对话是 我：前辈，请问…前辈：去问这颗料的 FAE 啊… 印象特别深的还记得有一次，我碰到了一个问题，算是比较有技术含量，当时在群里面引起了一阵讨论。有一个前辈无意问道我是做什么的，我便说我是 FAE，他们许多人便很疑惑 FAE 为什么还需要负责移植工作，为什么还能够有能力来进行移植工作。虽然非常尽力而委婉，但鄙视轻视之情还是溢于言表。 于是这几天我仔细分析思考了一下他们 RD 和 我们 FAE 的区别，得出了以下几点。 解决问题的思路这一点是最大的差距。这快一年的时间，我主要负责过两个平台，先是展讯平台，后是 RK 平台，两者都有各自的 BugReport 系统，展讯的叫做 ClearQuest（CQ),RK 的则是 Redmine ，刚进公司便学习了这些平台的使用方法。连师兄也教我说，遇到问题有三个步骤 去 CQ/Redmine 上面查原来是否有人碰到过类似问题; 问周围的同事有没有人碰到过 在网上搜索答案然后我自己又把第三点扩充了一下3.1 Google3.2 StackOverFlow3.3 Github 不得不承认，这些步骤确实对我的思维有很大的影响，而且坦诚的说，我认为这些影响弊大于利。 利快速解决问题，这一点是工作与学习的差别。不像学习的时候自己去慢慢琢磨原理，工作的时候主管们第一要求就是需要很快的解决问题（因为很多时候都是客户正赶着量产），所以需要有快速解决问题的能力。解决问题不在乎你是怎么去解决的，你可以抄 Github ，可以求助行业内的其他前辈，可以去各种 BugReport 平台搜索答案，方法无关紧要，结果就是一切。所以利在于，可以很快的为公司创造价值。 弊这就导致我现在每每碰到一个问题，首先都是想要去借助外力来解决问题。比如要移植一款某个 Sensor，我首先想得就是去 Github 上面找源码，最好能找到相同或者相似平台的，找到后轻轻松松移植，一了百了，但是实际上有很多技术细节容易被忽略掉。就像是曾经移植一款 GyroscopeSensor 的时候，到处都找不到代码（我们早就不代理这颗料了，但是因为是给我练手的，所以还是得做出来），于是尝试自己写代码。最开始很艰辛，但是花了一周，仿照平台上的 加速度计 Sensor 完成了这个 Gyroscope Sensor 代码的编写，跟踪到了整个 input 设备加载流程的代码细节中，还是很有成就感的。那么，这个快速解决问题的方法所带来的弊在于，相当容易忽略掉技术细节。做完了就结束了，没有碰到问题，就不会带来进步。 搜集信息和学习知识的能力搜集信息和学习知识能力，这一点我觉得因人而异。不能一概而论。确实接触到的 RD 前辈们很多都相当厉害，不过我觉得同样有很多的 RD 的学习能力甚至不如我们强。有的 RD 遇到问题就来找我们，即使是些很简单的东西，Google 就能出来，StackOverFlow 上面全都有。这一点因人而异也不细表了。 外界压力这一点毋庸置疑， RD 的压力比我们要大得多，这也是我相当羡慕的一点。并不是我有这种受虐倾向，只是我觉得个人的主观能动性是有限的，如果大环境都是向前冲的，我们自然也会向前冲的更有激情。而 FAE 所在的公司这种 “ 工程师氛围 “，实在太稀薄了。因为公司工作压力不大，所以时常下班后，大家半个小时一个小时之内便陆陆续续的回家了。我并不是说加班就意味着 ”工程师氛围“，而是说现在公司这种氛围不是我所期待的，很容易让人就磨平了斗志，进步速度自然而然的变慢很多。最可怕的是你以为自己是兔子，大家是乌龟，但是你不知道还有豹子、羚羊的存在，你不知道在奔跑的不止有动物，还有汽车、火箭，还有光。暂时解决这个问题的办法就是抱团，和热爱技术的小伙伴抱团一起去前进是暂时的策略。 了解到的一些真正的 RD 的生活，他们每天都有相当明确的任务，必须要实现某个功能，不能完成就加班。虽然有人说这样肯定累坏啦，但是我觉得在这种外界的高压下去前进，进步也一定是神速的。而且刚毕业就不想劳累，想去思考安逸，那你还想等到什么时候去奋斗呢？ 优势与劣势最后，整体的来看，因为压力的原因，FAE 积累技术的速度比 RD 要慢许多。但是这并不是无法弥补的。作为一个 FAE，首先要有很多 RD 一样独立思考问题的能力。即使是去求助 Github，也应该尽可能地了解技术实现的细节。其次，作为 FAE 的优势在于自由时间比 RD 多，所以我们需要做的就是把这些自由时间高效地利用起来，达到提高自己的目的。","categories":[],"tags":[{"name":"InnerPath","slug":"InnerPath","permalink":"http://iyounix.com/tags/InnerPath/"}]},{"title":"Linux 平台嵌入式开发 101","slug":"Linux/[Linux] Linux 平台嵌入式开发 101","date":"2016-08-19T06:26:42.000Z","updated":"2018-11-08T01:52:03.022Z","comments":true,"path":"2016/08/19/Linux/[Linux] Linux 平台嵌入式开发 101/","link":"","permalink":"http://iyounix.com/2016/08/19/Linux/[Linux] Linux 平台嵌入式开发 101/","excerpt":"","text":"今天开始带新人, 给新人准备了一份学习套餐. 熟悉 Linux 开发环境基本操作和概念文本学习方式http://happypeter.github.io/LGCB/book/index.htmlhttp://www.linuxprobe.com/chapter-02.html这两个看完 Linux 环境下的基本概念就掌握了。 视频学习方式http://www.imooc.com/course/programdetail/pid/45这个里面的 入门必备阶段的两个课程。 实战学习方式https://www.shiyanlou.com/courses/1 上面三个途径的内容是重复的，可以稍微看看然后挑自己喜欢的方式就 OK 了。 Linux 下开发的工具系统最好在实体机上自己装一个 Ubuntu 系统。虚拟机勉强也可以。 编辑器Vim：http://www.0xffffff.org/2013/01/09/7-vim-setting/或者Emacs：http://www.oschina.net/question/54100_56621选一个 版本控制工具Git：http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 记笔记OneNote 其他工具都是些简单的小工具，这个可以先了解有这样的东西，用到了再仔细查用法。串口调试工具：minicom链接服务器： ssh、ftp文件比较工具：BeyondCompare 基本功Shell会写简单的小脚本，执行些繁琐的指令。比如自动编译代码并下载到本地 等等。能看懂 Makefile 和 Android.mk（这个后面用到的时候再去查吧） C 语言周末抽两天时间过一遍：https://www.shiyanlou.com/courses/57 Linux C多了一些 Linux 系统下的 API：高级 C 语言 链接: https://pan.baidu.com/s/1hrEhUuw 密码: 46n6这个教程很好。不要扩散太多人了，因为是买的，被举报了可能链接就失效了。而且只买了第四章，其他的章节可以搜 CSDN 朱有鹏。几个小伙伴一起攒钱买来抽空学。 语言只是工具，用到什么学什么好资源和好方法 Google + StackOverflow + 知乎/Quora 下搜问题，抛弃百度吧：（用google可能需要改hosts）https://laod.org/hosts/2016-google-hosts.html 有钱的也可买一个 VPN。 IBM 文库：http://www.ibm.com/developerworks/cn/views/linux/libraryview.jsp 基本上所有的 Linux 基础知识都有 推荐两个好网站：实验楼（提供虚拟机，一边敲代码一边学）http://www.shiyanlou.com/register?inviter=NTY0MzE5MDg5MjAw爱慕课（以视频方式学习）www.imooc.com 编程书籍按需查阅https://github.com/dearsq/free-programming-books/blob/master/free-programming-books-zh.md 搜 命令 http://man.linuxde.net/ 搜 API http://lxr.free-electrons.com/ident PS：以后你们释放文档，最好不要发 word，记得发 pdf ，加上公司或者自己的水印最好。PPS：最后祝您 身体健康。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"NFC Android 平台 NXP NFC 移植流程归纳","slug":"Android_Driver/Driver/NFC/[NFC] Android 平台（Linux3.10） NXP NFC 移植流程归纳","date":"2016-07-28T15:01:05.000Z","updated":"2018-11-08T02:30:20.453Z","comments":true,"path":"2016/07/28/Android_Driver/Driver/NFC/[NFC] Android 平台（Linux3.10） NXP NFC 移植流程归纳/","link":"","permalink":"http://iyounix.com/2016/07/28/Android_Driver/Driver/NFC/[NFC] Android 平台（Linux3.10） NXP NFC 移植流程归纳/","excerpt":"","text":"目录一、驱动部分 添加驱动文件pn544.c / pn544.hMakefileKconfig 修改平台配置 其他 二、Android Middleware 的移植 Device 部分 external 部分 framework 部分 packages\\app\\Nfc 选择 PN547 or PN548 ESE 开关 添加 conf 与 .so 文件 其他 三、附录pn547_i2c_test 工具使用说明 一、驱动部分1. 添加驱动文件pn544.c / pn544.h12345cd IDH/kernel/drivers/mkdir pn544# 并加入驱动文件：# pn544.c# pn544.h Makefile同目录下添加 Makefile 如下：123456## Makefile for nfc devices#obj-y += pn544.o#obj-$(CONFIG_NFC_PN548) += pn544.occflags-$(CONFIG_NFC_DEBUG) := -DDEBUG 父目录下 Makefile 中添加1obj-y += pn544/ Kconfig同目录下添加 Kconfig 如下1234567891011121314151617181920## Near Field Communication (NFC) devices#menu &quot;Near Field Communication (NFC) devices&quot; depends on NFCconfig PN544_NFC tristate &quot;PN544 NFC driver&quot; depends on I2C select CRC_CCITT default n ---help--- Say yes if you want PN544 Near Field Communication driver. This is for i2c connected version. If unsure, say N here. To compile this driver as a module, choose m here. The module will be called pn544.endmenu 父目录下 Kconfig 添加：1source “drivers/pn544/Kconfig&quot; 2. 修改平台配置rcIDH/device/PLATFORM_NAME/xxx.rc为节点添加权限展讯平台是 IDH/device/sprd/scx35/init.sc8830.rc在 on boot 之后添加1234for nfc setprop ro.nfc.port &quot;I2C&quot; chmod 0660 /dev/pn544 chown nfc nfc /dev/pn544 在 on post-fs-data 之后 添加12mkdir /data/nfc 0770 nfc nfcmkdir /etc/param hardwareSources\\hardware\\libhardware\\include\\hardware\\nfc.h也用我们 hardware 目录下的 .h 替换 dts因为 Android 5.1 Android 6.0 的内核是 Linux3.10 以上的，所以和曾经修改 board_info 的形式有所区别，我们需要修改 dts。以展讯平台为例，查阅硬件资料，我们了解到使用的是 i2c1 组总线，i2c地址是 0x28。IRQ 用的 GPIO 是 229， VEN 用的 GPIO 是 226，固件下载管脚 DWN（firm-gpio）用的 GPIO 是 228。在 dts 的 i2c1 中添加节点：123456789101112nfc-pn544@28&#123; nfc-pn544@28&#123; compatible = \"nxp,nfc-pn544\"; reg = &lt;0x28&gt;; nxp,irq-gpio = &lt;&amp;d_gpio_gpio 229 0x00&gt;;//MTRSTN nxp,ven-gpio = &lt;&amp;d_gpio_gpio 226 0x00&gt;;//MTDI //interrupt-parent = &lt;&amp;d_gpio_gpio&gt;; //interrupts = &lt;229 0&gt;; interrupt-names = \"nfc_irq\"; //nxp,firm-gpio = &lt;&amp;d_gpio_gpio 228 0x00&gt;; nxp,firm-gpio = &lt;&amp;d_gpio_gpio 225 0x00&gt;; //MTDO &#125;; 修改完驱动部分后，进行编译，可以利用1make -32 2&gt;&amp;1|tee makeKernel.log 将编译日志导出到 makeKernel.log 中以便于分析编译错误。 编译完成 Kernel 部分后， 请用 adb shell 进入设备查看 dev 目录下是否有 pn544 节点生成。 并利用 pn547_i2c_test 工具检测 i2c 通信能否成功。（工具使用方法见附录） 请反馈给我们的工程师确认 Kernel 部分移植无误后再进行上层部分的移植，否则会增加不必要的工作量。谢谢。 3. 其他Hisi 平台的 i2c 通信失败可能需要修改平台端 i2c 相关的代码。MTK 平台 的 dts 请参考释放的资料包中的 dts。在移植Middleware代码的时候有一些额外的配置（除了正常移植步骤外，需要先注释掉平台自己实现的一套 NFC API） ，所以请先完成 Kernel 部分的移植后再进行 Middleware 部分的移植。RK 平台 dts 配置部分与本手册出入较大，请自行配置。Qcom 平台无额外修改。 二、Android Middleware 的移植根据 Android 版本的不同，获取到相应的 Middleware。Android 5.1 获取的是NFC_NCIHALx_ARF.3.3.0_L_FW08.01.26_FW10.01.14（Android5.1 无eSE）NFC_NCIHALx_ARF.3.5.0_L_FW08.01.26_FW10.01.18（Android5.1 有eSE）Android 6.0 获取的是NFC_NCIHAL_AR0F.4.2.0_M（Android6.0） 本文档只做客户移植参考使用，更详细的 移植说明 与 宏定义设置 请参考目录下的《ANxxxx-NCI_HALx_Setup_Guideline》文档。 1. Device 部分在平台的 mk 文件中添加： 例如展讯平台是 IDH/device/sprd/scx35/device.mk ：1234567891011121314# nxp nfcPRODUCT_PACKAGES += \\ libnfc-nci \\ libnfc_nci_jni \\ nfc_nci.pn54x.default \\ NfcNci \\ Tag \\ com.android.nfc_extrasPRODUCT_COPY_FILES += \\ frameworks/native/data/etc/com.nxp.mifare.xml:system/etc/permissions/com.nxp.mifare.xml \\ frameworks/native/data/etc/com.android.nfc_extras.xml:system/etc/permissions/com.android.nfc_extras.xml \\ frameworks/native/data/etc/android.hardware.nfc.xml:system/etc/permissions/android.hardware.nfc.xml \\ frameworks/native/data/etc/android.hardware.nfc.hce.xml:system/etc/permissions/android.hardware.nfc.hce.xml 请注意，续航符” \\ “后不要加空格，否则编译时会报错。 2. external 部分释放的代码有两个文件夹：dta 与 libnfc-nci ，前者不需要管，后者：删除平台原有的 libnfc-nci1rm external/libnfc-nci -rf 用我们所释放的对应代码替换之。 3. framework 部分 将释放代码中的 framework/base/core/java/com 下的 nxp 与 vzw 替换平台代码中的相应文件夹（若没有则添加） 将释放代码中的 framework/base/core/java/android/ 下的 nfc 文件夹替换平台代码中的相应文件夹 修改 frameworks/base/Android.mk ：用 BeyondCompare 等对比软件对比修改，主要是添加 nfc 相关的内容 4. packages\\app\\Nfc 整个目录删除后替换。5. 选择 PN547 芯片还是 PN548 芯片完成 external 和 packages 部分的移植后请确认如下三个地方的内容：external\\libnfc-nci\\Android.mk12#### Select the CHIP ####D_CFLAGS += -DNFC_NXP_CHIP_TYPE=PN548C2 external\\libnfc-nci\\halimpl\\pn54x\\Android.mk12#### Select the CHIP ####LOCAL_CFLAGS += -DNFC_NXP_CHIP_TYPE=PN548C2 packages\\apps\\Nfc\\Nci\\jni\\Android.mk12#### Select the CHIP ####NXP_CHIP_TYPE := $(PN548C2) 释放的代码默认是 PN548，代表 PN548 或 PN66T如果采用的是 PN547 或者 PN65T，请将 PN548C2 修改为 PN547C2。 6. ESE 开关修改如下两处确认打开 eSEpackages\\apps\\Nfc\\nci\\jni\\Android.mkNFC_NXP_ESE:= TRUEexternal\\libnfc-nci\\Android.mkNFC_NXP_ESE:= TRUE若关闭，请将如上改为 FALSE，并且在packages\\apps\\Nfc\\nci\\jni\\NativeNfcAla.cpp 中添加12345678extern &quot;C&quot;&#123;#if (NFC_NXP_ESE == TRUE) #include &quot;AlaLib.h&quot; #include &quot;IChannel.h&quot; #include &quot;phNxpConfig.h&quot;#endif&#125; 7. 添加 conf 与 .so 文件在释放的代码 external\\libnfc-nci\\halimpl\\pn54x 目录下我们可以看到libnfc-brcm_sample.conflibnfc-nxp-PN547C2_example.conflibnfc-nxp-PN548C2_example.conf三个文件。将 libnfc-brcm_sample.conf 改名为 libnfc-brcm.conf选取符合自己情况的 libnfc-nxp-PN54xC2_example.conf 并改名为 libnfc-nxp.conf在平台目录（如展讯平台是 device\\sprd\\scx35）下添加配置文件 conf 与 .so ：libnfc-brcm.conflibnfc-nxp.conflibpn548ad_fw.so 或者 libpn547_fw.so （在释放的 Firmware 目录下）并修改 device.mk 文件（如展讯平台是 IDH/device/sprd/scx35/device.mk ）：123456789101112# 其中请自行修改固件名NFC_FW_PATCH := device/sprd/scx35/libpn548ad_fw.soPRODUCT_COPY_FILES += \\ $(NFC_FW_PATCH):system/vendor/firmware/libpn548ad_fw.soNFC_CONFIG_PATCH :=device/sprd/scx35/libnfc-brcm.confPRODUCT_COPY_FILES += \\ $(NFC_CONFIG_PATCH):system/etc/libnfc-brcm.confNFC_CONFIG_NXP_PATCH :=device/sprd/scx35/libnfc-nxp.confPRODUCT_COPY_FILES += \\ $(NFC_CONFIG_NXP_PATCH):system/etc/libnfc-nxp.conf 对于 PN7120 则不需要配置 固件 .so 路径。因为 PN7120 不需要下载固件。 8. 其他MTK 平台的额外配置请根据 《MTK平台修改配置.txt》来进行修改。 至此，已完成 Middleware 部分的移植。更多问题，请邮件咨询我们的工程师。移植编译问题请附上 make 的 log，驱动问题请附上 Kernel log，Middleware 问题请附上 Android log，谢谢！ 三、附录pn547_i2c_test 工具使用说明pn547_i2c_test 为测试程序测试程序的使用方法如下1. 将 pn547_i2c_test.rar 解压到 external 目录下 mm 编译2. 将生成的 pn547_i2c_test push 到 system/binadb shellcd system/binchmod 777 pn547_i2c_test./pn547_i2c_test 务必利用本工具确认 KERNEL 部分正常通信后，再移植 Middleware 部分。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"},{"name":"NFC","slug":"NFC","permalink":"http://iyounix.com/tags/NFC/"}]},{"title":"NFC 客户 Support 流程","slug":"Android_Driver/Driver/NFC/[NFC] NFC 客户 Support 流程","date":"2016-07-28T15:01:05.000Z","updated":"2018-11-08T02:30:51.825Z","comments":true,"path":"2016/07/28/Android_Driver/Driver/NFC/[NFC] NFC 客户 Support 流程/","link":"","permalink":"http://iyounix.com/2016/07/28/Android_Driver/Driver/NFC/[NFC] NFC 客户 Support 流程/","excerpt":"","text":"驱动部分问题测试程序用法Pn547_i2c_test 为测试程序测试程序的使用方法如下1. 将 pn547_i2c_test.rar 解压到 external 目录下 mm 编译2. 将生成的 pn547_i2c_test push 到 system/bin执行 adb shellcd system/binchmod 777 pn547_i2c_test./pn547_i2c_test 利用本工具确认 KERNEL 部分正常通信后，再按文档《NFC_NCIHALx_ARF.3.3.0_L_FW08.01.26_FW10.01.14.rar》中的步骤移植上层部分 再还未移植上层内容前，执行测试程序后 NoACK1. 从原理图上看 I2C 的地址是 0x28,这组 I2C 上是否有其他设备是冲突的，请检查 DTS 中 I2C 的地址是否配置正确2. 请问是系统时钟还是晶振，采用外部晶振请保证是 27.12MHZ3. 请抓取 I2C 的波形，并请看确认一下 IRQ 管脚的状态4. Dev/pn544 是否生成了5. 检查供电、固件下载管脚电平高低是否正常 不慎移植了上层后，但还未确认底层是否移植成功，需要先删除移植上层所产生的内容请务必删除移植的上层内容后再使用测试程序因为移植了上层代码后，在开机过程中，上层代码会去调用设备节点，所以此时运行 i2c_test 工具肯定是会失败的。请删除上层编译结果后，再用 测试工具 进行测试： 备份版本后并作如下修改：删除 system/lib 下的 libnfc-nci.so 和 libnfc_nci_jni.so删除 system/lib/hw 下的nfc_nci.pn54x.default.so 文件删除 system/app/NfcNci 整个文件夹删除 system 下 frameworks/native/data/etc/com.nxp.mifare.xml:system/etc/permissions/com.nxp.mifare.xmlframeworks/native/data/etc/com.android.nfc_extras.xml:system/etc/permissions/com.android.nfc_extras.xmlframeworks/native/data/etc/android.hardware.nfc.xml:system/etc/permissions/android.hardware.nfc.xmlframeworks/native/data/etc/android.hardware.nfc.hce.xml:system/etc/permissions/android.hardware.nfc.hce.xml删除system/vendor/firmware/libpn547ad_fw.so删除 system/etc/libnfc-brcm.conf删除 system/etc/libnfc-nxp.conf重新编译后，烧录 system.img 重启机器 利用 I2C_test 工具测试 I2C 现在是否能够正常通信，并将测试工具显示的信息发送给我。 设备节点权限1234567设备节点没权限，加一下权限请在平台的 rc 文件中添加on boot# NFC setprop ro.nfc.port &quot;I2C&quot; chmod 0660 /dev/pn544chown nfc nfc /dev/pn544 海思平台的驱动问题 修改 I2C 的驱动实现12345678910diff -Naru new/i2c-drv/std_i2c/drv_i2c.c old/i2c-drv/std_i2c/drv_i2c.c --- new/i2c-drv/std_i2c/drv_i2c.c 2016-05-17 14:31:06.269986000 +0800 +++ old/i2c-drv/std_i2c/drv_i2c.c 2016-05-11 16:41:40.000000000 +0800 @@ -1040,7 +1040,7 @@ u32Len = g_astI2CBuff[I2cNum].u32Len; g_astI2CBuff[I2cNum].stDataExchange[u32Len].u32Direction = 1; g_astI2CBuff[I2cNum].stDataExchange[u32Len].u8Data = I2cDevAddr &amp; WRITE_OPERATION; - g_astI2CBuff[I2cNum].stDataExchange[u32Len].u32Command = I2C_WRITE; + g_astI2CBuff[I2cNum].stDataExchange[u32Len].u32Command = I2C_WRITE | I2C_START; g_astI2CBuff[I2cNum].u32Len++; 64位平台问题12345664 bit 编译，按如下修改后进行编译1. 添加编译选项#ifeq (&amp;(TARGET_ARCH),arm64) LOCAL_MULTLIB :=64#endif2. LOCAL_MODULE_PATH :=$(TARGET_OUT_SHARED_LIBRARIES)/hw 改成 LOCAL_MODULE_RELATIVE_PATH := hw 想用 NXP CLK 控制 PMIC 的 CLK1234567现在想用NXP CLK REQ信号去控制PMIC CLK，但测量不到NXP CLK REQ的信号，一直是低电平，请问这个需要怎么设置吗？解决方法：驱动将 CLK REQ 设成输入即可，之前提供给贵司的驱动已经有做这个另外 libnfc-nxp.conf 里NXP_CORE_CONF_EXTN=&#123;20, 02, 43, 10, A0, 02, 01, 01, 使能CLK REQ A0, 07, 01, 03, 安全模块安全模块部分， 首先 是需要第三方的厂商来协助完成 绑卡以及发卡 APP 的制作 （参考 三星pay 的 NFC 软件）。另外,安全模块有两种， TEE 和 REE。REE 指的 是在 RichOS（Android） 中实现的 安全保护措施。TEE 指的 是 与 RichOS 并 行 的运行环境，为 OS 提供安全服务。详细的可以参 考：http://blog.csdn.net/braveheart95/article/details/8882322两种都是实现 安全 模块的方式，区别在于 TEE 安 全级别更高。从移植过程中来看，REE 基于 我们 的代码还需要添加 .so 的 库文件。TEE 还需 要调 通 SPI 总 线。但是无论是哪 一种 都需要先将我们的上层移植完毕。 移植上层部分固件和配置文件的问题conf 文件需要对应硬件修改一些配置。请问 采用的是 系统时钟 还是 外部晶振？如果采用的是系统时钟的话请问频率是多少？ 平台是 64bit 还是 32bit 的呢？请将附件中的 .so 文件放到 /system/vendor/firmware目录下。 NFC APP 中需要修改的地方12345678910111213141516171819202122232425262728293031323334packages\\apps\\Nfc\\nci\\jni\\Android.mk #### Select the CHIP #### NXP_CHIP_TYPE :=$(PN547C2) external\\libnfc-nci\\Android.mk #### Select the CHIP ####D_CFLAGS += -DNFC_NXP_CHIP_TYPE=PN547C2 external\\libnfc-nci\\halimpl\\pn54x\\Android.mk #### Select the CHIP ####LOCAL_CFLAGS += -DNFC_NXP_CHIP_TYPE=PN547C2 packages\\apps\\Nfc\\nci\\jniNFC_NXP_ESE:= FALSEpackages\\apps\\Nfc\\nci\\jni\\NativeNfcAla.cpp做了如下修改：修改前：extern &quot;C&quot;&#123;#if (NFC_NXP_ESE == TRUE)#include &quot;AlaLib.h&quot;#include &quot;IChannel.h&quot;#include &quot;phNxpConfig.h&quot;#endif&#125;修改后extern &quot;C&quot;&#123;#if (NFC_NXP_ESE == TRUE)#include &quot;AlaLib.h&quot;#include &quot;IChannel.h&quot;#else#include &quot;phNxpConfig.h&quot;#endif&#125;另 libpn547_fw.so 需要放到 system/vendor/firmware 目录下 MTK 平台上层会遇到的问题 看这个“PN547 ON MTK 移植文档.pdf”里面的的一些目录结构，这个文档是针对android 6.0以下版本的指导说明书。里面一些路径跟android6.0的无法对应 ？需要关掉平台原生的 NFC 相关的代码。具体请参考附件《MTK平台修改配置.txt》。 MTK 平台新老版本代码有差异：请确认务必修改如下代码external\\libnfc-nci\\halimpl\\pn547\\dnld\\ 目录 下的 phDnldNfc_Internal.h#define PHDNLDNFC_CMDRESP_MAX_BUFF_SIZE (0x100U) ==&gt; (0xF0U) MTK 平台报错 Not FoundMTK 由于 package 里的文件系统，相册，设置 等应用使用了 MTK P2P 的接口，主要是这个接口没定义而导致报错，替换后会出现编译到时根据提示一个一个注释即可，因为MTK 平台有自己的一套 NFC 实现，我们的移植是删掉后并采用 NXP 的这一套。但是由于 MTK 平台的 其他 app 中（比如 setting） 会调用到这些他们自己实现的接口。所以报错 cannot find 的时候需要对应去报错的文件中将该接口注释掉就可以了。 测试 APK有一款用于测试的 APK（TagInfo），见附件，可以在完成上层代码移植后用于测试。语句注释掉就可以了。 NFC 菜单可以出现，可以正常切换，但是无法刷卡确认时钟是晶振还是系统，固件是否最新，天线匹配。调出波形为13.56M 附近。 可以出现，可以正常切换，A B卡（身份证）交替识别读写很快无法识别任意一种卡片 1234567891011121314151617181920212223242526 目前测试（使用NFC TagInfo软件）发现两个问题： 1. NPC100在S5P4418平台上识别到A类卡后，读取卡片信息的速度明显比手机（nexus4）慢； 2. 交替用A类卡和B类卡（身份证）进行识读，很快就无法再识别任何一种卡片了，如果只用一种类型的卡进行识读就不会出现问题；解决方法：打补丁：NPC100芯片今天的测试结果如下： 1. A卡反复识读正常 2. B卡反复识读正常 3. B卡识读后换A卡识读正常 4. A卡识读后换B卡识读必定异常（表现为1：choose an action对话框不断闪现 2. 设置中的NFC菜单此时无法正常关闭）解决方法：修改 packages/apps/Nfc/nci/jni/NativeNfcTag.cpp 中的以下内容： 1. -- static tNFA_HANDLE sNdefTypeHandlerHandle = NFA_HANDLE_INVALID; ++//static tNFA_HANDLE sNdefTypeHandlerHandle = NFA_HANDLE_INVALID; 2. sCurrentConnectedTargetType = natTag.mTechList[i]; ++ sCurrentConnectedHandle = targetHandle; if(natTag.mTechLibNfcTypes[i] == NFC_PROTOCOL_T3BT) &#123; goto TheEnd; &#125; -- sCurrentConnectedHandle = targetHandle; ++ // sCurrentConnectedHandle = targetHandle; if (natTag.mTechLibNfcTypes[i] != NFC_PROTOCOL_ISO_DEP) &#123; 硬件知识与其他硬件CLK_REQ 和 XTAL 区别CLK_REQ和XTAL1引脚都是时钟相关的引脚，在使用上有什么区别呢？一般在使用 BB 输出的时钟信号，会使用CLK REQ 这个脚，直接接到 PMIC 上 使能 GPIO ，用于控制时钟的开关一般 XTAL1 接的是 BB 端输出的时钟，需要使用 CLK_REQ 这个脚。XTAL1 接的是晶体的话，CLK_REQ 脚悬空。 PN65T只做读卡功能需要 UICC 么PN65T本身集成一个安全单元，可以做卡模拟，也可以外接一个 UICC SIM 卡做卡模拟。只做读卡不需要 UICC。 SPI 引脚作用用于主控和 SE 之间的通信及 SE OS 的升级 固件下载失败1234567891011121314151617181920212223242526272829303132333435363738在pn544_dev_read 函数中添加if (copy_to_user(buf, tmp, ret)) &#123;printk(&quot;%s : failed to copy to user space\\n&quot;, __func__);return -EFAULT;&#125;++ printk(&quot;IFD-&gt;PC:&quot;);++ for(i = 0; i &lt; ret; i++)&#123;++ printk(&quot; %02X&quot;, tmp[i]);++ &#125;++ printk(&quot;\\n&quot;);wake_lock_timeout(&amp;pn544_dev-&gt;read_wake, 2*HZ);return ret;fail: 在 pn544_dev_write函数中添加 /* Write data */ ret = i2c_master_send(pn544_dev-&gt;client, tmp, count); if (ret != count) &#123; printk(&quot;%s : i2c_master_send returned %d\\n&quot;, __func__, ret); ret = -EIO; goto exit;&#125;++ printk(&quot;PC-&gt;IFD:&quot;);++ for(i = 0; i &lt; count; i++)&#123;++ printk(&quot; %02X&quot;, tmp[i]);++ &#125;++ printk(&quot;\\n&quot;);exit:然后根据 Log 观察，固件下载失败。20 01 00 为下载固件的指令，正常应该下载到 8.1.26版本的固件，实际上固件版本为 8.1.8解决方法：提供 Android Log，并分析配置文件。固件版本采用错了，换成 32位固件后，解决问题。 常见 AndroidLog 分析NxpHal : phTmlNfc_Init Failed//节点未生成检查名字是否正确检查节点权限——&gt; adb 直接看/dev/pn54x 的节点权限 nfcManager_doInitialize; ver=NFCDROID-AOSP_L_00.01 nfa=NFA_PI_1.03.66+ NCI_VERSION=0x10I/NfcService( 1640): Enabling NFC // App 的 NFC 打开D/BrcmNfcJni( 1640): nfcManager_doInitialize: enter; ver=NFCDROID-AOSP_L_00.01 nfa=NFA_PI_1.03.66+ NCI_VERSION=0x10//ver=NFCDROID-AOSP 指的是 Android 5.0或者5.1 NFC_VERSION = 0x10 指的是 PN547 或者 65T 0x11 指的是 PN548 或者 66T D/BrcmNfcJni( 6290): NAME_NXP_DEFAULT_NFCEE_DISC_TIMEOUT not found跟踪代码/etc/libnfc_brcm.conf 没有找到 E HAL : load: id=nfc_nci.pn54x != hmi-&gt;id=nfc_nci_pn547HAL 层 id 与 HMI id 不对应修改 HAL 层 id 是在libhardware\\include\\hardware\\nfc.h #define NFC_NCI_NXP_PN54X_HARDWARE_MODULE_ID “nfc_nci.pn54x” 修改 HMI id 是在 配置文件 libnfc-brcm.conf12# NCI Hal Module nameNCI_HAL_MODULE 宏是否为&quot;nfc_nci.pn54x&quot; E/NfcAdaptation( 4800): NfcAdaptation::InitializeHalDeviceContext: fail hw_get_module应该是HAL 层的一个 nfc_nci.default.so 没编译出来external\\libnfc-nci\\halimpl\\pn547\\Android.mk 里LOCAL_MODULE := nfc_nci_pn547.$(HAL_SUFFIX)改成LOCAL_MODULE := nfc_nci_pn547.defaultPRODUCT_PACKAGES += \\ NfcNci \\ libnfc-nci \\ libnfc_nci_jni \\ nfc_nci_pn547.default \\ com.android.nfc_extras请确认这两处保持一致，在system/lib/hw 会有nfc_nci_pn547.default.so 生成，现在应该没生成 。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"},{"name":"NFC","slug":"NFC","permalink":"http://iyounix.com/tags/NFC/"}]},{"title":"NFC 程序设计（NDEF 格式介绍）","slug":"Android_Driver/Driver/NFC/[NFC] NFC 程序设计（NDEF 格式介绍）","date":"2016-07-28T15:01:05.000Z","updated":"2018-11-08T02:31:05.185Z","comments":true,"path":"2016/07/28/Android_Driver/Driver/NFC/[NFC] NFC 程序设计（NDEF 格式介绍）/","link":"","permalink":"http://iyounix.com/2016/07/28/Android_Driver/Driver/NFC/[NFC] NFC 程序设计（NDEF 格式介绍）/","excerpt":"","text":"NDEF 文本格式第一个字节 描述数据状态若干个字节 描述文本语言编码剩余字节 表述文本数据这些数据格式由 NFC Forum 相关规范 定义 NDEF 文本数据格式 NDEF 文本数据格式 偏移量bytes 长度bytes 描述 0 1 状态字节 1 \\&lt;n> ISO/IANA语言编码,格式是 USASCII，由状态字节后6位决定 \\&lt;n+1> \\&lt;m> 文本数据，编码格式是 UTF-8,编码格式由状态字节的前三位决定 状态字节码编码格式|字节位（0是最低位）|含义||–|–||7|0：文本格式是UTF-8 1：文本格式是UTF-16||6|必须设为0||\\&lt;5:0>|语言编码长度（占用的字节个数）| 获取标签数据用 NdefRecord.getPayload 方法完成。在处理这些数据之前，判断一下 NdefRecord 对象中存储的是不是 NDEF 文本格式数据。标准有两个： TNF（类型名格式，Type Name Format）必须是 NdefRecord.TNF_WELL_KNOWN 可变的长度类型必须是 NdefRecord.RTD_TEXT","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"},{"name":"NFC","slug":"NFC","permalink":"http://iyounix.com/tags/NFC/"}]},{"title":"NFC 程序设计（基础知识）","slug":"Android_Driver/Driver/NFC/[NFC] NFC 程序设计（基础知识）","date":"2016-07-28T15:01:05.000Z","updated":"2018-11-08T02:30:31.325Z","comments":true,"path":"2016/07/28/Android_Driver/Driver/NFC/[NFC] NFC 程序设计（基础知识）/","link":"","permalink":"http://iyounix.com/2016/07/28/Android_Driver/Driver/NFC/[NFC] NFC 程序设计（基础知识）/","excerpt":"","text":"android 官方手册：NFC Developer Android平台提供了两个android.nfc 和android.nfc.tech包,里面有API来实现NFC标签的操作。 android.nfcandroid.nfc 包中主要有四个类：NfcManager类：可以用来管理Android设备中指出的所有NFC Adapter，但由于大部分Android设备只支持一个NFCAdapter，可以直接使用getDefaultAapater方法来获取系统支持的Adapter。NfcAdapter类：本设备的NFC adapter,可以定义Intent来请求将系统检测到tags的提醒发送到你的Activity，并提供方法去注册前台tag提醒发布和前台NDEF推送。NdefMessage类：NDEF是NFC论坛定义的数据结构，用来有效的存数据到标签中，如文本，URL，和其他MIME类型。一个NdefMessage扮演一个容器，这个容器存哪些发送和读到的数据。一个NdefMessage对象包含0或多个NdefRecord，每个NDEF record有一个类型，比如文本，URL，智慧型海报/广告，或其他MIME数据。在NDEFMessage里的第一个NfcRecord的类型用来发送tag到一个android设备上的activity。Tag类：标示一个被动的NFC目标，比如tag，card，钥匙挂扣，甚至是一个电话模拟的的NFC卡。可提供对标签的各种操作方法。 android.nfc.techandroid.nfc.tech包包含对 Tag 查询属性 和 I/O 操作的类。这些类分别标示一个tag支持的不同的NFC技术标准。TagTechnology： 这个接口是下面所有tag technology类必须实现的。NfcA： 支持ISO 14443-3A 标准的属性和I/O操作。NfcB：NFC-B (ISO 14443-3B)的属性和I/O操作。NfcF：NFC-F (JIS 6319-4)的属性和I/O操作。NfcV： NFC-V (ISO 15693)的属性和I/O操作。IsoDep：ISO-DEP (ISO 14443-4)的属性和I/O操作。Ndef：对支持NDEF格式的标签进行读写操作。NdefFormatable： 对那些可以被格式化成NDEF格式的tag提供一个格式化的操作。MifareClassic： 如果android设备支持MIFARE，提供对MIFARE Classic目标的属性和I/O操作。MifareUltralight： 如果android设备支持MIFARE，提供对MIFARE Ultralight目标的属性和I/O操作。 NFC编程基本步骤权限1&lt;uses-permission android:name=\"android.permission.NFC\" /&gt; 限制版本号123&lt;uses-sdk android:minSdkVersion=\"19\" android:targetSdkVersion=\"19\" /&gt; 限制安装的设备123&lt;uses-feature android:name=\"android.hardware.nfc\" android:required=\"true\" /&gt; 定义可接受 Tag 的 Activity处理业务逻辑根据便签的具体业务 NFC 标签过滤系统 NfcManager 类详解Use getSystemService(java.lang.String) with NFC_SERVICE to create an NfcManager, then call getDefaultAdapter() to obtain the NfcAdapter.Alternately, you can just call the static helper getDefaultAdapter(android.content.Context). public static NfcAdapter getDefaultAdapter (Context context)：获取手机中默认的NFC设备，一般一部手机就只有一个NFC模块，所有调用此方法即可。 NfcAdapter 类详解重要的常量用于从Intent中获取获取信息，这个Intent是NFC检测到Tag后由系统发起的，由 getIntent().getParcelableExtra(NfcAdapter.常量名); 方法获取相应对象）：EXTRA_TAG(必须的)：它是一个代表了被扫描到的标签的Tag对象；可通过 getParcelableExtra(NfcAdapter.EXTRA_TAG) 获得标签对象。EXTRA_NDEF_MESSAGES(可选)：它是一个解析来自标签中的NDEF消息的数组。这个附加信息是强制在 Intent 对象上的；可通过 getParcelableArrayExtra(NfcAdapter.EXTRA_NDEF_MESSAGES）获得 NDEF 消息。EXTRA_ID(可选)：标签的低级ID。以下三个常量用于对获取的Intent中的Tag类型进行判断：ACTION_NDEF_DISCOVERED：NfcAdapter.ACTION_NDEF_DISCOVERED.equals(getIntent().getAction())ACTION_TAG_DISCOVERED：NfcAdapter.ACTION_TAG_DISCOVERED.equals(getIntent().getAction())ACTION_TECH_DISCOVERED：NfcAdapter.ACTION_TECH_DISCOVERED.equals(getIntent().getAction()) 重要方法：1234public boolean isEnabled () //用于判断当前NFC是否处于可用状态public void enableForegroundDispatch (Activity activity, PendingIntent intent, IntentFilter[] filters, String[][]techLists) //Enable foreground dispatch to the given Activity.用于打开前台调度（拥有最高的权限），当这个Activity 位于前台（前台进程），即可调用这个方法开启前台调度，一般位于onResume()回调方法中public void disableForegroundDispatch (Activity activity) //关闭前台调度，一般位于onPause()回调方法中 NdefMessage 类详解以下三个方法用于构造一个NDEF数据 结构的的Tag数据（用于在Activity与标签之间的数据传递，读取与写入都要用该对象进行封装）123456public NdefMessage (byte[] data)public NdefMessage (NdefRecord record, NdefRecord... records)public NdefMessage (NdefRecord[] records)public byte[] toByteArray ()public int getByteArrayLength ()public NdefRecord[] getRecords () //Get the NDEF Records inside this NDEF Message. NdefRecord 类详解以下两个为构造方法：12public NdefRecord (short tnf, byte[] type, byte[] id, byte[] payload)public NdefRecord (byte[] data) 以下四个方法获取NdefRecord对象对应字段的类型：1234public byte[] getType ()public short getTnf ()public byte[] getPayload ()public byte[] getId () Tag类详解：12public String[] getTechList ()// Get the technologies available in this tag, as fully qualified class names. Ndef类详解：该类用于对NDEF格式的Tag进行读写操作的封装，不同的Tag用不同的类封装，都在android.nfc.tech包中1234567891011121314public static Ndef get (Tag tag) //Get an instance of Ndef for the given tag.构建对象public void connect ()//Enable I/O operations to the tag from this TagTechnology object.，打开I/O操作public boolean isWritable ()//Determine if the tag is writable.判断是否可写public int getMaxSize ()//Get the maximum NDEF message size in bytes.public void writeNdefMessage (NdefMessage msg)//Overwrite the NdefMessage on this tag.向这个Tag写入数据public String getType ()//Get the NDEF tag type.public boolean makeReadOnly ()//Make a tag read-only. NdefFormatable类详解：用于将其他类型的格式格式化成Ndef格式123456public static NdefFormatable get (Tag tag)//Get an instance of NdefFormatable for the given tag.Returns null if NdefFormatable was not enumerated in getTechList(). This indicates the tag is not NDEF formatable by this Android device.public void connect ()//Enable I/O operations to the tag from this TagTechnology object.public void format (NdefMessage firstMessage)//Format a tag as NDEF, and write a NdefMessage. NFC 前台调度将处理NFC标签的权利交给某个窗口（优先级最高）1、在onCreate（）中获得NfcAdapter对象；2、创建与该Activity关联的PendingIntent；3、指定一个用于处理NFC标签的窗口；通常会在onResume（）方法中采用nfcAdapter.enableForegroundDispatch()来实现；4、禁止窗口处理NFC标签。采用 nfcAdapter.disableForegroundDispatch()来实现。 前台调度中onNewIntent方法的使用如果IntentActivity处于任务栈的顶端，也就是说之前打开过的Activity，现在处于onPause、onStop状态的话，其他应用再发送Intent的话，执行顺序为：onNewIntent，onRestart，onStart，onResume。launchMode为singleTask的时候，通过Intent启到一个Activity,如果系统已经存在一个实例，系统就会将请求发送到这个实例上，但这个时候，系统就不会再调用通常情况下我们处理请求数据的onCreate方法，而是调用onNewIntent方法。系统可能会随时杀掉后台运行的Activity，如果这一切发生，那么系统就会调用onCreate方法，而不调用onNewIntent方法，一个好的解决方法就是在onCreate和onNewIntent方法中调用同一个处理数据的方法。onNewIntent()中的setIntent()和getIntent()，如果没有调用setIntent(intent)，则getIntent()获取的数据将不是你所期望的。所以最好是调用setIntent(intent)，这样在使用getIntent()的时候就不会有问题了。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"},{"name":"NFC","slug":"NFC","permalink":"http://iyounix.com/tags/NFC/"}]},{"title":"2016Q2总结——春花夏拾","slug":"Life/InnerPath/16-07-172016Q2总结——春花夏拾","date":"2016-07-17T04:22:00.000Z","updated":"2018-11-08T01:30:40.291Z","comments":true,"path":"2016/07/17/Life/InnerPath/16-07-172016Q2总结——春花夏拾/","link":"","permalink":"http://iyounix.com/2016/07/17/Life/InnerPath/16-07-172016Q2总结——春花夏拾/","excerpt":"","text":"掐指一算大概有三个月有余没有写点什么了。也不知道是因为太过忙碌还是太过堕落，现在回想起来竟然想不起一二，索性将周报和[CSDN上的文章][1] 翻出来看一看，这三个月到底自己干了什么。按顺序逐一细表吧。 遗忘四月份在移植 Mipi LCD 和 TP，写了五篇文章，其中《展讯平台启动流程（uboot）》和《Mipi LCD 加载流程分析》，自认为这两篇的内容质量还不错，是追着代码一点一点抠出来的。还隐约记得当时自认为对 LCD 和 TP 的移植已经掌握的比较到位了，但是现在在不看原来笔记的情况下却已经无法回顾起来了，时间真的是个很残忍而现实的东西啊。不过也无所谓了，总有个厚积薄发的过程。想起乐乐说的，知识的学习分为两个阶段，第一个阶段是通过理论和实践将其掌握，第二个阶段仅仅是熟练度的问题。忘了就忘了吧，相信后面在移植 LCD 和 TP 的时候应该会碰到更多有意思的问题，也更能加强这方面的熟练度了吧。 自律关于自律，很多问题的产生其实究其根本就是自律性不够强，时常需要外界的环境来约束自己。入职转瞬已经一年，前几天我们将一周年照片拿出来看，最让人惊叹的就是 Hugo，硬生生从一个 180 的胖子减到了 130的瘦子，之前也听说过如此励志的例子，但是发生在身边的小伙伴身上的这还是第一次碰到。对别人成功的惊叹之余更多的还是对自己缺陷的无奈和愤怒。二月底报了一个清华大学的软件工程专业课，每周大概五个小时的课，课可以任何时候去听，到七月份初的考试。规划的非常美好，每周也就五个小时，但是实践的时候往往是两三周的课拖着觉得不行了然后一起上，作业也很多，累积着堆积如山的作业越到后面越是无力完成。一来是对报名费的不舍，一来是想这多学一点是一点的心态，一直断断续续的去学习着，效率自然底下，甚至还浪费了大半个月的工作时间去完成这课程的作业。这种不全力以赴却又藕断丝连不忍割舍的做法确实愚蠢，且放后面再说，不过如若这几个月自律一些的话，现在应该已经拿到毕业证了吧。抱怨归抱怨，问题还是需要解决，怎么做呢，具体而言抱团行动以互相督促，制定合理计划，加上加强锻炼可能会有一定效果。就像 Keep 上说的自律给予我自由。那么就看看三个月之后的结果吧。 放弃记得一年前的某篇博客上面有写，当时还没有学会舍得，转瞬一年的现在，有些事情处事仍然不够果断。前段时间那个软件工程的课程采用的是 Python 语言，当时学了近一个月后我就发现这个于现在的我其实并没有多大帮助。工作中不会用到 Python，这些软件工程的思想也不符合现在的开发模式，一切不能够付之于实践的知识都不能称其为掌握。现在回顾起来，大部分学习内容也还是没有吸收，只记得许多名词，顶多当别人讲到某个概念的时候不至于两眼一抹黑，但这样的半知无解的学习并没有什么意义。最重要的是帐没有算清楚，因为舍不得报名的几百块，有些周末还整天得去补课，甚至四五月份的工作日还抽了一部分时间去完成课后作业，现在想想确实后悔，浪费了至少大半个月。我事后想想有些取舍很明显的事情为什么当时就无法判断，进行果断的选择呢。其实是因为眼界太局限了，视野仅仅的局限在了这一个季度之中，我应该尝试把时间刻度拉长一点，眼界放大一点来看。比如我要是用一年为刻度来看这个问题，对于一年而言，这个 Python 课程是否重要？这几百多钱多么？显然答案都是否定的。刻意的将眼界放开一点去思考问题，再进行决策结果可能会好许多。 适应性五月份完全摆脱了 Windows环境，耗费一个星期来搭建 Linux下的开发环境。虽然一直都知道 Linux 下更适合进行开发，但是始终割舍不掉 Windows环境下的各种诱惑，刚刚转变系统的时候，真的有诸多不便，但是人真的是个适应性很强的生物，没有什么是必不可少的，两个月后的现在能够非常高效的在 Linux 环境下进行开发，这也算是度过了困难期后的幸福了吧。生活中亦然，像之前租房小区离公司半小时车程，每天都能七点起床吃完早餐八点一刻到公司，现在搬到公司五分钟步程的单间反而时常八点才醒。无论是困难的环境还是轻松的环境都很容易就进入状态，看来有时候还是需要对自己狠一些才行。 没有什么事情是没有意义的五月下半月到六月底真的是忙碌的一个月，因为一个季度算是进入了下旬，然而工作上的任务还没开动，于是忙忙碌碌的开始赶起了进度。这一个半月移植了 MSensor 和 GyroscopeSensor，其中因为一些小问题卡壳了很久，当时尤其烦躁，觉得在这些看起来没什么意义的问题上浪费了太多的时间。不过其实在 close 掉这些小问题之后我才明白，这些小问题就是所谓的经验。知识系统框架的问题可以通过理论的学习来积累，但是有很多小问题只有在实践的过程中才会碰到，我想这些零零碎碎的只有通过实践才能 get 的点就是所谓的经验。而且没有什么东西会是徒劳的，想起原来大学时期给自己的一些很无聊的压力，比如周末睡个懒觉就觉得好堕落，但是又无法改正，于是在懊恼中继续睡懒觉。但是实际上没有什么东西是徒劳的。多睡了一会觉虽然不一定精神就会好一些，但是身体的状态绝对是在正增长，这些状态的改善一定会接下来的工作中得到体现的。以上。 总结围绕 Q2 做了一下总结，总得来说虽然走了一些不必要的弯路，但是还算充实，另外一年真的好快，一瞬间工作已经满一年了。现在回头看看这一年的收获好像并没有预期的多，有些许遗憾但也不算后悔，而且我知道有些东西是已经潜移默化发生改变了的。后面就量化的看一下元旦时定下的计划完成情况吧。 [1]: http://blog.csdn.net/dearsq/article/list/2 Linux驱动的几个模块要熟知。到9月份要完成以下几个模块的学习 LCM（MIPI接口设备） TP（I2C） GSensor（SPI接口） MSensor（I2C接口） GyroscopeSensor（I2C接口） P/L Sensor Camera 熟悉Linux内核中的常用知识点： 并发控制（中断屏蔽、原子操作、自旋锁、信号量、互斥体） 阻塞与非阻塞I/O（等待队列）、轮询操作 中断与时钟 I2C/SPI 两类设备的驱动模型 十二本小说硬指标。需要抽时间列个书单，才能有计划的进行阅读任务。 黑客与画家 这么慢，那么美 白夜行 岛上书店 天才在左，疯子在右 蔡康永的说话之道 特立独行的猫《不要让未来的你，讨厌现在的自己》 格局逆袭 Stroy of Your Whole Life 锻炼。指标为 Keep 上面的任务争取每天完成。 博客要继续坚持最少两周一更。这个养成习惯就好了。另外一些专业性知识也会有条理的梳理在 CSDN 上，更多的是供以后自己查阅吧。 以上五点为接下来大半年的大致计划，一些零碎的选做任务： 开始了解理财投资相关的知识 学游泳 技术方面还算是在循序渐进的完成，而且值得高兴的是公司换座位换到了两位很厉害的前辈中间，感觉接下来有的请教了。 生活方面令人惊诧的是比自己想象中要快的多的学会了游泳，大概一个月的时间，去了游泳馆六次，竟然从一个旱鸭子走到了好歹淹不死的地步了。更加验证了一个行之有效的学习方法，模仿&amp;实践。 书的话三个月只看了两本，这个在完成工作任务的情况下尽量完成吧，不做强求了。 这个博客的话两周一更，即一个月两篇，这个没有做到，四五六月没更，虽然CSDN上更新的比较频繁（四月11,五月12,六月6），但犹豫了一下还是不给自己退路了，技术向的内容还是不算了，还是差六篇，慢慢补上。 那么，继续加油吧，做更好的自己。 晚安。","categories":[],"tags":[{"name":"InnerPath","slug":"InnerPath","permalink":"http://iyounix.com/tags/InnerPath/"}]},{"title":"未来先见","slug":"Life/InnerPath/16-03-29未来先见","date":"2016-03-29T15:00:00.000Z","updated":"2018-11-08T01:30:40.291Z","comments":true,"path":"2016/03/29/Life/InnerPath/16-03-29未来先见/","link":"","permalink":"http://iyounix.com/2016/03/29/Life/InnerPath/16-03-29未来先见/","excerpt":"","text":"我和小伙伴对带薪参加参会这种事情向来是乐此不疲的。《2016中国智能硬件创新创业互动论坛》于 3月 29 日在华强北圣廷苑酒店举行。总的来说这次的论坛比较官僚，干货颇少，乏善可陈，与其说是创新互动论坛，不如说是产品发布会，每个分享者都完全将演讲变成了自家产品的介绍，着实让人尴尬。不过也并不是一无是处，只是得费更大的功夫才能从每个演讲者的感慨中挖掘到他们创造产品或者带领团队的过程中排除产品本身以外真正更有价值的东西。那就挑两个笔记多一点的说下收获和心得吧。 唯乐产品心得 【Weloop 牛浩田】总的来说有几点： 理解用户需求： 不要轻信用户的话 数据更能说明问题 不要试图满足所有用户 是否有更好的替代品 不要做噱头 噱头会缺少独立性 噱头会减少用户口碑 噱头让研发团队失去成就感 噱头很伤害品牌 噱头并不会有助于销售产品 竞争对手做噱头，应该怎么办？ 真诚并坚持自己的优势 领先全领域才算优势 优势，是品牌最大的口碑 保持这种优势，才能扩大口碑 注意如何建立新的优势 发现可能被用户爱上的部分 基于真实的用户场景 超出用户的与其，给出惊喜 发现哪些让用户形成习惯的部分 当心不良体验带来的破坏 真诚赢得信赖 用户并不感激廉价产品 良好的体验才是最大的实惠 不要做骗子 珍惜每一个用户，建立真正的信任 另外牛浩田认为，硬件创业的门槛会比较高，不但需要前期投入很多资金，而且团队搭建的复杂度和所需人才的类型都会高过单纯的互联网行业。牛浩田为准备进入硬件领域的创业朋友在产品定位的方法上支了几招：要争取成为小领域的王者，避免在早期就和大公司的产品全面竞争，而且要有沉淀下来做5年的耐心。 实际上很多地方的观点我都是不赞同的。 比如演讲的第二条，不要做噱头，牛浩田说不要做噱头，因为噱头这个东西很容易做，大家都有，所以不具有独立性；这样就降低了口碑；研发团队的大家都知道这个是噱头，也不会用心去做；所以很伤害品牌；当用户拿到产品后，期待噱头带来的体验的时候发现并没有多少体验，于是很失望，这个不会有助于销售产品。我觉得这部分就是在瞎扯。 究其根本原因可能是对噱头这个概念理解的定位有所不同，也有可能是牛浩田的 Weloop 手环在这个地方栽了跟头所以才有此感想。我觉得噱头是一款产品卖的好坏的一个很重要的部分。就好比 Vivo 的快充，这个就是噱头，但是他并不缺少独立性，没有哪家能做的有他好，口碑也建立起来了，团队成就感这个我没有证据也就不置可否，前面的好处为品牌形象的塑造也增加了好处，所以这势必会使产品销量得到增加。 还比如演讲其中牛浩田还说，要争取将产品做好，功能实现好再上线，有助于用用户口碑的建立。这点我也不大赞同，等研发团队真正把产品做好，恐怕市场要么被别的人捷足先登抢去了，要么是这个的红利期已经过去了。我主张的看法的快速迭代，勇于试错。最开始可以小批量量产，并且提供和用户互动的渠道，这样才能真正的了解用户需求，如果一心闭门造车，怎么会做出真正契合用户心意的产品呢，即使有市场调研，哪有直接和用户交流使用体验来的更加直接呢。而且为用户增加参与感，让用户觉得自己参与到了产品的开发中，可能会更加提升口碑与用户粘性。 XIMMERSE VR市场分析这个确实提供了不少 VR 行业内的调研情况。凶猛的各种数据砸下来着实让人信服。主要说的是虚拟现实领域创业的这把火则是从去年延续到今年，有越烧越旺的趋势。唐师建认为，虚拟现实的发展方向是移动和社交，VR和VR交互会带来社交革命，它能够创造出强烈的存在感，将家人朋友带入同一空间，消除距离的隔阂。 另外还有一个值得一提的观点。VR 技术很难，目前国内有很多人希望涌入到这个市场中，投资人也有大把的钱正准备往里面倾倒。但是实际上，唐有一个观点是，VR 技术远比我们想象的烧钱，相比较手机市场，这个地方预期的市场回报实在太少了，但是 VR 真正烧钱的地方在于它的建模，渲染，美工等方面。而现状是投资者顶多投几百万到几千万，要想做出一款成熟的 VR 产品，这些钱是远远不够的。所以存在一种可能就是，大家对这个东西过于盲目乐观了。不过，这种事情，就让时间和市场来检验吧。 另外还有机器人、无人机。都是常识性的科普，并未涉及到多少干货,也暂且不表。另外还有一点额外的感触就是参加活动一定要慎重，这种官僚性质比较强干货比较少的选择的时候得注意。同时也要加强倾听的能力，会学抓住别人表达的重点非常重要。 好吧，以上。","categories":[],"tags":[{"name":"InnerPath","slug":"InnerPath","permalink":"http://iyounix.com/tags/InnerPath/"}]},{"title":"2016Q1总结","slug":"Life/InnerPath/16-03-282016Q1总结","date":"2016-03-28T14:00:00.000Z","updated":"2018-11-08T01:30:40.291Z","comments":true,"path":"2016/03/28/Life/InnerPath/16-03-282016Q1总结/","link":"","permalink":"http://iyounix.com/2016/03/28/Life/InnerPath/16-03-282016Q1总结/","excerpt":"","text":"不知不觉 3 个月一晃就过去了。现在看看之前定的计划不禁感叹计划没有变化快。总结一下这三个月所学的东西并且制定下一个阶段的计划吧。这三个月做了什么： Android APP 编写，只是初步了解吧，四大组件的模型还是一些常用控件的用法。了解基础的 Android 调试技巧。 NFC 相关的知识，将 PN548 移植到了 SC7731 的样机上，最后 NFC 的三大功能都能实现。 调整一下之前所定的计划内容： 以NFC为切入点，将内核的基本功打扎实，量化的 标准是核心驱动理论全部信手拈来这个太笼统了，大致方向是正确的，在下面列举具体的规划。 了解链接装载与库的整个流程，量化的标准是俞甲子那本书前面的所有问题都能说的出所以然这本书太深了，先不看，转而先通过上面的第一点了解 Linux 中设备驱动的框架。编译流程的切入点从 uboot 开始。通过对 Uboot 的分析来加深对编译链接装载的理解。 看十二本小说，一个月一本，十二篇读后感。这个需要坚持。 坚持锻炼，身体确实是本钱，量化的标准就是 10 KG 的哑铃可以轻松做50个。这个需要坚持。 博客实现两周一更。这个需要养成习惯，争取养成每个周末都写一些随笔的习惯。 TOEIC 分数达到555分。这三个月完全没有提升英语相关的技能。时间是在太有限了，重心先放在提升专业技术能力。明年开始有意识的提升英语技能，主要重心应该放在口语方面。 掌握JAVA基础。 JAVA基础通过做APP 应该算是掌握了，虽然不是具体系统的学习，但是读 JAVA 程序算是没问题了。而且 JAVA 暂时对 驱动层 的学习没有帮助，暂且优先级靠后。语言学习方面 C &gt; C++ &gt; Python &gt; JAVA 下面制定一下新的计划，就不按照一年来计划了，大概算是接下来6-9个月的计划吧： Linux驱动的几个模块要熟知。到9月份要完成以下几个模块的学习 LCM（MIPI接口设备） TP（I2C） GSensor（SPI接口） MSensor（I2C接口） GyroscopeSensor（I2C接口） P/L Sensor Camera 熟悉Linux内核中的常用知识点： 并发控制（中断屏蔽、原子操作、自旋锁、信号量、互斥体） 阻塞与非阻塞I/O（等待队列）、轮询操作 中断与时钟 I2C/SPI 两类设备的驱动模型 十二本小说硬指标。需要抽时间列个书单，才能有计划的进行阅读任务。 黑客与画家 这么慢，那么美 白夜行 岛上书店 天才在左，疯子在右 蔡康永的说话之道 特立独行的猫《不要让未来的你，讨厌现在的自己》 格局逆袭 Stroy of Your Whole Life 锻炼。指标为 Keep 上面的任务争取每天完成。 博客要继续坚持最少两周一更。这个养成习惯就好了。另外一些专业性知识也会有条理的梳理在 CSDN 上，更多的是供以后自己查阅吧。 以上五点为接下来大半年的大致计划，一些零碎的选做任务： 开始了解理财投资相关的知识 学游泳 加油吧，珍惜时间，做更好的自己。","categories":[],"tags":[{"name":"InnerPath","slug":"InnerPath","permalink":"http://iyounix.com/tags/InnerPath/"}]},{"title":"世殊事异，所以兴怀","slug":"Life/InnerPath/16-03-15世殊事异","date":"2016-03-15T14:00:00.000Z","updated":"2018-11-08T01:30:40.291Z","comments":true,"path":"2016/03/15/Life/InnerPath/16-03-15世殊事异/","link":"","permalink":"http://iyounix.com/2016/03/15/Life/InnerPath/16-03-15世殊事异/","excerpt":"","text":"最近发生的事情太多了，有点让人喘不过气，最近雨也一直下个不停，感觉整个人都发霉了。趁着写博客，谈谈最近的烦心事吧。一则倾吐，二则条分缕析，希望能够将这些烦心事杀掉。 离职潮一个个的都走了，最开始 Boom 走的时候是第一次与熟人分别的时候，那时候应该也是最难受，后来是 Arno 前辈，Nina，Zaki 梓民，赖政，再后来 Bear 哥和 Code 叔，本来已经习以为常了，以为自己完全麻木了。但是到现在两个室友 Raj 和 Jiro 也走了，就感觉像被一块裹过尸体的老旧绷带缠住了心，越裹越紧，不知道是什么感觉，只觉得有点恶心也有点喘不过气。似乎大家都心照不宣的没有对老大说真正的离职原因。老大也假装着或者真的不知道大家离开的缘由。 工资真的太特么低了。 每次在深圳和同学们或是好友聚会的时候，无论多么刻意回避这个话题，最终都会扯到工资。 无论是自尊也好，还是虚荣也罢。这个东西真的是太现实了。都说人比人比死人，但逃避反正不是我的性格，而且不说和自己实力相当的比较，就说实际上就纯粹的论技术而言完全没有自己厉害的，实际上和他们工资却差上 2-3 K。所以说走是注定的。在完成 Q1 总结里面的计划的任务后，应该就是离开的时候。 这时候另一个让我伤感和惆怅的问题就来了，自己是个很害怕分别的人，似乎实际上自己比想象中粗线条的自己更加重感情。记得当时 万总 得知 Jiro 走的时候，跟我说，“你不要也走了啊，不然我会伤心死的”，因为那时我确实有走的冲动，所以虽然笑着回他“怎么会”，但是内心风起云涌。 Hugo Fawn 他们几个在公司附近住着互相照料着感觉挺好的，或锻炼，或出游。大家每天也都非常开心。但是最近自己下意识的疏远着大家，因为我有点害怕，害怕如果很熟悉的话，离别一定也会很伤感吧。 然而没有谁是必不可少的。 Jiro 走的时候当时听到有人说，嗯？黄金程是谁？ 我顿时就释然了，任何一个人的离职也不过是这一两天内大家饭桌上的谈资，“哎，怎么又走了一个”“唉，工资真的低啊”，然后之后这些感慨就随着餐盘中的剩菜剩饭一起倒在了垃圾桶里。我想到时候自己走的时候不会说任何话，只会轻轻地和师兄和Lanny姐打上招呼。然后静静离开。 因为没有谁是必不可少的。 似乎不需要利用列出利弊的方法来分析离开与否，答案是肯定的。但还是梳理一下思路吧。 离职的利： 工资毋庸置疑更高，现在已经触底了。 环境可能更能让人有斗志，虽然说还是看个人，但是这里的环境确实太让人安逸。另外在这里个人额外的努力是无法被量化计算的。虽说权当是为了提升自己吧。但是相比较而言更多公司的情况是，让大家在提升自己的同时获得物质上可以提现的成效。 发展前景应该更广阔，在台企想要得到一定程度的提升似乎不大现实。 离职的弊： 平台注定会更小，这家公司的平台应该是最大的了。接受新东西的渠道肯定更少了。 朋友，也是最不想提及的一个话题，但是没有谁是必不可少的，真的是好友的话不管到哪应该都是好友吧。 这半年，唯一需要做的就是疯狂地提升自己的技术，摒弃掉一切外物。时刻提醒自己当初选择来深圳的目的。 最后摘抄无意中看到的一段话自警： 仅仅是出于攀比心理，看到同学、朋友都混得不错，产生了焦虑感，从而想换换工作的，也还是暂时静一静。当一个人混得不好的时候，总习惯于向外去寻找原因，认为是平台不好，行业不好，领导不好，产品不好等等，而忽略了内因。人家干得好，不见得只是人家的公司不错，更可能的是内在的某些东西在起作用。你如果不调整好自己，只是一味地想要找到各方面都契合你的平台，无异于缘木求鱼，可能跳到哪里都是一样。 仅仅是想多挣几两银子的，不建议跳槽。收入的增长是一个综合而又缓慢的过程，在一个高度市场化的环境中，这主要是和你的综合素质相关的。虽然我们不用添加“厚积薄发”的标签，但只要你能力到了，收入自然就起来了。更多地看重眼前利益，而忽略了自身的积累，只能是短跑选手，有爆发力，而没有持久性。起个大早而赶个晚集的，在职场中比比皆是。我很认可一种说法：那些最终挣到大钱的，都不是聪明人，而是一些看上去有点笨，但善于坚持的人。 出于一时之愤，想逞一时之快的，建议至少等到心情平复了再来考虑换工作的事。你可能是被老大痛斥了，绩效分数被打低了，年终奖没有达到自己的预期，承诺没有兑现等，因此愤而辞职，很多时候还都是裸辞。但回过头来想想，你爽是爽了，可接下来该怎么办呢？各种论坛、朋友圈当中会因为你的快意恩仇而给你击节叫好，但煤气公司、水电公司、电话公司、房东可不会因此而少收你一分钱。当你处于没有后路的情况下，下一份工作就有点逼不得已，很可能就踩进了又一个泥坑。所以客观一点，理性一点，通盘考虑一下，再来选择自己的最佳路径。","categories":[],"tags":[{"name":"InnerPath","slug":"InnerPath","permalink":"http://iyounix.com/tags/InnerPath/"}]},{"title":"Android5.1 添加自定义开机动画（视频）并去黑屏","slug":"Android_App/[Android5.1] 添加自定义开机动画（视频）并去黑屏","date":"2016-03-14T15:01:05.000Z","updated":"2018-11-08T03:21:39.662Z","comments":true,"path":"2016/03/14/Android_App/[Android5.1] 添加自定义开机动画（视频）并去黑屏/","link":"","permalink":"http://iyounix.com/2016/03/14/Android_App/[Android5.1] 添加自定义开机动画（视频）并去黑屏/","excerpt":"","text":"[TOC] 平台 ：RK3288OS：Android5.1参考文章：Android系统的开机画面显示过程分析（罗升阳） 补丁如下源码分析及修改方式关于开机动画的流程主要代码在framebuffer/base/cmds/bootanimation/bootAnimation.cpp从 BootAnimation::threadLoop() 中的我们可以看到12345if(mZip == NULL) &#123; r = android(); &#125; else &#123; r = movie();&#125; 根据 mZip（这是一个叫做 bootanimation.zip 的文件）是否存在，决定调用 android() 接口还是 movie() 接口。 android()如果没有 zip 文件进入的就是这种方式。会加载”images/android-logo-mask.png”和”images/android-logo-shine.png” 这两张图片，前者是镂空的 ANDROID 字样，后者是一副很长的银白黑渐进的背景图，通过固定前者，移动后者，实现 ANDROID 字样的反光效果。想修改android闪动的那两张图片的话，最简单的方法是直接替换图片（图片在 /frameworks/base/core/res/assets/images），如果懂 openGL 的话也可以自己做酷炫的动画。 movie()如果有 bootanimation.zip 文件进入的就是这种方式。1#define SYSTEM_BOOTANIMATION_FILE \"/system/media/bootanimation.zip\" 会加载 bootanimation.zip 中的内容。zip 文件中实际是很多帧图片的组合，通过多帧图片的逐步播放实现动画的效果。所以把做好的动画拷贝到编译好对应的目录下即可，然后执行make snod整合进 img 包就可以看到效果了。具体制作 bootanimation.zip 的文章参考这两篇：http://blog.csdn.net/mlbcday/article/details/7410509http://luq1985428.blog.163.com/blog/static/12243116220131198011812/但这样默认是没有音乐的，还需要实现一个 playMusic() 的接口，来同步的播放音乐。具体实现 playMusic() 接口的方式参考这一篇的 “1.播放音乐”：http://www.voidcn.com/blog/longtian635241/article/p-2095371.html从 mp4 中提取音频为 ogg 或者 wav 格式的网站有http://media.io/缺点是 多帧图片由于画面色彩丰富、动画较长，这样做出来的 zip 会比较大，播放效果会出现明显、严重卡顿 播放时music时可能出现动画和声音不同步 所以我们可以调用 mediaPlayer 的接口来实现播放视频（mp4） 自行添加 video 接口修改 ThreadLoop 中的判断123456789 // We have no bootanimation file, so we use the stock android logo // animation.- if (mZip == NULL) &#123; + if (mVideo) &#123;//这里的 mVideo 是一个标志位，表示是否有开机视频+ r = video();+ &#125;else if (mZip == NULL) &#123; r = android(); &#125; else &#123; r = movie(); 我们在 ReadyToRun 中实现 mVideo 的判断。123456789101112131415161718@@ -359,6 +362,7 @@ status_t BootAnimation::readyToRun() &#123; mFlingerSurfaceControl = control; mFlingerSurface = s; + mVideo = false; // If the device has encryption turned on or is in process // of being encrypted we show the encrypted boot animation. char decrypt[PROPERTY_VALUE_MAX];@@ -366,6 +370,9 @@ status_t BootAnimation::readyToRun() &#123; bool encryptedAnimation = atoi(decrypt) != 0 || !strcmp(\"trigger_restart_min_framework\", decrypt); + if (access(BOOTANIMATION_VIDEO, R_OK) == 0) + mVideo = true;+ ZipFileRO* zipFile = NULL; if ((encryptedAnimation &amp;&amp; (access(SYSTEM_ENCRYPTED_BOOTANIMATION_FILE, R_OK) == 0) 下面可以开始添加 video 接口了12345678910111213141516171819202122232425262728293031+bool BootAnimation::video()+&#123;+ const float MAX_FPS = 60.0f;+ const bool LOOP = true;+ const float CHECK_DELAY = ns2us(s2ns(1) / MAX_FPS);+ sp&lt;IMediaHTTPService&gt; httpService;+ eglMakeCurrent(mDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);+ eglDestroySurface(mDisplay, mSurface);+ /*+ float asp = 1.0f * mWidth / mHeight;+ SurfaceComposerClient::openGlobalTransaction();+ mFlingerSurfaceControl-&gt;setPosition(mWidth, 0);+ mFlingerSurfaceControl-&gt;setMatrix(0, 1 / asp, -asp, 0);+ SurfaceComposerClient::closeGlobalTransaction();+ */++ sp&lt;MediaPlayer&gt; mp = new MediaPlayer();+ mp-&gt;setDataSource(httpService, BOOTANIMATION_VIDEO, NULL);//设置播放资源+ mp-&gt;setLooping(true);//确定是否播放循环+ mp-&gt;setVideoSurfaceTexture(mFlingerSurface-&gt;getIGraphicBufferProducer());+ mp-&gt;prepare();+ mp-&gt;start();+ while(true) &#123;+ if(exitPending())+ break;+ usleep(CHECK_DELAY);+ checkExit();+ &#125;+ mp-&gt;stop();+ return false;+&#125; 如果要实现开关机动画不同也可以增加一个判断。这里的 BOOTANIMATION_VIDEO 为 mp4 的路径，setDataSource 接口有多种重载方式，这里采用 url 的方式。12+#define BOOTANIMATION_VIDEO \"/system/media/bootanimation.mp4\"+#include &lt;media/IMediaHTTPService.h&gt; 最后修改头文件，添加增加的两个成员变量/cmds/bootanimation/BootAnimation.h123456789@@ -106,6 +106,8 @@ private: EGLDisplay mSurface; sp&lt;SurfaceControl&gt; mFlingerSurfaceControl; sp&lt;Surface&gt; mFlingerSurface;+ bool mVideo;+ bool video(); ZipFileRO *mZip; int mHardwareRotation; GLfloat mTexCoords[8]; 至此已经完成 video() 接口的编写了。（具体 MediaPlayer 的用法参考的 http://blog.csdn.net/ddna/article/details/5176233 ）后面可以在 /system/media/ 中添加 bootanimation.mp4 尝试能否播放 mp4。 开机视频前黑屏 5s是由于等待电池的后台服务启动导致的，屏蔽如下代码。 frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp 屏蔽后黑屏时间减为 1s 左右。","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"},{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"瑞芯微出差记","slug":"Life/InnerPath/16-02-24瑞芯微出差记","date":"2016-02-24T14:00:00.000Z","updated":"2018-11-08T01:30:40.291Z","comments":true,"path":"2016/02/24/Life/InnerPath/16-02-24瑞芯微出差记/","link":"","permalink":"http://iyounix.com/2016/02/24/Life/InnerPath/16-02-24瑞芯微出差记/","excerpt":"","text":"//话说这是第一次出差，确实应该值得一记，但开始动笔的时候却又不知道该从何处下手。那还是按照一贯的做法想到什么写什么，最后再稍稍整理好了。第一次出差，颇有些感受，技术方面会在 CSDN 上更新，在这里就只谈感受吧。 一款产品的诞生这三个月算是第一次较为完整了参与了一款电子产品的研发，颇有些感受。想要从两个角度来说。 按分工一款电子产品包含很多部分模块 ，尤其是高度模块化分工合作的现在，一款产品的诞生只需要负责各个部分的公司各司其职，通力合作就好了。拿这次做的这款儿童手表举例。 品牌客户（终端客户） A | 设计师 项目经理 方案厂商 B | 硬件工程师 系统软件工程师 项目经理 代理厂商 C | 硬件工程师 驱动软件工程师 芯片原厂 D | 硬件工程师 驱动软件工程师 品牌客户（对代理商或原厂而言称作“终端客户”）A 公司定义产品，提供了产品的概念和设计（即大部分产品的定义）。完成了定义后接下来要做的就是找到一个具有相关经验的方案厂商 B 。 B 将产品具象化，就是根据 A 的定义来对物料的选型，或者选择现有的代理商提供的现成的模块来做。A 和 B 已经确定了大致要是用到的硬件或硬件模块，他们就需要采购这些东西，于是 A 和 B 就找到了代理商。 代理商代理原厂的芯片，甚至将这些芯片做成方案（模块）来进行推广。A 和 B 找到能满足需要（价格，服务，物料覆盖面）的代理商，然后和代理商提供的技术支持一同去攻关这款产品。 其中值得一说的是，代理商的定位，原厂因为所生产的芯片产量大、种类广、客户需求丰富所以无法对市场上如此客户一一提供技术支持。他们需要很多代理商来代理他们的产品，由代理商去寻找客户并且销售芯片，原厂减少了搜索客户和为客户提供技术支持的成本，代理商从中赚取了差价，而原厂只需要对部分代理商提供技术培训，或者是挑选部分出货量大的优质客户来进行技术支持。 再举一个接触到的例子，手机中的 NFC 模块。比如魅族的魅蓝手机、酷派的部分机器的 NFC 是由我们公司进行代理。这些 魅族/酷派 被我们称为终端客户/品牌客户。他们和前一个例子不同的是他们有自己的研发团队，但是这些研发人员也不是负责手机的整个模块，大部分是负责上层的应用（UI 设计、系统 APP 等） 或者 手机外观的设计等。他们也会找到代理商或者方案厂商来采购现成的模块。当所有模块都组装好且调试完毕测试成功后，一个产品也就诞生了。 延伸出来两点感触： 1.做手机真的是越来越容易：几乎是一站式采购，大部分模块都有成熟的解决方案，只需要将这些方案拼凑在一起即可。最明显的体现就是2000元以下的手机，大部分都是将现在既有的模块进行拼凑与组装，超快速的迭代，没有固定的技术支持团队为该型号的手机提供技术支持（主要是固件更新及软件优化）那么这些产品的质量底下，使用寿命堪忧也不是没有原因的了。 2.做一款好的产品可以说只需要一个好的IDEA。 从之前这个模型来看，每一个环节都有相对应的公司来负责，看似与上下每个公司都分不开，但是最最核心的还是产品本身。因为所有的环节都有替代品但唯独产品设计与定位本身是需要创造的。只要有了一个成功的想法，接下来需要的就是说服投资者为你投资，然后找到方案厂商帮忙选型..提供解决方案..等等水到渠成。 按时间最开始接触这个项目的时候是参加软件方面功能定义的交流会。参会人员有终端客户的项目经理和设计师，方案厂商的项目经理与系统工程师，代理厂商的软硬件主管，原厂的软硬件主管（类似技术总监），至于跟在大牛们屁股后面打酱油的我就忽略掉吧。在交流会上终端客户会粗略介绍想要实现的每一个软件模块，并进行分工，由主管（技术总监）们评估功能实现的可能性和大概所需时间。 接下来就是研发过程，在大家分配好任务后每个 Team 都会回去对所负责功能的实现进行具体的评估。然后按照上面所讲的模块层次进行沟通。比如我们代理商的RD/FAE会和方案商的 RD进行沟通，然后由方案提供商的项目经理将情况反馈给终端客户。 在研发工程中免不了各种大大小小的会议，探讨某个模块的具体实现或者因为技术瓶颈需要修改某些功能。 最后在所有模块都搞定了就开始进行整机测试。这之前还有各个模块的单独测试。 再就是PP/MP 试产和量产了。 总结突然发现一开始写就停不下来了。其他想说的也还有很多，比如原厂的工程师们的个人特点、终端客户们的个人特点，还有工作环境等等这些之间都有着很微妙的联系，非常有意思。不过也不大想赘述了。总的来说，这次出差让我对项目完成的一个流程有了大致的了解。那么继续在磨砺中收获和成长吧。明天也要好好努力哟！","categories":[],"tags":[{"name":"InnerPath","slug":"InnerPath","permalink":"http://iyounix.com/tags/InnerPath/"}]},{"title":"十二分之一","slug":"Life/InnerPath/16-01-30十二分之一","date":"2016-01-30T15:12:30.000Z","updated":"2018-11-08T01:30:40.291Z","comments":true,"path":"2016/01/30/Life/InnerPath/16-01-30十二分之一/","link":"","permalink":"http://iyounix.com/2016/01/30/Life/InnerPath/16-01-30十二分之一/","excerpt":"","text":"不得不感叹一句时间这玩意真的是越跑越快啊。一转眼2016年就走了十二分之一了。而且可能感叹着感叹着，这辈子也就这样过去了。抱歉又开始胡思乱想了。其实这一篇博文纯粹是为了应付年初许下的诺言，每两周必须要写点什么才行。所以就放开点胡乱的想吧，想到什么就唠嗑什么。 不愿意做的事这个写东西不就是一个不愿意做的事么，于是从这个地方开始想。仔细一想来公司了不愿意做的事情还真不少。 最开始是十一月份有个客户需要 Android Watch 的 APP ，大家都是搞驱动的谁弄过这个啊，于是赶鸭子上架非让我来搞，最初也是因为有点兴趣便承了下来。但是，谁知道这一搞就过去了一个多月。项目远比我想象的复杂的多，连 JAVA 都没有系统地学过，现在突然让人做 Android ，难度当然是有的，但是确实也收获了不少，其中最值得分享的一点是一种和学校学习完全不同的学习方法。这个放在下一节来说。 然后是公司2016年公司的校招计划，可能是转正答辩把自己的本性暴露的更多了一点，被 Candy 抓住了要帮忙准备2016年校招的事情。写文案不说，三月还得跟着 HR 们一起去跑学校。说实话，最初的真的是很厌恶这种感觉，自私的说，我只想好好的把技术知识积累好，不想过多的分心到其他的事情上，所以做事的时候非常抵触。但是老板的任务又不得不完成啊，所以 deadline 的前一天晚上才开始准备完成任务。还记得当时自己坐在沙发上，抱着电脑，就那样直直地盯着空白的 word 文档，以为自己在想着文案策划，但实际上满脑袋充斥的都是抵触之情。到一点的时候，开始动笔了，怎么写，抄别人的呗，花了两个小时搜集资料，又花了一个小时草草码字总算应付了事。一写完就睡着了。第二天六点多从沙发上冻醒了，洗了个热水澡便去公司修改措辞。一整天晕晕呼呼自己工作的事情效率也变得格外之低。晚上和室友一起回家的时候，我狠狠地抱怨了一顿。但是室友的建议好似醍醐灌顶。他说，“躲不了就上”，对，就是这么简单，但是自己却一直没有看透。 工作中本来就是有很多安排不可能如意，但是这些逃不掉的东西与其低效率地一遍抱怨一遍完成，还不如转化角度，全身心的投入进去将它来完成。不仅缩短了浪费的时间，更是提高了质量。而且真的是浪费时间么？也不见得。任何事情做了都是会有收获的，可能它的回馈形式并不是物质的。比如写文案提升了一点点创新思维的能力，让脑洞增大了一点点。更新博文虽然刚开始很讨厌，但是确实能整理自己的逻辑思维、提升表达能力。跟着公司跑校招，嗯，好歹有无限的旺仔牛奶可以喝吧。 道理很简单，想通了就好。要么不做，要么做好。 实践学习法这个方法在编程学习中格外有效，可能也是显而易见的方法，然而却总是不能下意识的去使用它。这个方法就是“仿照”。工作中的学习和大学中的学习有很大的不同，前者的目的是为了完成任务，后者的目的是为了夯实基础。所以也导致了方法的不一样。 在做AndroidAPP 的时候，任务很急，所以需求分析完后第一步就是去网上找别人做好的demo，这时候github的威力就体现出来了。基本上知道类似功能的英文后就能找到想要的demo。下一步就是参考demo去把相应的功能抄过来。抄的时候当然会涉及到很多看不懂的地方，于是碰到什么问题就去查对应知识点。这样一点点来学习。比如刚开始的时候，我觉得还没有 Java 基础，于是从头开始学Java，一个星期就这样过去了，才学完多态。于是转换策略直接上手，一个多月过去了，感觉Java基础其实也已经学习的差不多了。 坚持的力量最初也是为了完成之前《写在2015的尾巴与2016的开头》里面许下的关于锻炼新年愿望，下了个 Keep 软件就开始锻炼。和做所有事情一样，前几天真的是很有激情，然而过了几天就开始犯懒了。而且刚开始做了几天浑身都是酸痛的，天气也愈加寒冷，只想躲在被子里冬眠。多亏了 Keep 有个点赞的功能，每天晚上到家看到昨天的锻炼被几个人点了赞就很有成就感。竟然也是坚持下来了。其中28号的时候懒惰战胜了一切，一回家洗了澡就躲在床上玩 ipad 了，断了一天，现在想起来实在很后悔。 回头想想变化确实是有的。最开始双手各两公斤哑铃都吃不消，做几组手臂便酸的发抖。仰卧起坐十来个便也是极限。连最初级的训练难度，做十分钟都吃不大消。但是二十号左右的时候，两公斤哑铃竟然已经没有太多感觉了，两边各加到了三公斤，仰卧起坐一次五十个也腹部也不会太酸。欣喜之情当然是有的。但是之前许下的目标还是很远。每次看到那些坚持连续锻炼1000天的人就觉得很可怕。究竟是什么样的力量让他们三年如一日的锻炼。 最近感受到最可怕的一点就是时间过的太快了，不知不觉已经毕业七个月了，但是现在回头看一眼和毕业时候知识储备的差距似乎并没有预期的大。不过可能还是自己太急功近利了一点，技术积累应该还是慢慢的有所增加的，只是没有一个东西能够明显的这些储备体现出来，我如安慰自己。 不过不管怎样，所能做的也唯有继续坚持，相信坚持的力量，期待厚积薄发。 加油，2016！","categories":[],"tags":[{"name":"InnerPath","slug":"InnerPath","permalink":"http://iyounix.com/tags/InnerPath/"}]},{"title":"书评《黑客与画家》","slug":"Life/InnerPath/16-01-15书评《黑客与画家》","date":"2016-01-15T14:00:00.000Z","updated":"2018-11-08T01:30:40.291Z","comments":true,"path":"2016/01/15/Life/InnerPath/16-01-15书评《黑客与画家》/","link":"","permalink":"http://iyounix.com/2016/01/15/Life/InnerPath/16-01-15书评《黑客与画家》/","excerpt":"","text":"最初是在买其他的书的时候看到了这本书的名字，着实被吸引了一把，但是也只是去大致瞥了一眼，没有细看。第二次是 Buddy 师兄无意中提到了这本书，于是产生了些许兴趣，便买了回来，但第一章都未看完便随它躺在桌上静静的吃灰了。第三次是和基友聊天，聊到了阮一峰这个人，这个经济学博士在前端方面被大家所称赞，于是好奇去搜了下他的博客，不禁十分佩服，又突然发现这本书的译者正是阮一峰，于是爱屋及乌，这才开始沉下心来看这本书。 梗概全书大概讲了三个方面的内容。第一部分讲的是黑客们是如何成长的，他们看待世界的观点是怎样的。第二部分解释了黑客们怎样做出成果，这些成果是如何对世界造成影响的。第三部分解释了黑客的工具（编程语言）和工作方法，了解这些可以更好的了解黑客文化。 随想第一部分很多观点都不赞同。因为作者 Paul Graham 年轻的时候就开始编程，在哈佛大学计算机系，真的是世界上第一批程序员，但是读博士读到一半的时候又对艺术产生兴趣，拿到博士学位后去学习绘画，希望成为画家。所以他不算是一名黑客，但是我感觉他所说的黑客全部是以自己为蓝本描述的。而可能因为他自己小时候有些“nerd”和内向的性格，所以以偏概全的认为大部分黑客都是书呆子并且不善言语。但是有一句话很有意思，“黑客与画家最像”，当时自己对这两者之间的关系的看法和作者的稍有不同。曾经陶红兵跟我们讲过，历史上最伟大的艺术家无一例外都是疯子，我觉得一个超级黑客和一个伟大的艺术家内心都有一种疯狂。Paul 应该是由自身的体会说他们的共同之处在于创造，他们都是在努力着试图去创造出优秀的作品。同时他们都有一种无奈，那就是他们的想法可能是社会无法欣赏甚至容忍的。他在刚开始进行艺术工作的时候常常入不敷出，收入低且不稳定，经常以给别人编程来补贴家用。他提出一种做法就是“Day Job”，首先以一分白天工作养家糊口，其次发展自己的爱好。读到这里的时候我真切的感受到了Paul 本人的影子，觉得这个确实非常的现实。其实不止是黑客，谁又不是这样呢。像自己不知不觉毕业已经有半年，现在回头看自己最初的想法真的是很天真。当时自己有些很单纯的想法比如希望能够成为嵌入式方面的大牛，但是工作后才发现，嵌入式行业太广泛，成为全才绝对不可能，就算是现在选择的手机这一块，要对从上到下每个模块都深入了解也需要不少光景。而且最简单的希望安安心心从Android的Linux底层驱动又发现很多事情不可能如你所愿的顺利。总会有各种杂事使你分心。领导的命令不能不服从，这个时候你是服务者，公司是你的顾客，他们是上帝。如果恰若你的公司给你安排的工作正好是你乐于发展的方向，那简直就是天大的好事了。 第二部分这一部分讲的是黑客们或者说是软件工程师们为社会创造的巨大财富，互联网软件。在看这一部分的时候我简直被 Paul 的远见所折服，“我们生活中的一切，都将成为计算机”，所以他和朋友一起做出了一款搭建网店的软件。在公司做大后他将创立的公司 Viaweb 卖给了 Yahoo，工作半年后因为不适应大公司的工作环境离职了。并开始教哈佛学生如何成立创业公司。从那个时候开始他慢慢开始将扶持别人创业当作自己的事业，他成为了一名天使投资人。同时他提出的一套创业公式也很有意思：1.搭建原型2.上线运营3.收集反馈4.调整产品5.成长壮大他主张用户就是王道，快速的上线运营能够了解到用户真正需要什么。从而进行产品的完善和公司定位的调整。和前段时候写的那篇博客里面 90 后的创业人孙宇晨的观点几乎一模一样“快速迭代、勇于试错、调整产品、螺旋上升”。真的现在创业越来越简单了，你只需要一个好的点子，唯一的门槛就是勇气。 第三部分这一部分最有意思的是 Paul 对100年后编程语言的预测。他认为语言是在如生物一样进化着的，不停地在传承着，有的会死掉，有的会融合。他预言 JAVA 会死掉，所谓的死掉并不是指靠这个语言找到工作的大学生数量会下降，而是指这个语言已经走到了进化的末端。他认为一门语言内核越干净、越小生命力越顽强。恰好前端时间接收到一个观点，王东岳《物演通论》里面 “递弱代偿”的观点类似。总的来说就是愈原始愈简单的物类其存在度愈高，愈后衍愈复杂的物类其存在度愈低，并且存在度呈一个递减趋势。就比如化学元素，最先出现的氢元素占宇宙百分比70%，其实是氦，越后面的存在度越低。生物也是一样，最先出现的细菌在现在还活着，但是恐龙却已经灭绝了。人在整个地球发展史中的所占有的时间长度绝对更低，因为越往后繁衍越复杂，所依赖的东西越多。因为你的复杂性，任何一个变量都可能导致这个物种的灭亡。突然发现 Paul 所说的观点和递弱代偿理论如此的相近。为了解决一类问题，发明了一种语言，虽然能够提升编程者的效率，但是越发展也越有它的局限性。它的局限性体现在越发展却越针对于一种应用场景。 总结总的来说，这本书本身的内容并没有给我太多的颠覆的感觉，换一句话说就是里面呈现的新的思维太少，更多的都是作者在当时著书时的预测和判断。现在看来虽然有些预言无比正确，但是这也只能提高我对 Paul 的敬佩。关键在于如何去拥有他这种预测的能力。我暂时只看到了两点。首先，毋庸置疑是技术的积累。Paul首先是哈佛大学计算机系的博士生，所以已经具备了扎实的能力，这种能力在他初创公司开始做产品的时候毫无疑问是非常重要的。其次是实践的重要性。最后他能成为一个预见性非常厉害的天使投资人就是因为他创过业，对创业的每个环节都十分清楚，因此他才能够权衡一个项目开始实施的时候可能遇到的问题。最后，开始进行创业项目的指导和投资后这方面的经验如雪球一般越滚越多。硅谷创业之父的头衔也当仁不让了。 分析的这两点都算是显而易见的，其实他的成功一定还和更多更深次的原因有关。不过有的观点是接触到了之后才能够联想到的，因为能力有限暂时也未挖掘出来。况且做好这两点也非一朝一夕，暂时以第一点为目标踏踏实实积累好硬实力。走得越远，视野可能也越广阔吧。","categories":[],"tags":[{"name":"Food4Thought","slug":"Food4Thought","permalink":"http://iyounix.com/tags/Food4Thought/"}]},{"title":"写在2015的尾巴与2016的开头","slug":"Life/InnerPath/16-01-03写在2015的尾巴与2016的开头","date":"2016-01-03T14:00:00.000Z","updated":"2018-11-08T01:30:40.291Z","comments":true,"path":"2016/01/03/Life/InnerPath/16-01-03写在2015的尾巴与2016的开头/","link":"","permalink":"http://iyounix.com/2016/01/03/Life/InnerPath/16-01-03写在2015的尾巴与2016的开头/","excerpt":"","text":"元旦假日。第一天，小扫除好好整理了下长草了的房间，和同事打了一场酣畅淋漓的羽毛球，陪同学看了许诺已久的电影；第二天，去年嚷了半年的愿望终于实现了，在床上整整躺一天，把2015年一年没睡够的觉算是全补上了；第三天，来到公司，做下一个Q的学习计划，突然发现有些时日没有更新博客，便借此时做下2015年的归纳总结和2016年的展望吧。 2015年，上半年好像忙忙碌碌，下半年也好像忙忙碌碌，也不知道忙碌着什么，然后，一年就这样过去了。上半年一开始好好准备毕业论文和答辩，拿到offer后，西藏行了一遭，也不知道什么时候建了这个website，其他有印象的事儿似乎也掰不出几个。七月入职，一晃半年，Linux驱动功夫稍稍见长，对内核驱动框架了解深了一点，也开始接触JAVA和Android，但是也更迷茫，不知道走上层还是下层。2016年，按照QPI计划要开始学习NFC，期间也穿插着Android APP的编写。还是感觉有些不踏实，底层基础还没有打牢，JAVA也还没啃完就要去啃Android，应该要把重点更明确一下才好。 那么就稍稍做下2016年的规划吧。 以NFC为切入点，将内核的基本功打扎实，量化的标准是核心驱动理论全部信手拈来 了解链接装载与库的整个流程，量化的标准是俞甲子那本书前面的所有问题都能说的出所以然 看十二本小说，一个月一本，十二篇读后感 坚持锻炼，身体确实是本钱，量化的标准就是 10 KG 的哑铃可以轻松做50个 博客实现两周一更 TOEIC 分数达到555分 掌握JAVA基础 似乎不多，但每个任务都是需要坚持才能达到的。踏实一点，戒骄戒躁，厚积薄发，2016 加油。","categories":[],"tags":[{"name":"InnerPath","slug":"InnerPath","permalink":"http://iyounix.com/tags/InnerPath/"}]},{"title":"UnixC 内存 mem 操作","slug":"Language/[UnixC] 内存 mem 操作","date":"2015-12-31T17:01:01.000Z","updated":"2018-11-08T02:03:47.213Z","comments":true,"path":"2016/01/01/Language/[UnixC] 内存 mem 操作/","link":"","permalink":"http://iyounix.com/2016/01/01/Language/[UnixC] 内存 mem 操作/","excerpt":"","text":"[TOC] 概述头文件 string.h memcpy、memmove 拷贝一定长度mem内容 memset buffer填充工作 memchr 字符查找 memcmp 比较mem中buffer大小 详述memcpy 拷贝内存，不可重叠定义：1void *memcpy(void *dst,const void *src,size_t n) 作用：拷贝 src 所指向的内存内容的前 n 个字节到 dst 所指向的内存地址上。返回指向 dst 的指针。另外 src 和 dst 指向的 内存区域 不可重叠。区别于 strcpy 的不同是：memcpy 完成 n 个字节的复制。strcpy 遇到 \\0 字符才结束。123456789101112131415#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; int a[10] = &#123;0&#125;; for (int i = 0; i &lt; 10; i++) a[i] = i; memcpy(&amp;a[4],a,sizeof(int)*6); //memmove(&amp;a[4], a, sizeof(int) * 6); for (int i = 0; i &lt; 10; i++) cout &lt;&lt; a[i]; getchar(); return 0;&#125; 输出 0123012301 memmove 拷贝内存，可重叠定义：1void* memmove(void* dst,const void* src,size_t n) 作用：与memcpy()一样都是用来拷贝src所指的内存前n个字节到dst所指的内存上。不同的是，当src和dest所指的内存区域重叠时，memmove仍然可以正确的处理，不过执行效率上会比memcpy略慢。src 与 dst 的区域可以重叠。从高地址拷到低地址，和从低地址拷到高地址 是不同的。 memset 批处理定义：1void* memset(void *s,int ch,size_t n) 作用：将 s 中前 n 个字节用 ch 替换并返回 s 。 memchr 查找内存中的某个字符定义：1extern void* memchr(const void* buf,int ch,size_t count) 作用：从 buf 所指内存区的前 count 个字节查找字符 ch，当第一次遇到字符 ch 时停止查找。如果成功，返回指向字符 ch 的指针；否则返回 null。 memcmp 内存中字节比较定义：1int memcmp(const void* buf1,const void* buf2,unsigned int count) 作用：比较buf1和buf2的前count个字节返回值：当buf1 &lt; buf2 时，返回值 &lt; 0 当buf1 == buf2时，返回值 = 0 当buf1 &gt; buf2时，返回值 &gt; 0 实现memcpy12345678910111213141516/** * memcpy - Copy one area of memory to another * @dest: Where to copy to * @src: Where to copy from * @count: The size of the area. * * You should not use this function to access IO space, use memcpy_toio() * or memcpy_fromio() instead. */void * memcpy(void * dest,const void *src,size_t count)&#123; char *tmp = (char *) dest, *s = (char *) src; while (count--) *tmp++ = *s++; return dest;&#125; memmove123456789101112131415161718/* Normally compiler builtins are used, but sometimes the compiler calls out of line code. Based on asm-i386/string.h. */#define _STRING_C#include &lt;linux/string.h&gt;#undef memmovevoid *memmove(void * dest,const void *src,size_t count)&#123; if (dest &lt; src) &#123; __inline_memcpy(dest,src,count); &#125; else &#123; char *p = (char *) dest + count; char *s = (char *) src + count; while (count--) *--p = *--s; &#125; return dest;&#125; memset12345678void *(memset) (void *s,int c,size_t n)&#123; const unsigned char uc = c; unsigned char *su; for(su = s;0 &lt; n;++su,--n) *su = uc; return s;&#125; memchr1234567891011121314151617void *memchr (const void *ptr, int value, int num)&#123; if (ptr == NULL) &#123; perror(\"ptr\"); return NULL; &#125; char * p = (char *)ptr; while (num--) &#123; if (*p != (char)value) p++; else return p; &#125; return NULL;&#125; memcmp12345678910111213/* 因为类型可以为任意，所以形参应为void * * 相等则返回0，否则不为0 */ int my_memcmp(const void *s1,const void *s2,size_t count) &#123; int res = 0; const unsigned char *p1 =(const unsigned char *)s1;//注意是unsigned char * const unsigned char *p2 =(const unsigned char *)s2; for(p1 ,p2;count &gt; 0;p1++,p2++,count--) if((res =*p1 - *p2) != 0) //不相当则结束比较 break; return res; &#125;","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://iyounix.com/tags/C/"}]},{"title":"编程修养","slug":"Language/[其他] 编程修养","date":"2015-12-31T17:01:01.000Z","updated":"2018-11-08T02:04:25.671Z","comments":true,"path":"2016/01/01/Language/[其他] 编程修养/","link":"","permalink":"http://iyounix.com/2016/01/01/Language/[其他] 编程修养/","excerpt":"","text":"[TOC] 初学 C 语言的时候看到过 陈皓《编程修养》 中的内容，当时不以为意。 工作一年后无意间再次看到这篇文章，感触颇深。发现其中的每一点言之凿凿。 于是拷贝其目录，试试看自己能否也像前辈一样将每一个修养的细节都用代码语言表现出来。 目录01、版权和版本 02、缩进、空格、换行、空行、对齐 03、程序注释 04、函数的[in][out]参数 05、对系统调用的返回进行判断 06、if 语句对出错的处理 07、头文件中的#ifndef 08、在堆上分配内存 09、变量的初始化 10、h和c文件的使用 11、出错信息的处理 12、常用函数和循环语句中的被计算量 13、函数名和变量名的命名 14、函数的传值和传指针 15、修改别人程序的修养 16、把相同或近乎相同的代码形成函数和宏 17、表达式中的括号 18、函数参数中的const 19、函数的参数个数 20、函数的返回类型，不要省略 21、goto语句的使用 22、宏的使用 23、static的使用 24、函数中的代码尺寸 25、typedef的使用 26、为常量声明宏 27、不要为宏定义加分号 28、||和&amp;&amp;的语句执行顺序 29、尽量用for而不是while做循环 30、请sizeof类型而不是变量 31、不要忽略Warning 32、书写Debug版和Release版的程序 版权&amp;版本在写代码的时候添加文件头，可以利用 vimrc 自动实现这个功能：Vim设置（非常全） 。在每次生成新文件的时候都会自动生成形如下面样式的文件头。123456/************************************************************************* &gt; File Name: test.c &gt; Author: Younix &gt; Mail: foreveryounix@gmail.com &gt; Created Time: 2016年10月14日 星期五 15时28分28秒 ************************************************************************/ 缩进、空格、换行、空行、对齐同样利用 Vimrc 来实现，在 .vimrc 中添加123456789101112131415&quot; 自动缩进set autoindentset cindent&quot; Tab键的宽度set tabstop=4&quot; 统一缩进为4set softtabstop=4set shiftwidth=4&quot; 不要用空格代替制表符&quot;set noexpandtab&quot; 将制表符用 4 个空格替代set ts=4set expandtab&quot; 在行和段开始处使用制表符set smarttab 更多详细的也可以参考之前那篇文章。 BTW：indent 命令也是一个好方法 注释注释的格式应该如此写：1234567891011/*================================================================ * 函 数 名：XXX * 参 数： * type name [IN] : descripts * 功能描述: * .............. * 返 回 值：成功TRUE，失败FALSE * 抛出异常： * 作 者：Younix 2016/10/14 * ================================================================*/ 函数的[in][out]参数在调用某个函数前先判断一下传进来的指针是否合法！使用断言 assert 对系统调用的返回进行判断 文件返回的文件描述符 socket 返回的 socket 号 malloc 返回的内存这些我使用 dbg.h 中的 check() 宏完成检查。dbg.h 是 Zed.Shaw 编写的一个比较不错的 debug 宏合集。非常好用。1234567891011121314#ifdef NDEBUG#define debug(M, ...)#else#define debug(M, ...) fprintf(stderr, &quot;DEBUG %s:%d: &quot; M &quot;\\n&quot;, __FILE__, __LINE__, ##__VA_ARGS__) //牛逼#endif#define clean_errno() (errno == 0 ? &quot;None&quot; : strerror(errno))#define log_err(M, ...) fprintf(stderr, &quot;[ERROR] (%s:%d: errno: %s) &quot; M &quot;\\n&quot;, __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)#define log_warn(M, ...) fprintf(stderr, &quot;[WARN] (%s:%d: errno: %s) &quot; M &quot;\\n&quot;, __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)#define log_info(M, ...) fprintf(stderr, &quot;[INFO] (%s:%d) &quot; M &quot;\\n&quot;, __FILE__, __LINE__, ##__VA_ARGS__)#define check(A, M, ...) if(!(A)) &#123; log_err(M, ##__VA_ARGS__); errno=0; goto error; &#125;#define sentinel(M, ...) &#123; log_err(M, ##__VA_ARGS__); errno=0; goto error; &#125;#define check_mem(A) check((A), &quot;Out of memory.&quot;)#define check_debug(A, M, ...) if(!(A)) &#123; debug(M, ##__VA_ARGS__); errno=0; goto error; &#125; 下载地址：http://download.csdn.net/detail/dearsq/9653980 if 语句的错误处理先写错误处理，再写正常逻辑 头文件中的 #ifndef这个毋庸置疑非常重要，为了防止交叉引用 在堆上分配内存栈上分配内存方法：123456char*AllocStrFromStack()&#123; char pstr[100]; return pstr;&#125; 堆上分配内存方法：12345678char* AllocStrFromHeap(int len) &#123; char *pstr; if ( len &lt;= 0 ) return NULL; return ( char* ) malloc( len ); &#125; 栈上分配的内存在函数结束时被释放，此时返回有可能出现段错误。堆上分配的内存在free时才被释放，在函数返回时仍然存在。 malloc 分配的内存一定要初始化;free 后的指针一定要设置为 NULL。内存检查工具 Purify 变量初始化 malloc 后记得 memset 清零 对栈上分配的 struct 或数组进行初始化 对全局和静态变量，声明时就要初始化 h和c文件的使用声明和实现严格分开，采用 Makefile 来管理。 另外，在 .h 中不要初始化。 出错信息的处理我采用的是 dbg.h 中提供的方式。 常用函数和循环语句中的被计算量12345678GetLocalHostName(char* name)&#123; char funcName[] = &quot;GetLocalHostName&quot;; sys_log( &quot;%s begin......&quot;, funcName ); ... sys_log( &quot;%s end......&quot;, funcName );&#125; 如果这个函数经常被调用，那么可以把 funcName 声明为 static。 函数名和变量的命名这个不多说，最好望文生义。 函数的传值和传指针其实任何时候都是在传值，看似传指针也只是传的指针的副本。1234567891011121314voidGetVersion(char* pStr)&#123; pStr = malloc(10); strcpy ( pStr, &quot;2.0&quot; );&#125;main()&#123; char* ver = NULL; GetVersion ( ver ); ... ... free ( ver );&#125; 其实这里函数的形参 pStr 只是 ver 的副本。因为是副本，pStr 所指向的地方和 ver 所指向的地方相同，但是如果对其取地址的话，可以看到 &amp;pStr 和 &amp;ver 是不同的。因为这里也只是 值 传递。 修改他人程序删除时请使用注释 把相同或近乎相同的代码形成函数和宏如题 表达式中的括号为了避免误解，多加括号没有错的。 函数参数中的 const在函数中只读的参数请使用 const。虽然指针即使用 const 修饰后依然能改，但是编译器会报 Warning，可以引起注意。 函数的参数个数参数太多请用结构体传参。 返回类型不要省略 goto 语句除了错误处理，其他情况不要用 goto。 宏定义宏可以加快运行速度（减少函数调用的开销），但是会增加执行文件体积。而且注意将变量（）起来。 不要给宏定义加分号static最初了解 static 是因为全局变量。但是他最大的作用是在于控制访问。C 中如果一个函数或者一个全局变量 被声明为 static，那么它们将只能在这个 C 中被访问！ 函数代码尺寸保证函数功能的单一性。 typedeftypedef char bool; 为常量声明宏char name[NAME_SIZE] || &amp;&amp; 语句执行顺序注意 &amp;&amp; 时，并不一定所有判断都会执行。 尽量用for而不是while做循环请sizeof 类型而不是变量不要忽略Warning 声明了未使用的变量。（虽然编译器不会编译这种变量，但还是把它从源程序中注释或是删除吧） 使用了隐晦声明的函数。（也许这个函数在别的C文件中，编译时会出现这种警告，你应该这使用之前使用extern关键字声明这个函数） 没有转换一个指针。（例如malloc返回的指针是void的，你没有把之转成你实际类型而报警，还是手动的在之前明显的转换一下吧） 类型向下转换。（例如：float f = 2.0; 这种语句是会报警告的，编译会告诉你正试图把一个double转成float，你正在阉割一个变量，你真的要这样做吗？还是在2.0后面加个f吧，不然，2.0就是一个double，而不是float了） 书写Debug版和Release版的程序参考 dbg.h 添加调试函数。","categories":[],"tags":[{"name":"InnerPath","slug":"InnerPath","permalink":"http://iyounix.com/tags/InnerPath/"}]},{"title":"Git 如何修改之前的某次commit","slug":"Language/[Git] 如何修改之前的某次commit","date":"2015-12-31T17:01:01.000Z","updated":"2018-11-08T02:03:27.355Z","comments":true,"path":"2016/01/01/Language/[Git] 如何修改之前的某次commit/","link":"","permalink":"http://iyounix.com/2016/01/01/Language/[Git] 如何修改之前的某次commit/","excerpt":"","text":"Git version: 2.7.4OS: Ubuntu 16.04 [TOC] 需求背景将 A 功能从 branchA 合入到主分支 master 后过了很多个提交后，发现 A 功能某个地方有 bug，那最好的方法就是跳回到写 A 功能的时候进行修改。 这分为两个部分 修改之前某次的 commit 信息 修改之前某次的 commit 内容 实现方法比如我现在的 git log 如下：1234fd65115db FUNCTION Mipi Camera Camera IC: OV13850 Interface: RX197a8ad0f7f FUNCTION 移植 8寸 Mipi LCD Driver IC: RM720149633cf0919 FUNCTION 移植 8寸 TP Driver IC:GT911 我现在发现当时移植 TP 的时候有 bug，我需要回到 9633cf0919 对进行 TP 进行移植的时候来修复这个 Bug。 我只需要这样做： 1、将当前分支无关的工作状态进行暂存1git stash 2、将 HEAD 移动到需要修改的 commit 上1git rebase 9633cf0919^ --interactive 3、找到需要修改的 commit ，将首行的 pick 改成 edit4、开始着手解决你的 bug5、 git add 将改动文件添加到暂存6、 git commit –amend 追加改动到提交7、git rebase –continue 移动 HEAD 回最新的 commit8、恢复之前的工作状态1git stash pop","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://iyounix.com/tags/git/"}]},{"title":"C 第一章 GCC 编译的背后","slug":"Language/[C] 第一章 GCC 编译的背后","date":"2015-12-31T17:01:01.000Z","updated":"2018-11-08T02:04:54.906Z","comments":true,"path":"2016/01/01/Language/[C] 第一章 GCC 编译的背后/","link":"","permalink":"http://iyounix.com/2016/01/01/Language/[C] 第一章 GCC 编译的背后/","excerpt":"","text":"[TOC] 预处理、编译、汇编、链接-E，-S，-c 和 -Ocpp，cc1，as，ld 预处理完成任务：预处理命令处理、头文件的包含、宏定义的拓展、条件编译的选择-E1gcc -E hello.c 在命令行定义宏：1gcc -DDEBUG hello.c 等于1#define DEBUG 编译（翻译）完成任务：词法分析、语法分析、源码翻译为汇编代码-S1$ gcc -S hello.c 编译器优化123$ gcc -o hello hello.c # 采用默认选项，不优化$ gcc -O2 -o hello2 hello.c # 优化等次是2$ gcc -Os -o hellos hello.c # 优化目标代码的大小 大小： hellos &lt; hello2 &lt; hello执行速度：hellos &gt; hello2 &gt; hello 汇编完成任务：汇编代码翻译成机器代码（目标代码）-c1234567891011gcc -c hello.s #会生成hello.o$ file hello.shello.s: ASCII assembler program text$ gcc -c hello.s #用gcc把汇编语言编译成目标代码$ file hello.o #file命令用来查看文件类型，目标代码可重定位的(relocatable)， #需要通过ld进行进一步链接成可执行程序(executable)和共享库(shared)hello.o: ELF 32-bit LSB relocatable, Intel 80386, version 1 (SYSV), not stripped$ as -o hello.o hello.s #用as把汇编语言编译成目标代码$ file hello.ohello.o: ELF 32-bit LSB relocatable, Intel 80386, version 1 (SYSV), not stripped gcc 和 as 默认产生的目标代码都是 ELF 格式 ELF文件了解目标代码，区分三种类型 relocatable（可重定位）、executable（可执行）、shared libarary（共享库）的不同。我们需要工具，bjdump，objcopy，nm，strip 或者 readelf。1234567ELF Header(ELF文件头)Program Headers Table(程序头表，实际上叫段表好一些，用于描述可执行文件和可共享库)Section 1Section 2Section 3...Section Headers Table(节区头部表，用于链接可重定位文件成可执行文件或共享库) 对于可重定位文件，程序头是可选的，而对于可执行文件和共享库文件（动态链接库），节区表则是可选的。可以分别通过 readelf 文件的 -h，-l 和 -S 参数查看 ELF 文件头（ELF Header）、程序头部表（Program Headers Table，段表）和节区表（Section Headers Table） ELF文件头文件头说明了文件的类型，大小，运行平台，节区数目等。写一个小工程，三个文件来测试123456789101112131415161718192021/* myprintf.c */#include &lt;stdio.h&gt;void myprintf(void)&#123; printf(&quot;hello, world!\\n&quot;);&#125;/* test.h -- myprintf function declaration */#ifndef _TEST_H_#define _TEST_H_void myprintf(void);#endif/* test.c */#include &quot;test.h&quot;int main()&#123; myprintf(); return 0;&#125; test.o 类型是 REL（可重定位文件） myprintf.o 类型是 REL（可重定位文件） test 类型是 EXEC（可执行文件） ar 创建静态链接库 ar rcsv libmyprintf.a myprintf.o libmyprintf.a 类型也是 REL（可重定位文件）.a 静态库可以是多个 REL 文件的集合 创建动态链接库 gcc myprintf.c -fPIC -shared -o libmyprintf.so libmyprintf.so 类型是 DYN（共享目标文件） ELF主体：节区（Section） ELF 文件中 文件头 组织整个文件总体结构 节区表 描述可重定位文件 程序头（段表）描述可执行文件 可重定位文件中 ，节区表描述的是其节区本身; 可执行文件中，程序头描述的是由各个节区组成的段。 12345678910111213141516171819202122$ gcc -c myprintf.c$ readelf -S myprintf.o //节区表There are 11 section headers, starting at offset 0xc0:Section Headers: [Nr] Name Type Addr Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .text PROGBITS 00000000 000034 000018 00 AX 0 0 4 [ 2] .rel.text REL 00000000 000334 000010 08 9 1 4 [ 3] .data PROGBITS 00000000 00004c 000000 00 WA 0 0 4 [ 4] .bss NOBITS 00000000 00004c 000000 00 WA 0 0 4 [ 5] .rodata PROGBITS 00000000 00004c 00000e 00 A 0 0 1 [ 6] .comment PROGBITS 00000000 00005a 000012 00 0 0 1 [ 7] .note.GNU-stack PROGBITS 00000000 00006c 000000 00 0 0 1 [ 8] .shstrtab STRTAB 00000000 00006c 000051 00 0 0 1 [ 9] .symtab SYMTAB 00000000 000278 0000a0 10 10 8 4 [10] .strtab STRTAB 00000000 000318 00001a 00 0 0 1Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings) I (info), L (link order), G (group), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific) objdump -d 看反编译结果，-j 看指定节区123456789101112131415$ objdump -d -j .text myprintf.omyprintf.o: file format elf32-i386Disassembly of section .text:00000000 &lt;myprintf&gt;: 0: 55 push %ebp 1: 89 e5 mov %esp,%ebp 3: 83 ec 08 sub $0x8,%esp 6: 83 ec 0c sub $0xc,%esp 9: 68 00 00 00 00 push $0x0 e: e8 fc ff ff ff call f &lt;myprintf+0xf&gt; 13: 83 c4 10 add $0x10,%esp 16: c9 leave 17: c3 ret 用 -r 选项可以看到有关重定位的信息1234567$ readelf -r myprintf.oRelocation section &apos;.rel.text&apos; at offset 0x334 contains 2 entries: Offset Info Type Sym.Value Sym. Name0000000a 00000501 R_386_32 00000000 .rodata0000000f 00000902 R_386_PC32 00000000 puts# R_386_32 和 R_386_PC32 是重定位类型，根据类型来进行重新定位 .rodata 节区包含只读数据，即我们要打印的 hello,world! 1234$ readelf -x .rodata myprintf.oHex dump of section &apos;.rodata&apos;: 0x00000000 68656c6c 6f2c2077 6f726c64 2100 hello, world!. .data 节区无内容, 它应该包含一些初始化的数据123$ readelf -x .data myprintf.oSection &apos;.data&apos; has no data to dump. .bss节区无内容，它应该包含未初始化的数据，默认初始为 0123$ readelf -x .bss myprintf.oSection &apos;.bss&apos; has no data to dump. .comment 是一些注释，可以看到是是 Gcc 的版本信息 12345$ readelf -x .comment myprintf.oHex dump of section &apos;.comment&apos;: 0x00000000 00474343 3a202847 4e552920 342e312e .GCC: (GNU) 4.1. 0x00000010 3200 .note.GNU-stack 这个节区也没有内容123$ readelf -x .note.GNU-stack myprintf.oSection &apos;.note.GNU-stack&apos; has no data to dump. .shstrtab 包括所有节区的名字123456789$ readelf -x .shstrtab myprintf.oHex dump of section &apos;.shstrtab&apos;: 0x00000000 002e7379 6d746162 002e7374 72746162 ..symtab..strtab 0x00000010 002e7368 73747274 6162002e 72656c2e ..shstrtab..rel. 0x00000020 74657874 002e6461 7461002e 62737300 text..data..bss. 0x00000030 2e726f64 61746100 2e636f6d 6d656e74 .rodata..comment 0x00000040 002e6e6f 74652e47 4e552d73 7461636b ..note.GNU-stack 0x00000050 00 .symtab 包括所有用到的相关符号信息1234567891011121314$ readelf -symtab myprintf.oSymbol table &apos;.symtab&apos; contains 10 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND 1: 00000000 0 FILE LOCAL DEFAULT ABS myprintf.c 2: 00000000 0 SECTION LOCAL DEFAULT 1 3: 00000000 0 SECTION LOCAL DEFAULT 3 4: 00000000 0 SECTION LOCAL DEFAULT 4 5: 00000000 0 SECTION LOCAL DEFAULT 5 6: 00000000 0 SECTION LOCAL DEFAULT 7 7: 00000000 0 SECTION LOCAL DEFAULT 6 8: 00000000 24 FUNC GLOBAL DEFAULT 1 myprintf 9: 00000000 0 NOTYPE GLOBAL DEFAULT UND puts 字符串表 .strtab 包含用到的字符串，包括文件名、函数名、变量名等12345$ readelf -x .strtab myprintf.oHex dump of section &apos;.strtab&apos;: 0x00000000 006d7970 72696e74 662e6300 6d797072 .myprintf.c.mypr 0x00000010 696e7466 00707574 7300 intf.puts. 汇编语言文件中的节区表述12345678910111213141516171819202122$ gcc -S myprintf.c$ cat myprintf.s .file &quot;myprintf.c&quot; .section .rodata.LC0: .string &quot;hello, world!&quot; .text.globl myprintf .type myprintf, @functionmyprintf: pushl %ebp movl %esp, %ebp subl $8, %esp subl $12, %esp pushl $.LC0 call puts addl $16, %esp leave ret .size myprintf, .-myprintf .ident &quot;GCC: (GNU) 4.1.2&quot; .section .note.GNU-stack,&quot;&quot;,@progbits 链接https://tinylab.gitbooks.io/cbook/content/zh/chapters/02-chapter2.html","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://iyounix.com/tags/C/"}]},{"title":"C 函数调用的时候栈发生了什么","slug":"Language/[C] 函数调用的时候栈发生了什么","date":"2015-12-31T17:01:01.000Z","updated":"2018-11-08T02:02:57.721Z","comments":true,"path":"2016/01/01/Language/[C] 函数调用的时候栈发生了什么/","link":"","permalink":"http://iyounix.com/2016/01/01/Language/[C] 函数调用的时候栈发生了什么/","excerpt":"","text":"[TOC] 本文分析的问题是函数的栈调用机理。先说结论 结论 通过栈传递参数 从右向左 参数压栈 先压参数入栈 然后返回地址入栈 ebp 等寄存器入栈 调用过程中的栈是由调用方来维护 所谓的寄存器入栈 实际上是指的一组寄存器入栈。因为在新调用的函数中，这些寄存器仍然会被用到，为了退出调用函数后能恢复状态，凡是有可能被修改的寄存器都要入栈。出栈顺序和入栈顺序相反。这个过程由编译器维护。 栈在现在普遍应用的单指令流，单数据流计算机上，编译后的程序都是基于栈来调度的。程序装载入内存后，代码指令映射到内存空间的指令区，操作的数据则在对应的栈空间和堆空间上。堆空间用于动态内存的分配、应用。本文分析暂不考虑分析堆的问题。 错误的小例子我们以如下例子为例12345678910111213char* get_memory()&#123; char p[]=\"hello world\"; return p; //错误代码&#125;int main()&#123; char* str = NULL; str = get_memory(); printf(\"%s\",str); //打印出来的是随机字符串 printf(\"%c\",*str); //打印出来的是固定的 h return 0;&#125; 这段代码在 get_memory 中，犯了一个经典的错误。返回了已经释放过的局部变量。我们来仔细分析一下 入栈内存空间可以看成线性的存储空间。而栈处于程序的数据区，对应的是每一个函数的局部变量的存储空间。程序执行到了main函数中第一条指令时，即建立了main函数的栈，标志是cpu的 esp 寄存器和 ebp 寄存器，前者指向main 函数栈的栈顶，后者指向栈底。具体如图1所示，图1是当执行到了char* str=NULL 这段代码后的栈状态。计算机已经为指针 str分配了4个字节的空间，当然现在的内容是NULL，不指向任何内容。 需要注意的一点是，在X86平台上，栈的增长空间是由高位向低位增长的，而堆内存是由低位向高位增长的。当前的栈还只是main函数的栈，局部变量只有一个char指针string，占了4个字节，esp指向栈顶。当上面的程序调用 get_memory 函数时，就进入了新函数的栈空间，期间为了能在新函数运行结束后正确返回main函数，需要保护好调用现场。我们的程序中需要保护的就是就是一个ebp地址和一个main函数中断执行的执行点，亦即返回地址，按照C函数调用管理，先入栈的是返回地址，其后才是ebp指针指向的地址。ebp入栈后的main函数栈如图2所示：此时，只是返回地址和ebp指针入栈，函数尚未进入get_memory()函数。但esp栈顶指针已经指向了新的地址，main函数的栈 空间也随之增大。 真正进入get_memory函数，并且执行了char p[]=”hello world” 语句之后的栈空间如图3所示:此时，已经进入了get_memory函数的栈，所以ebp寄存器指向新函数栈的栈底，这个栈底是在进入新函数之前最后时刻的 esp所指向的地址。所以我们在查看汇编代码时，能看到所有函数的头两个指令都类似于：12pushl %ebpmovl %esp, %ebp 都是先让ebp入栈，即图3中的old ebp，然后再ebp更新为新的esp，此时esp正好指向的是ebp的下一个地址。 新的ebp前一个位置存储的是old ebp，从新的ebp开始就是get_memory的栈空间了。可以看到新函数中的局部变量，数组p 分配到了12个字节存储”hello wolrd”。计算机通过调整esp的位置来分配了空间，这就是在栈上分配内存的原理。就是简单 的调整esp而已。 注意图中的eax寄存器指向了p数组的首地址，这是因为，eax在X86平台上充当着传递返回值的作用。get_momeory函数返回的 是p数组的首地址，自然eax存储的就是p数组首地址了。 出栈函数退出的过程和进入的过程正好相反，也只有这样才能正确恢复中断状态。在本文中的例子就是，首先释放p数组空间，释 放的过程和分配过程一样，只需调整esp寄存器的值就可以了。释放掉局部变量后，esp就指向了old ebp了，然后执行pop ebp指令，就恢复了ebp在main函数中的值，即main函数的栈底地址。之后就可以获取到返回地址，jmp到这个地址，就从 get_memory函数中回到了main函数中。此时的栈状态如图4所示：此时esp已经指向了string变量的下一个地址，esp之后的所有的空间此时都是被释放掉了的，但此时因为还没有被重新 分配，所以他们的值还是原来的值，并没有变化。而string变量是get_memory函数的返回值，它还是指在原来p数组的首 地址位置:0xCFFFFFF0。 小结从上面的分析过程，可以看出函数在调用过程中，所有的局部变量都是在栈上分配的，一旦退出了函数，就被释放。这就 是C函数中局部变量作用域仅在函数内有效的原因。需要明了的是调用过程中的压栈，出栈次序：先进入的是返回地址，然 后是old ebp。 问题分析%S 为什么是乱码首先需要补充一点，在上文中小结中提到，调用一个函数时先入栈的是返回地址，实际上，比返回地址更先入栈的是调用 函数的参数。上面的get_memory函数没有参数，所以直接先入栈了返回地址。在有参数的函数调用时，实际是需要先入栈 参数的。而且，对C/C++函数而言，入栈次序是从右向左的，最右的参数最先入栈。 因为我们的程序下一个调用的是printf函数，这个函数是有参数的，而且在我们的程序中中是两个参数。我们先讨论第一种 调用方法,即printf(“%s”,string)这个调用。进入该函数后的栈空间如图5所示：进入函数时，最右边的参数arg2先入栈，按照C函数的值传递特性，此时传入的是string的副本，即arg2也是一个地址，指 向0xCFFFFFF0。然后arg1入栈，接着是返回地址入栈。因为arg2是4个字节，arg1也是一个字符串常量的地址，也是4个字 节。可以看到，此时的0xCFFFFFF0地址已经被返回地址覆盖掉了，而这个地址正是上次调用时的数组p的起始位置，并且 main中的局部变量string和printf的第二个参数arg2都指向这个地址，但此时该地址中的的值已经不是’h’了，同样的，因 为printf要为其局部变量分配内存，hello world的12个字节全部被覆写。 综上所述，printf在一进入的瞬间，哪怕不执行任何代码，原hello world的空间就被覆盖了，自然也不会得到正确的输 出。得到的全是随机的乱码。实际上也不能简单说是随机的，因为返回地址，printf的局部变量都是确定的，只是把这些 地址，局部变量都当成char输出时，肯定是乱码了，但肯定是确定的乱码。 %c 为什么始终是 h再看第二个问题。同前者不一样的是，这次调用的第二个参数不是一个地址了，而是一个char。按照 值传递的特性，此时的arg2是string的一个拷贝，即arg2=string。而且，这个赋值过程发生在进入函数printf之前。 如图6所示：图6显示了刚刚把printf的第2个参数arg2入栈后的情况，因为string是0xCFFFFFF0，且该位置此时还没有被覆写，所以 *string=’h’，而值传递后，argv2=’h’。这就是arg2压栈后的栈状态。 随后，继续把第一个参数压栈，再把函数返回地址压栈，此时压入了4+1+4=9个字节，esp到达了0xCFFFFFEF位置，如 图7所示:图7显示的是，进入printf函数栈后的栈状态，此时虽然原来的0xCFFFFFF0位置开始的”hello world”被覆盖了，但argv2 值中所存的依然是’h’这个拷贝，所以，第二个程序最终输出的是’h’也就很正常了。","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://iyounix.com/tags/C/"}]},{"title":"Linux 内核的 sysfs 文件系统","slug":"Linux/[Linux] 内核的 sysfs 文件系统","date":"2015-12-30T22:06:06.000Z","updated":"2018-11-08T01:53:25.846Z","comments":true,"path":"2015/12/31/Linux/[Linux] 内核的 sysfs 文件系统/","link":"","permalink":"http://iyounix.com/2015/12/31/Linux/[Linux] 内核的 sysfs 文件系统/","excerpt":"","text":"sysfs 是 Linux 内核中一种新的 虚拟的基于内存的 文件系统。它的作用和 proc 类似，但除了同样具有查看(cat) 和 设定(echo) 内核参数功能之外，也可以用来管理 Linux 统一设备模型。它使用 sysfs 导出内核数据的方式更为统一。 sysfs 挂载点 /sys 目录结构 sysfs 与 Linux 统一设备模型的关系 常见属性文件的用法 以内核编程方面的具体例子展示如何添加 sysfs 支持 sysfs 介绍及其挂载点 /sys 下的目录结构/syssysfs 文件系统会被挂载在 /sys 上。参考 sysfs-rules.txt procsysfs 比 proc 相比有很多优点，最重要的就是设计上很清晰。比如，一个proc 虚拟文件有可能有内部格式，/proc/scsi/scsi 它是可读可写的（但是其权限被标记为 0444,这是 bug），并且读写格式不一样，代表不同的操作。即 应用程序 读到了这个文件的内容还需要进行字符串的解析，在写入时还需要先用字符串格式化按指定的格式写入字符串进行操作。但是，一个 sysfs 设计原则是 一个属性文件 只做一件事情，sysfs 属性文件一般只有一个值，直接读取或者写入。 /sys 下的目录结构1234567root@younixPC:~# ls -F /sysblock/ bus/ class/ dev/ devices/ firmware/ fs/ hypervisor/ kernel/ module/ power/root@younixPC:~# ls -F /sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0/broken_parity_status enable modalias resource0 rom ueventclass irq msi_bus resource0_wc subsystem@ vendorconfig local_cpulist power/ resource1 subsystem_devicedevice local_cpus resource resource2 subsystem_vendor 在 /sys 目录下有 block, bus, class, dev, devices, firmware, fs, kernel, module, power 这些子目录，本文将分别介绍这些目录存在的含义。第二个 ls 命令展示了在一个 pci 设备目录下的文件， “ls” 命令的 “-F” 命令为所列出的每个文件使用后缀来显示文件的类型，后缀 “/“ 表示列出的是目录，后缀 “@” 表示列出的是符号链接文件。可以看到第二个目录下包含有普通文件 (regular file) 和符号链接文件 (symbolic link file) ，后面将介绍这个具体的设备为例说明其中每一个普通文件的用途。 /sys 下的子目录 所包含的内容 /sys/devices 这是内核对系统中所有设备的分层次表达模型，也是 /sys 文件系统管理设备的最重要的目录结构，下文会对它的内部结构作进一步分析； /sys/dev 这个目录下维护一个按字符设备和块设备的主次号码(major:minor)链接到真实的设备(/sys/devices下)的符号链接文件，它是在内核 2.6.26 首次引入； /sys/bus 这是内核设备按总线类型分层放置的目录结构， devices 中的所有设备都是连接于某种总线之下，在这里的每一种具体总线之下可以找到每一个具体设备的符号链接，它也是构成 Linux 统一设备模型的一部分； /sys/class 这是按照设备功能分类的设备模型，如系统所有输入设备都会出现在 /sys/class/input 之下，而不论它们是以何种总线连接到系统。它也是构成 Linux 统一设备模型的一部分； /sys/block 这里是系统中当前所有的块设备所在，按照功能来说放置在 /sys/class 之下会更合适，但只是由于历史遗留因素而一直存在于 /sys/block, 但从 2.6.22 开始就已标记为过时，只有在打开了 CONFIG_SYSFS_DEPRECATED 配置下编译才会有这个目录的存在，并且在 2.6.26 内核中已正式移到 /sys/class/block, 旧的接口 /sys/block 为了向后兼容保留存在，但其中的内容已经变为指向它们在 /sys/devices/ 中真实设备的符号链接文件； /sys/firmware 这里是系统加载固件机制的对用户空间的接口，关于固件有专用于固件加载的一套API，在附录 LDD3 一书中有关于内核支持固件加载机制的更详细的介绍； /sys/fs 这里按照设计是用于描述系统中所有文件系统，包括文件系统本身和按文件系统分类存放的已挂载点，但目前只有 fuse,gfs2 等少数文件系统支持 sysfs 接口，一些传统的虚拟文件系统(VFS)层次控制参数仍然在 sysctl (/proc/sys/fs) 接口中中； /sys/kernel 这里是内核所有可调整参数的位置，目前只有 uevent_helper, kexec_loaded, mm, 和新式的 slab 分配器等几项较新的设计在使用它，其它内核可调整参数仍然位于 sysctl (/proc/sys/kernel) 接口中 ; /sys/module 这里有系统中所有模块的信息，不论这些模块是以内联(inlined)方式编译到内核映像文件(vmlinuz)中还是编译为外部模块(ko文件)，都可能会出现在 /sys/module 中： 编译为外部模块(ko文件)在加载后会出现对应的 /sys/module/ &lt; module_name &gt;/, 并且在这个目录下会出现一些属性文件和属性目录来表示此外部模块的一些信息，如版本号、加载状态、所提供的驱动程序等 编译为内联方式的模块则只在当它有非0属性的模块参数时会出现对应的 /sys/module/ &lt; module_name &gt;, 这些模块的可用参数会出现在 /sys/modules/ &lt; modname &gt;/parameters/ &lt; param_name &gt; 中， 如 /sys/module/printk/parameters/time 这个可读写参数控制着内联模块 printk 在打印内核消息时是否加上时间前缀； 所有内联模块的参数也可以由 “&lt; module_name &gt; . &lt; param_name &gt; = &lt; value &gt;” 的形式写在内核启动参数上，如启动内核时加上参数 “printk.time=1” 与 向 “/sys/module/printk/parameters/time” 写入1的效果相同； 没有非0属性参数的内联模块不会出现于此。 /sys/power 这里是系统中电源选项，这个目录下有几个属性文件可以用于控制整个机器的电源状态，如可以向其中写入控制命令让机器关机、重启等。 /sys/slab (对应 2.6.23 内核，在 2.6.24 以后移至 /sys/kernel/slab) 从2.6.23 开始可以选择 SLAB 内存分配器的实现，并且新的 SLUB（Unqueued Slab Allocator）被设置为缺省值；如果编译了此选项，在 /sys 下就会出现 /sys/slab ，里面有每一个 kmem_cache 结构体的可调整参数。对应于旧的 SLAB 内存分配器下的 /proc/slabinfo 动态调整接口，新式的 /sys/kernel/slab/ &lt; slab_name &gt; 接口中的各项信息和可调整项显得更为清晰。 /sys/devices/12$ ls -F /sys/devices/isa/ LNXSYSTM:00/ pci0000:00/ platform/ pnp0/ pnp1/ system/ virtual/ 可以看到，在 /sys/devices/ 目录下是按照设备的基本总线类型分类的目录，再进去查看 PCI 类型的设备：1234$ ls -F /sys/devices/pci0000:00/0000:00:00.0/ 0000:00:02.5/ 0000:00:03.1/ 0000:00:0e.0/ power/0000:00:01.0/ 0000:00:02.7/ 0000:00:03.2/ firmware_node@ uevent0000:00:02.0/ 0000:00:03.0/ 0000:00:03.3/ pci_bus/ 在 /sys/devices/pci0000:00/ 下是按照 PCI 总线接入的设备号分类存放的目录。再进去查看其中的一个：12345$ ls -F /sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0/ device local_cpus power/ subsystem_vendorbroken_parity_status enable modalias resource ueventclass irq msi_bus subsystem@ vendorconfig local_cpulist pci_bus/ subsystem_device 可以看到，其中有一个目录 0000:01:00.0/ ，其它的都是属性文件和属性组，而如果对 0000:01:00.0/ 子目录中进行再列表查看则会得到之前我们看到过的目录结构。 层次图如下：我们看到涉及了 ksets，kobjects，attrs 等。 统一设备模型对于统一设备模型，我们可以看这一篇博文： 涉及到文件系统实现来说， sysfs 是一种基于 ramfs 实现的内存文件系统，与其它同样以 ramfs 实现的内存文件系统(configfs,debugfs,tmpfs,…)类似， sysfs 也是直接以 VFS 中的 struct inode 和 struct dentry 等 VFS 层次的结构体直接实现文件系统中的各种对象；同时在每个文件系统的私有数据 (如 dentry-&gt;d_fsdata 等位置) 上，使用了称为 struct sysfs_dirent 的结构用于表示 /sys 中的每一个目录项。12345678910111213141516171819struct sysfs_dirent &#123; atomic_t s_count; atomic_t s_active; struct sysfs_dirent *s_parent; struct sysfs_dirent *s_sibling; const char *s_name; union &#123; struct sysfs_elem_dir s_dir; struct sysfs_elem_symlink s_symlink; struct sysfs_elem_attr s_attr; struct sysfs_elem_bin_attr s_bin_attr; &#125;; unsigned int s_flags; ino_t s_ino; umode_t s_mode; struct iattr *s_iattr;&#125;; 在上面的 kobject 对象中可以看到有向 sysfs_dirent 的指针，因此在sysfs中是用同一种 struct sysfs_dirent 来统一设备模型中的 kset/kobject/attr/attr_group. 具体在数据结构成员上， sysfs_dirent 上有一个 union 共用体包含四种不同的结构，分别是目录、符号链接文件、属性文件、二进制属性文件；其中目录类型可以对应 kobject，在相应的 s_dir 中也有对 kobject 的指针，因此在内核数据结构， kobject 与 sysfs_dirent 是互相引用的；有了这些概念，再来回头看 之前 sysfs 目录层次图 所表达的 /sys 目录结构就是非常清晰明了: 在 /sys 根目录之下的都是 kset，它们组织了 /sys 的顶层目录视图； 在部分 kset 下有二级或更深层次的 kset； 每个 kset 目录下再包含着一个或多个 kobject，这表示一个集合所包含的 kobject 结构体； 在 kobject 下有属性(attrs)文件和属性组(attr_group)，属性组就是组织属性的一个目录，它们一起向用户层提供了表示和操作这个 kobject 的属性特征的接口； 在 kobject 下还有一些符号链接文件，指向其它的 kobject，这些符号链接文件用于组织上面所说的 device, driver, bus_type, class, module 之间的关系； 不同类型如设备类型的、设备驱动类型的 kobject 都有不同的属性，不同驱动程序支持的 sysfs 接口也有不同的属性文件；而相同类型的设备上有很多相同的属性文件；注意，此表内容是按照最新开发中的 2.6.28 内核的更新组织的，在附录资源如 LDD3 等位置中有提到 sysfs 中曾有一种管理对象称为 subsys (子系统对象)，在最新的内核中经过重构认为它是不需要的，它的功能完全可以由 kset 代替，也就是说 sysfs 中只需要一种管理结构是 kset，一种代表具体对象的结构是 kobject，在 kobject 下再用属性文件表示这个对象所具有的属性； 常见 sysfs 属性的功能使用设备(PCI)的 sysfs 属性文件以桌面系统上的视频卡为例，列举它对应的 kobject 上的属性文件的对应用途;一般来说，在 Linux 桌面上都有视频卡以支持 Xorg 软件包作为 XWindow 服务器来运行，因此 先找到 Xorg 的进程号，查看这个进程所使用的所有文件（注意查看这个进程属性需要 root 用户权限）；1234567891011121314151617# ps xfa |grep Xorg 2001 tty1 Ss+ 2:24 \\_ /usr/bin/Xorg :0 -nr -verbose -auth \\/var/run/gdm/auth-for-gdm-NPrkZK/database -nolisten tcp vt1# lsof -nP -p 2001Xorg 2001 root mem REG 8,3 617732 231033 \\/usr/lib/xorg/modules/drivers/sis_drv.so[...]Xorg 2001 root mem REG 0,0 134217728 5529 \\/sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0/resource0Xorg 2001 root mem REG 0,0 131072 5531 \\/sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0/resource1[...]Xorg 2001 root 7u REG 0,0 256 5504 \\/sys/devices/pci0000:00/0000:00:00.0/configXorg 2001 root 8u unix 0xdbe66000 0t0 8756 socketXorg 2001 root 9u REG 0,0 256 5528 \\/sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0/config 此 Xorg 服务器是以内存映射（mem）方式打开了 “/sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0/resource0” 和 “/sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0/resource1” ，同时以文件读写形式 (7u,9u) 打开了 “/sys/devices/pci0000:00/0000:00:00.0/config” 和 “/sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0/config” 事实上， PCI 设备对应的 kobject 目录下的 config 正是代表PCI设备的 “配置空间”，对于普通 PCI (非PCI-E)设备而言，其配置空间大小一般是 256字节，这个空间可以使用十六进制工具 dump 出来，如下。(有关 PCI 设备本身的三种地址空间，请参考附录 LDD3)12345678910# hexdump -C /sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0/config00000000 39 10 30 63 03 00 30 02 00 00 00 03 00 00 00 80 |9.0c..0.........|00000010 08 00 00 d8 00 00 00 e1 01 d0 00 00 00 00 00 00 |................|00000020 00 00 00 00 00 00 00 00 00 00 00 00 19 10 30 1b |..............0.|00000030 00 00 00 00 40 00 00 00 00 00 00 00 00 00 00 00 |....@...........|00000040 01 50 02 06 00 00 00 00 00 00 00 00 00 00 00 00 |.P..............|00000050 02 00 30 00 0b 02 00 ff 00 00 00 00 00 00 00 00 |..0.............|00000060 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|*00000100 这个空间正好是 256字节大小，熟悉 PCI 的人们还可以知道，从 PCI 配置空间可以读到有关此 PCI 设备的很多有用信息，如厂商代码，设备代码，IRQ 号码等；前四个字节 0x39 0x10 0x30 0x63 就是按小端(little endian)存放的2个短整数，因此其 PCI 厂商号码和 PCI 设备号码分别是 0x1039 和 0x63301234567891011# lspci -v -d 1039:633001:00.0 VGA compatible controller: Silicon Integrated Systems [SiS] 661/741/760 PCI/AGP \\or 662/761Gx PCIE VGA Display Adapter (prog-if 00 [VGA controller]) Subsystem: Elitegroup Computer Systems Device 1b30 Flags: 66MHz, medium devsel BIST result: 00 Memory at d8000000 (32-bit, prefetchable) [size=128M] Memory at e1000000 (32-bit, non-prefetchable) [size=128K] I/O ports at d000 [size=128] Capabilities: [40] Power Management version 2 Capabilities: [50] AGP version 3.0 在 PCI 设备上除了有 config 是配置空间对用户的接口以外，还有 resource{0,1,2,…} 是资源空间，对应着 PCI 设备的可映射内存空间；此外 PCI 设备还提供了很多接口，全部列表如下：123456789101112131415161718192021222324# ls -lU /sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0/总计 0-rw-r--r-- 1 root root 4096 12-09 00:28 uevent-r--r--r-- 1 root root 4096 12-09 00:27 resource-r--r--r-- 1 root root 4096 12-09 00:27 vendor-r--r--r-- 1 root root 4096 12-09 00:27 device-r--r--r-- 1 root root 4096 12-09 00:28 subsystem_vendor-r--r--r-- 1 root root 4096 12-09 00:28 subsystem_device-r--r--r-- 1 root root 4096 12-09 00:27 class-r--r--r-- 1 root root 4096 12-09 00:27 irq-r--r--r-- 1 root root 4096 12-09 00:28 local_cpus-r--r--r-- 1 root root 4096 12-09 00:28 local_cpulist-r--r--r-- 1 root root 4096 12-09 00:28 modalias-rw------- 1 root root 4096 12-09 00:28 enable-rw-r--r-- 1 root root 4096 12-09 00:28 broken_parity_status-rw-r--r-- 1 root root 4096 12-09 00:28 msi_buslrwxrwxrwx 1 root root 0 12-09 00:28 subsystem -&gt; ../../../../bus/pcidrwxr-xr-x 2 root root 0 12-09 00:28 power-rw-r--r-- 1 root root 256 12-08 23:03 config-rw------- 1 root root 134217728 12-08 23:03 resource0-rw------- 1 root root 134217728 12-09 00:28 resource0_wc-rw------- 1 root root 131072 12-08 23:03 resource1-rw------- 1 root root 128 12-09 00:28 resource2-r-------- 1 root root 0 12-09 00:28 rom 可以看到很多其它属性文件，这些属性文件的权限位也都是正确的，有 w 权限位的才是可以写入。其中大小为 4096字节的属性一般是纯文本描述的属性，可以直接 cat 读出和用 echo 字符串的方法写入；其它非 4096字节大小的一般是二进制属性，类似于上面的 config 属性文件；关于纯文本属性和二进制属性，在下文 编程实践：添加sysfs支持 一节会进一步说明。 从 vendor, device, subsystem_vendor, subsystem_device, class, resource 这些只读属性上分别可以读到此 PCI 设备的厂商号、设备号、子系统厂商号、子系统设备号、PCI类别、资源表等，这些都是相应 PCI 设备的属性，其实就是直接从 config 二进制文件读出来，按照配置空间的格式读出这些号码；使用 enable 这个可写属性可以禁用或启用这个 PCI 设备，设备的过程很直观，写入1代表启用，写入0则代表禁用；subsystem 和 driver 符号链接文件分别指向对应的 sysfs 位置；(这里缺少 driver 符号链接说明这个设备当前未使用内核级的驱动程序)resource0, resource0_wc, resource1, resource2 等是从”PCI 配置空间”解析出来的资源定义段落分别生成的，它们是 PCI 总线驱动在 PCI 设备初始化阶段加上去的，都是二进制属性，但没有实现读写接口，只支持 mmap 内存映射接口，尝试进行读写会提示 IO 错误，其中 _wc 后缀表示 “合并式写入(write combined)” ，它们用于作应用程序的内存映射，就可以访问对应的 PCI 设备上相应的内存资源段落；有了 PCI 核心对 sysfs 的完善支持，每个设备甚至不用单独的驱动程序，如这里的 “0000:01:00.0” 不需要一个内核级的驱动程序，有了 PCI 核心对该设备的配置空间发现机制，可以自动发现它的各个不同段落的资源属性，在 Xorg 应用程序中可以直接以 “/usr/lib/xorg/modules/drivers/sis_drv.so” 这个用户空间的驱动程序对其进行映射，就可以直接操作此视频卡了；有了这一个 PCI 设备的示例可以知道，有了一个 PCI 设备的 /sys/devices/ 设备对象，去访问它的各项属性和设置属性都非常简单。 使用 uevent在 sysfs 下的很多 kobject 下都有 uevent 属性，它主要用于内核与 udev (自动设备发现程序)之间的一个通信接口；从 udev 本身与内核的通信接口 netlink 协议套接字来说，它并不需要知道设备的 uevent 属性文件，但多了 uevent 这样一个接口，可用于 udevmonitor 通过内核向 udevd (udev 后台程序)发送消息，也可用于检查设备本身所支持的 netlink 消息上的环境变量，这个特性一般用于开发人员调试 udev 规则文件， udevtrigger 这个调试工具本身就是以写各设备的 uevent 属性文件实现的。这些 uevent 属性文件一般都是可写的，其中 /sys/devices/ 树下的很多 uevent 属性在较新内核下还支持可读：12345678910111213141516171819# find /sys/ -type f -name uevent -ls 11 0 -rw-r--r-- 1 root root 4096 12月 12 21:10 \\/sys/devices/platform/uevent 1471 0 -rw-r--r-- 1 root root 4096 12月 12 21:10 \\/sys/devices/platform/pcspkr/uevent 3075 0 -rw-r--r-- 1 root root 4096 12月 12 21:10 \\/sys/devices/platform/vesafb.0/uevent 3915 0 -rw-r--r-- 1 root root 4096 12月 12 21:10 \\/sys/devices/platform/serial8250/uevent 3941 0 -rw-r--r-- 1 root root 4096 12月 12 21:10 \\/sys/devices/platform/serial8250/tty/ttyS2/uevent 3950 0 -rw-r--r-- 1 root root 4096 12月 12 21:10 \\/sys/devices/platform/serial8250/tty/ttyS3/uevent 5204 0 -rw-r--r-- 1 root root 4096 12月 12 21:10 \\/sys/devices/platform/i8042/uevent[...] 912 0 -rw-r--r-- 1 root root 4096 12月 12 21:17 \\/sys/devices/pci0000:00/0000:00:02.5/uevent[...] 上面截取的最后一个是 SCSI 硬盘控制器设备的 uevent 属性文件，这些 /devices/ 属性文件都支持写入，当前支持写入的参数有 “add”,”remove”,”change”,”move”,”online”,”offline”。如，写入 “add”，这样可以向 udevd 发送一条 netlink 消息，让它再重新一遍相关的 udev 规则文件；这个功能对开发人员调试 udev 规则文件很有用。1# echo add &gt; /sys/devices/pci0000:00/0000:00:02.5/uevent 使用驱动(PCI)的 sysfs 属性文件， bind, unbind 和 new_id在设备驱动 /sys/bus/*/driver/… 下可以看到很多驱动都有 bind, unbind, new_id 这三个属性，12# find /sys/bus/*/drivers/ -name bind -ls.. 每一个设备驱动程序在程序内以某种方式注明了可用于哪些硬件，如所有的 PCI 驱动都使用 MODULE_DEVICE_TABLE 声明了所能驱动的 PCI 硬件的 PCI 设备号。但驱动程序不能预知未来，未来生产的新的硬件有可能兼容现有硬件的工作方式，就还可以使用现有硬件驱动程序来工作。在 bind 和 unbind 发明以前，这种情况除了修改 PCI 设备驱动程序的 DEVICE_TABLE 段落，重新编译驱动程序，以外别无他法，在 2.6 内核上添加了 bind 和 unbind 之后可以在不重新编译的情况下对设备和驱动之间进行手工方式地绑定。 而且对于有些硬件设备可以有多份驱动可用，但任何具体时刻只能有一个驱动程序来驱动这个硬件，这时可以使用 bind/unbind 来强制使用和不使用哪一个驱动程序；(注意关于多种驱动程序的选择，更好的管理方法是使用 modprobe.conf 配置文件，需要重启才生效，而 bind/unbind 提供的是一种临时的无需重启立即生效的途径；) 使用它们可以强制绑定某个设备使用或强制不使用某个驱动程序，操作方法就是通过 bind 和 unbind 接口。 123456789101112# find /sys/ -type f \\( -name bind -or -name unbind -or -name new_id \\) -ls 69 0 -rw-r--r-- 1 root root 4096 12月 12 22:12 \\/sys/devices/virtual/vtconsole/vtcon0/bind 3072 0 --w------- 1 root root 4096 12月 12 22:15 \\/sys/bus/platform/drivers/vesafb/unbind[...] 6489 0 --w------- 1 root root 4096 12月 12 22:09 \\/sys/bus/pci/drivers/8139too/unbind 6490 0 --w------- 1 root root 4096 12月 12 22:09 \\/sys/bus/pci/drivers/8139too/bind 6491 0 --w------- 1 root root 4096 12月 12 22:15 \\/sys/bus/pci/drivers/8139too/new_id 这个结果中特别提到了 8139too 这份驱动程序的这三个属性文件，12345678910111213141516171819202122232425262728293031323334353637383940414243# find /sys/bus/pci/drivers/8139too/ -ls 6435 0 drwxr-xr-x 2 root root 0 12月 12 22:08 \\/sys/bus/pci/drivers/8139too/ 6436 0 lrwxrwxrwx 1 root root 0 12月 12 22:08 \\/sys/bus/pci/drivers/8139too/0000:00:0e.0 -&gt; ../../../../devices/pci0000:00/0000:00:0e.0 6485 0 lrwxrwxrwx 1 root root 0 12月 12 22:08 \\/sys/bus/pci/drivers/8139too/module -&gt; ../../../../module/8139too 6488 0 --w------- 1 root root 4096 12月 12 22:08 \\/sys/bus/pci/drivers/8139too/uevent 6489 0 --w------- 1 root root 4096 12月 12 22:08 \\/sys/bus/pci/drivers/8139too/unbind 6490 0 --w------- 1 root root 4096 12月 12 22:08 \\/sys/bus/pci/drivers/8139too/bind 6491 0 --w------- 1 root root 4096 12月 12 22:08 \\/sys/bus/pci/drivers/8139too/new_id# echo 0000:00:0e.0 &gt; /sys/bus/pci/drivers/8139too/unbind-bash: echo: write error: 没有那个设备# ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 16436 qdisc noqueue state UNKNOWN link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state \\UNKNOWN qlen 1000 link/ether 00:14:2a:d1:16:72 brd ff:ff:ff:ff:ff:ff inet 192.168.1.102/24 brd 192.168.1.255 scope global eth03: bond0: &lt;BROADCAST,MULTICAST,MASTER&gt; mtu 1500 qdisc noop state DOWN link/ether 00:00:00:00:00:00 brd ff:ff:ff:ff:ff:ff# echo -n 0000:00:0e.0 &gt; /sys/bus/pci/drivers/8139too/unbind# ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 16436 qdisc noqueue state UNKNOWN link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo3: bond0: &lt;BROADCAST,MULTICAST,MASTER&gt; mtu 1500 qdisc noop state DOWN link/ether 00:00:00:00:00:00 brd ff:ff:ff:ff:ff:ff# echo -n 0000:00:0e.0 &gt; /sys/bus/pci/drivers/8139too/bind# ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 16436 qdisc noqueue state UNKNOWN link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo3: bond0: &lt;BROADCAST,MULTICAST,MASTER&gt; mtu 1500 qdisc noop state DOWN link/ether 00:00:00:00:00:00 brd ff:ff:ff:ff:ff:ff4: eth0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN qlen 1000 link/ether 00:14:2a:d1:16:72 brd ff:ff:ff:ff:ff:ff 这一段操作过程演示了如何对 PCI 设备 “0000:00:0e.0” 强制取消绑定 “8139too” 驱动和强制绑定 “8139too” 驱动：对 unbind 属性写入总线号码(bus_id)即是强制取消绑定；对 bind 属性写入总线号码(bus_id)即是强制绑定；注意，它要求的写入的是总线号码，对应于PCI设备的总线号码是按照 “domain(4位):bus(2位):slot(2位):function号(不限)” 的方式组织，是可以从其设备 kobject 节点上找到，而其它类型的总线有各自不同的规则；请特别注意： 在这一个例子中， “echo 0000:00:0e.0 &gt; /sys/bus/pci/drivers/8139too/unbind” 这第一个写入命令以 “No such device” 为错误退出，而后续的 “echo -n” 命令则可以成功。这是因为内核在对总线号码进行匹配时过于严格了，通常的 “echo” 命令写入一个字符串会以一个换行符结束输出，内核所接收到的是带有这个换行符的 bus_id 字符串，将它与内核数据结构中的真正的 bus_id 字符串相比较，当然不能找到；所幸的是，这个问题在最新的 2.6.28 开发中的内核上已已经解决，它将这个比较函数改为一个特殊实现的字符串比较，自动忽略结尾处的换行符，在 2.6.28-rc6 内核上测试，不带”-n”参数的 echo 命令已经可以写入成功。而 new_id 属性文件也可以以另一种途径解决新的设备号问题：它是一个只写的驱动属性，可用于向其中写新的设备号。它支持写入 2至7个十六进制整形参数，分别代表 vendor, device, subvendor, subdevice, class, class_mask, driver_data 最少为 2个是因为一个 PCI设备主要以厂商号(vendor)和设备号(device)所唯一标定，其它 5个参数如果不输入则缺省值为 PCI_ANY_ID(0xffff)。 125441 0 --w------- 1 root root 4096 12月 14 18:15 \\/sys/bus/pci/drivers/8139too/new_id 从 8139too 驱动上可以看到它当前所静态支持的设备号码列表，其中包括当前系统中的设备 10ec:8139, 假设未来有一款 8140 设备也满足 8139 设备的硬件通讯协议，于是可以使用 8139too 驱动程序来驱动它，操作如下 1# echo &apos;10ec 8140&apos; &gt; /sys/bus/pci/drivers/8139too/new_id 这在不更新驱动程序的情况下调试设备很有用处。 使用 scsi_host 的 scan 属性在具有使用 SCSI 总线连接的主机上，与 PCI类似的是也采用四个号码作为一组来描述一个设备，其中位于最顶层的是 scsi_host。我们从设备类别 /class/为起点来探索：123456# ls -lU /sys/class/scsi_host总计 0lrwxrwxrwx 1 root root 0 12-13 01:59 host0 -&gt; \\../../devices/pci0000:00/0000:00:02.5/host0/scsi_host/host0lrwxrwxrwx 1 root root 0 12-13 01:59 host1 -&gt; \\../../devices/pci0000:00/0000:00:02.5/host1/scsi_host/host1 注意这是 2.6.27 内核的最新变化，在 /sys/class/ 下的都改为符号链接，真实的 kobject 都存在于 /sys/devices/ 中；我们这里探索其中的 host0 这个 SCSI 控制器：123456789101112131415161718192021# readlink -f /sys/class/scsi_host/host0/sys/devices/pci0000:00/0000:00:02.5/host0/scsi_host/host0# ls -lU /sys/devices/pci0000:00/0000:00:02.5/host0/scsi_host/host0总计 0-rw-r--r-- 1 root root 4096 12-13 02:02 ueventlrwxrwxrwx 1 root root 0 12-13 02:02 subsystem -&gt; ../../../../../../class/scsi_hostlrwxrwxrwx 1 root root 0 12-13 02:02 device -&gt; ../../../host0-r--r--r-- 1 root root 4096 12-13 02:02 unique_id-r--r--r-- 1 root root 4096 12-13 02:02 host_busy-r--r--r-- 1 root root 4096 12-13 02:02 cmd_per_lun-r--r--r-- 1 root root 4096 12-13 02:02 can_queue-r--r--r-- 1 root root 4096 12-13 02:02 sg_tablesize-r--r--r-- 1 root root 4096 12-13 02:02 unchecked_isa_dma-r--r--r-- 1 root root 4096 12-13 02:02 proc_name--w------- 1 root root 4096 12-13 02:02 scan-rw-r--r-- 1 root root 4096 12-13 02:02 state-rw-r--r-- 1 root root 4096 12-13 02:02 supported_mode-rw-r--r-- 1 root root 4096 12-13 02:02 active_mode-r--r--r-- 1 root root 4096 12-13 02:02 prot_capabilities-r--r--r-- 1 root root 4096 12-13 02:02 prot_guard_typedrwxr-xr-x 2 root root 0 12-13 02:02 power 对这些属性文件解释如下：有四个 SCSI 特有的可写参数： scan,state,supported_mode,active_mode；可以向其中写入不同的参数来控制此 SCSI 控制器的各种状态；其它一些可读属性用于读取这个 SCSI 控制器的一些当前值；其中的 scan 属性文件在调试一些 SCSI 硬件驱动时很有用，它是只写的，可以写入三个至四个以空格分开的整数，用于分别指定对应的 host, channel, id, lun 进行重新搜索。且这个 scan 属性支持以”-“作为通配符，如以下命令可以执行让整个 scsi_host 进行重新搜索，这个功能用于调试某些对热挺拔实现不完善的 SCSI 驱动程序很有用：1# echo &apos;- - -&apos; &gt;/sys/devices/pci0000:00/0000:00:02.5/host0/scsi_host/host0/scan 内核模块中的 sysfs 属性文件以一个 8139too 模块为例解释在这个 kboject 下每一个属性的用途；12345678910111213# find /sys/module/8139too/ -ls 6408 0 -r--r--r-- 1 root root 4096 12月 13 02:17 \\/sys/module/8139too/version 6412 0 drwxr-xr-x 2 root root 0 12月 13 02:17 \\/sys/module/8139too/sections 6433 0 drwxr-xr-x 2 root root 0 12月 13 02:17 \\/sys/module/8139too/notes 6434 0 -r--r--r-- 1 root root 36 12月 13 02:17 \\/sys/module/8139too/notes/.note.gnu.build-id 6486 0 drwxr-xr-x 2 root root 0 12月 13 02:17 \\/sys/module/8139too/drivers 6487 0 lrwxrwxrwx 1 root root 0 12月 13 02:17 \\/sys/module/8139too/drivers/pci:8139too -&gt; ../../../bus/pci/drivers/8139too 其中的属性文件都是只读的，用于提供信息。从 version, srcversion 上可以了解到这个模块所声明的版本号，源码版本号， refcnt 是模块引用计数， sections 属性组中有一些模块加载至内存的相应节信息， drivers/ 目录中是对所提供的驱动的链接；因为模块是内核驱动编程的最佳选择，而一个模块有可能提供多个驱动程序，因而在未知一个设备在用哪一个驱动的情况下可以先从 /sys/module/ 查找相应模块的情况，再从 drivers/ 发现出真正的驱动程序。或者也可以完全反过来利用这些信息，先用 lspci/lshw 等工具找到 /sys/devices/ 下的设备节点，再从其设备的 driver 链接找到 /sys/bus//drivers/ 下的 device_driver, 再从 device_driver 下的 module 链接找到 /sys/module//，这样就可以得到已加载模块中空间是哪一个模块在给一个设备提供驱动程序。 更多 sysfs 属性文件以上所举的例子仅仅是一些常见的 sysfs 属性用法，实际的系统中还常常有很多其它的从未见过的 sysfs 属性，因此只有举例是不够的，即使维护了一份 sysfs 属性用法参考大全也不够，未来的内核版本还会出现新的 sysfs 属性，因此还必须了解 Linux 内核代码以找到实现这些属性的代码位置，以学会在没有相应属性文档的情况从内核源代码来分析其 sysfs 属性功能。 一个实例参考博客： 小结sysfs 给应用程序提供了统一访问设备的接口，但可以看到， sysfs 仅仅是提供了一个可以统一访问设备的框架，但究竟是否支持 sysfs 还需要各设备驱动程序的编程支持；在 2.6 内核诞生 5年以来的发展中，很多子系统、设备驱动程序逐渐转向了 sysfs 作为与用户空间友好的接口，但仍然也存在大量的代码还在使用旧的 proc 或虚拟字符设备的 ioctl 方式；如果仅从最终用户的角度来说， sysfs 与 proc 都是在提供相同或类似的功能，对于旧的 proc 代码，没有绝对的必要去做 proc 至 sysfs 的升级；因此在可预见的将来， sysfs 会与 proc, debugfs, configfs 等共存很长一段时间。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"Linux 统一设备模型","slug":"Linux/[Linux] 统一设备模型","date":"2015-12-30T22:06:06.000Z","updated":"2018-11-08T01:47:21.028Z","comments":true,"path":"2015/12/31/Linux/[Linux] 统一设备模型/","link":"","permalink":"http://iyounix.com/2015/12/31/Linux/[Linux] 统一设备模型/","excerpt":"","text":"统一设备模型是 Linux 2.5 内核开始开发的一套新设备模型。目的是为了对计算机上所有的设备进行统一的操作和表示。这个模型是在分析了 PCI 和 USB 的总线驱动过程中得到的，他们两种总线类型能代表当前系统中大多数设备类型，它们都有完善的热插拔机制和电源管理的支持，也有级联机制的支持，以桥接 PCI/USB 总线控制器的方式可以支持更多的设备。 比如典型的 PC 系统中， CPU 控制的是 PCI 总线，USB 总线是以一个 PCI-USB 桥的形式接在 PCI 总线设备上，外部 USB 再接在 USB 总线设备上。当 计算机 挂起（suspend）时，Linux 内核应该以“外部USB-&gt;USB总线-&gt;PCI总线设备”的顺序通知每一个设备将电源挂起;执行恢复（resume）时，则以相反的顺序通知;反之如果不按此顺序将有设备得不到正确 电源状态变迁的通知，将无法正常工作。 基本结构：|类型|所包含内容|对应内核数据结构|对应/sys项目||–|–|–|–||设备Devices|设备是此模型中最基本的类型，以设备本身的链接按层次组织|struct device|/sys/devices/ / / …/ ||设备驱动Device Drivers|在一个系统中安装多个相同设备，只需要一份驱动程序的支持|struct device_driver|/sys/bus/pci/drivers/ /||总线类型Bus Types|在整个总线级别上对如此总线上连接的所有设备进行管理|struct bus_type| /sys/bus/ / ||设备类别Device Classes|这是按照功能进行分类组织的设备层次树；如 USB 接口和 PS/2 接口的鼠标都是输入设备，都会出现在 /sys/class/input/ 下 | struct class |/sys/class/ * /| 从内核实现它们时所使用的数据结构来说，Linux 统一设备模型又是以两种基本数据结构进行树型和链表型结构组织的。 kobject 在 Linux 设备模型中最基本的对象，它的功能是提供引入计数和维持父子（parent）结构 、平级（sibling）目录关系，上面的 device ，device_driver 等各对象都是以 kobject 基础功能之上实现的;12345678910111213struct kobject &#123; const char *name; struct list_head entry; struct kobject *parent; struct kset *kset; struct kobj_type *ktype; struct sysfs_dirent *sd; struct kref kref; unsigned int state_initialized:1; unsigned int state_in_sysfs:1; unsigned int state_add_uevent_sent:1; unsigned int state_remove_uevent_sent:1;&#125;; 其中 struct kref 内含一个 atuomic_t 类型用于引用计数，parent 是单个指向 父节点的指针，entry 用于父 kset 以链表结构将 kobject 维护成双向链表。 kset：它用来对同类型对象提供一个包装集合，在内核数据结构上它也是由内嵌(继承)一个 kboject 实现，因而它同时也是一个 kobject ，具有 kobject 的全部功能；123456struct kset &#123; struct list_head list; spinlock_t list_lock; struct kobject kobj; struct kset_uevent_ops *uevent_ops;&#125;; 其中的 struct list_head list 用于将集合中的 kobject 按 struct list_head entry 维护成双向链表；","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"Linux 服务器添加硬盘方法","slug":"Linux/[Linux] 服务器添加硬盘方法","date":"2015-12-30T22:06:06.000Z","updated":"2018-11-08T01:53:05.134Z","comments":true,"path":"2015/12/31/Linux/[Linux] 服务器添加硬盘方法/","link":"","permalink":"http://iyounix.com/2015/12/31/Linux/[Linux] 服务器添加硬盘方法/","excerpt":"","text":"服务器容量 10 T 竟然只剩 50G 不到了。公司加了 500 G 的普通硬盘用于存放不常用的源码。以下是步骤： 查看当前硬盘状况12$ df -h $ ls -l /dev/sd* 可以看到 sdb 是我们的第二块硬盘 1$ fdisk -l 可以看到Disk /dev/sdb doesn’t contain a valid partition table我们看到 sdb 还未挂载。 添加分区1$ sudo fdisk sdb 按 m 帮助可以看到用法 依次输入n //添加分区p //主要分区 //p表示主要 e表示拓展1 //起始分区号1 //起始扇区 //我这里填的是 2048+500 //最后的扇区W //确认 之后我们就可以在 /dev 下看到 sdb1 的存在了 分区格式化将分区设置为 ext4 格式1$ mkfs -t ext4 /dev/sdb1 执行完这条命令需要等待一下，格式化分区 挂载分区到用户目录比如我们需要挂载这个 sdb1 分区到 用户 atu 的 atusoftware 目录下：在 root 用户下执行12# mkdir /home/atu/atusoftware# mount /dev/sdb1 /home/atu/atusoftware 执行服务器开机自动挂载修改 /etc/fstab 文件1$sudo vi /etc/fstab 添加如下内容1/dev/sdb1 /home/atu/softwaredata ext4 defaults 0 0 该行内容表达的意思是 &lt; file system&gt; 什么文件系统 &lt; mount point&gt; 挂载点在哪 &lt; type&gt; 文件系统的类型呢 &lt; options&gt; 选项，一般填默认 defaults &lt; dump&gt; 是否要备份文件系统，1 备份 0 不备份 &lt; pass&gt; 以什么顺序检查文件系统，0 不检查 点击这里有一篇 /etc/fstab 详解 至此，重新登录 ssh atu@[IP] 可以正常访问下面的 atusoftware 目录。scp 也可以正常上传下载东西。 完。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"Linux 文件批量重命名 rename","slug":"Linux/[Linux] 文件批量重命名 rename","date":"2015-12-30T22:06:06.000Z","updated":"2018-11-08T01:53:15.986Z","comments":true,"path":"2015/12/31/Linux/[Linux] 文件批量重命名 rename/","link":"","permalink":"http://iyounix.com/2015/12/31/Linux/[Linux] 文件批量重命名 rename/","excerpt":"","text":"OS : Ubuntu16.04 需求场景修改 bootanimation 的时候美工发过来的文件太多了 , 需要批量重命名 方法Linux 下的 rename 命令格式是1rename &apos;s/修改前的内容/修改后的内容/&apos; 要修改的文件 批量添加后缀 txt1rename &apos;s/$/\\.txt/&apos; * $ 表示结束符,\\.txt 表示修改为 .txt 批量修改后缀1rename &apos;s/\\.txt/\\.bat/&apos; 将 .txt 改为 .bat 将 10_01_001.png 改名为 001.png1rename &apos;s/10_01_//&apos; man rename更多的参看 man rename","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"Linux 内核的 proc 文件系统","slug":"Linux/[Linux] 内核的 proc 文件系统","date":"2015-12-30T22:06:06.000Z","updated":"2018-11-08T01:49:03.949Z","comments":true,"path":"2015/12/31/Linux/[Linux] 内核的 proc 文件系统/","link":"","permalink":"http://iyounix.com/2015/12/31/Linux/[Linux] 内核的 proc 文件系统/","excerpt":"","text":"内核现在采用的是 sysfs 文件系统。在 sysfs 诞生之前我们采用的是 proc 文件系统。sysfs 是一个与 /proc 类似的文件系统，但是它的组织更好（从 /proc 中学习了很多教训）。不过 /proc 已经确立了自己的地位，因此即使 sysfs 与 /proc 相比有一些优点，/proc 也依然会存在。本文对 /proc 文件系统一些基础的知识进行归纳和整理。 另外还有一个 debugfs 文件系统，不过（顾名思义）它提供的更多是调试接口。debugfs 的一个优点是它将一个值导出给用户空间非常简单（实际上这不过是一个调用而已）。 proc 是一个虚拟的文件系统，我们利用它实现 Linux 内核空间与用户空间 的通信。在 proc 文件系统中，我们可以将对虚拟文件的读写作为与内核中实体进行通信的一种手段，但是与普通文件不同的是，这些虚拟文件的内容都是动态创建的。 proc 虚拟文件系统介绍最初这个是为了提供有关文件系统中进程的信息。后来因为很有用，内核中其他元素也用其报告信息，或进行动态运行配置。/proc 文件系统包含了一些目录和虚拟文件。虚拟文件向用户呈现内核中的信息，同时也是用户空间向内核发送信息的手段。 呈现内核信息1234567891011121314[root@younixPC]# ls /proc1 2040 2347 2874 474 fb mdstat sys104 2061 2356 2930 9 filesystems meminfo sysrq-trigger113 2073 2375 2933 acpi fs misc sysvipc1375 21 2409 2934 buddyinfo ide modules tty1395 2189 2445 2935 bus interrupts mounts uptime1706 2201 2514 2938 cmdline iomem mtrr version179 2211 2515 2947 cpuinfo ioports net vmstat180 2223 2607 3 crypto irq partitions181 2278 2608 3004 devices kallsyms pci182 2291 2609 3008 diskstats kcore self2 2301 263 3056 dma kmsg slabinfo2015 2311 2805 394 driver loadavg stat2019 2337 2821 4 execdomains locks swaps 左边是一系列数字编号的文件。每个实际上都是一个目录，表示系统中的一个进程。由于在 GNU/Linux 中创建的第一个进程是 init 进程，因此它的 process-id 为 1。然后对这个目录执行一个 ls 命令，这会显示很多文件。123[root@younixPC]# ls /proc/1auxv cwd exe loginuid mem oom_adj root statm taskcmdline environ fd maps mounts oom_score stat status wchan 每个文件都提供了有关这个特殊进程的详细信息。例如，要查看 init 的 command-line 项的内容，只需对 cmdline 文件执行 cat 命令。12[root@younixPC]# cat /proc/1/cmdlineinit [5] /proc 中另外一些有趣的文件有：cpuinfo，它标识了处理器的类型和速度；pci，显示在 PCI 总线上找到的设备；modules，标识了当前加载到内核中的模块。 配置内核信息下面对 /proc 中的一个虚拟文件进行读写（配置），首先检查内核的 TCP/IP 栈中 IP 转发的目前设置，然后启动这种功能。12345root@younixPC:/# cat /proc/sys/net/ipv4/ip_forward0root@younixPC:/# echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forwardroot@younixPC:/# cat /proc/sys/net/ipv4/ip_forward1 我们还可以用 sysctl 来配置这些内核条目。 内核模块简介可加载内核模块（LKM）是用来展示 /proc 文件系统的一种方法。它用来动态地向 Linux 内核添加或者删除代码。LKM 也是 Linux 内核中为设备驱动程序和文件系统使用的一种机制。 如果一个驱动程序被直接编译到了内核中，那么即使这个驱动程序没有运行，它的代码和静态数据也会占据一部分空间。为了节省空间，我们采用动态模块编译的方法，将这个驱动程序编译成一个模块 .ko ，那么就只在其需要内存并将其加载进内核时才占用内存空间。 这样可以根据可用硬件和连接的设备来加载对应的模块。 一个最简单的 LKM 实例（simple-lkm.c）123456789101112131415161718#include &lt;linux/module.h&gt;/* Defines the license for this LKM */MODULE_LICENSE(&quot;GPL&quot;);/* Init function called on module entry */int my_module_init( void )&#123; printk(KERN_INFO &quot;my_module_init called. Module is now loaded.\\n&quot;); return 0;&#125;/* Cleanup function called on module exit */void my_module_cleanup( void )&#123; printk(KERN_INFO &quot;my_module_cleanup called. Module is now unloaded.\\n&quot;); return;&#125;/* Declare entry and exit functions */module_init( my_module_init );module_exit( my_module_cleanup ); 对于这个文件 simple-lkm.c 我们可以创建一个 Makefile ，其内容如下：1obj-m += simple-lkm.o 使用 make 来进行编译：12345678younix@younixPC:~/Code/Linux/Moudle$ make -C /usr/src/linux-headers-4.4.0-24-generic SUBDIRS=$PWD modulesmake: Entering directory &apos;/usr/src/linux-headers-4.4.0-24-generic&apos; CC [M] /home/younix/Code/Linux/Moudle/simple-lkm.o Building modules, stage 2. MODPOST 1 modules CC /home/younix/Code/Linux/Moudle/simple-lkm.mod.o LD [M] /home/younix/Code/Linux/Moudle/simple-lkm.komake: Leaving directory &apos;/usr/src/linux-headers-4.4.0-24-generic&apos; 结果生成了一个 simple-lkm.ko 的文件。现在可以加载或者卸载这个模块了，然后可以查看其输出。insmod 命令加载rmmod 命令卸载lsmod 显示当前的加载项12345root@younixPC:/home/younix/Code/Linux/Moudle# insmod simple-lkm.koroot@younixPC:/home/younix/Code/Linux/Moudle# lsmodModule Size Used bysimple_lkm 16384 0root@younixPC:/home/younix/Code/Linux/Moudle# rmmod simple-lkm 另外，内核的输出进入了 内核的环形缓冲区中，并没有打印到 stdout 上。使用 dmesg 工具或者使用 cat /proc/kmsg 来查看其内容。123root@younixPC:/home/younix/Code/Linux/Moudle# dmesg &gt; dmesg.txtmy_module_init called. Module is now loaded.my_module_cleanup called. Module is now unloaded. 将 LKM 集成到 /proc 文件系统中这里简单地介绍一下在展示一个更有用的 LKM 时所使用的几个元素。 创建并删除 /proc 项create_proc_entry创建一个虚拟文件。这个函数可以接收一个文件名、一组权限和这个文件在 /proc 文件系统中出现的位置。create_proc_entry 的返回值是一个 proc_dir_entry 指针（或者为 NULL，说明在 create 时发生了错误）。然后就可以使用这个返回的指针来配置这个虚拟文件的其他参数，例如在对该文件执行读操作时应该调用的函数。create_proc_entry 的原型和 proc_dir_entry 结构中的一部分如下所示。1234567891011121314151617struct proc_dir_entry *create_proc_entry( const char *name, mode_t mode, struct proc_dir_entry *parent );struct proc_dir_entry &#123; const char *name; // virtual file name mode_t mode; // mode permissions uid_t uid; // File's user id gid_t gid; // File's group id struct inode_operations *proc_iops; // Inode operations functions struct file_operations *proc_fops; // File operations functions struct proc_dir_entry *parent; // Parent directory ... read_proc_t *read_proc; // /proc read function write_proc_t *write_proc; // /proc write function void *data; // Pointer to private data atomic_t count; // use count ...&#125;; read_proc / write_proc插入对这个虚拟文件进行读写的函数。 remove_proc_entry需要提供文件名字符串，以及这个文件在 /proc 文件系统中的位置（parent）。1void remove_proc_entry( const char *name, struct proc_dir_entry *parent ); parent 参数可以为 NULL（表示 /proc 根目录），也可以是很多其他值，这取决于我们希望将这个文件放到什么地方。下面列出了可以使用的其他一些父 proc_dir_entry，以及它们在这个文件系统中的位置。|proc_dir_entry |在文件系统中的位置||–|–||proc_root_fs| /proc||proc_net| /proc/net||proc_bus| /proc/bus||proc_root_driver| /proc/driver| 写回调函数write 函数原型12int mod_write( struct file *filp, const char __user *buff, unsigned long len, void *data ); filp 参数实际上是一个打开文件结构（我们可以忽略这个参数）。buff 参数是传递给您的字符串数据。缓冲区地址实际上是一个用户空间的缓冲区，因此我们不能直接读取它。len 参数定义了在 buff 中有多少数据要被写入。data 参数是一个指向私有数据的指针。在这个模块中，我们声明了一个这种类型的函数来处理到达的数据。我们使用 copy_from_user 函数来维护用户空间的数据。 读回调函数read 写回调函数12int mod_read( char *page, char **start, off_t off, int count, int *eof, void *data ); page 参数是这些数据写入到的位置count 定义了可以写入的最大字符数。在返回多页数据（通常一页是 4KB）时，我们需要使用 start 和 off 参数。当所有数据全部写入之后，就需要设置 eof（文件结束参数）。与 write 类似，data 表示的也是私有数据。此处提供的 page 缓冲区在内核空间中。因此，我们可以直接写入，而不用调用 copy_to_user。 其他有用的 proc 函数proc_mkdir、symlinks 以及 proc_symlink 在 /proc 文件系统中创建目录。对于只需要一个 read 函数的简单 /proc 项来说，可以使用 create_proc_read_entry，这会创建一个 /proc 项，并在一个调用中对 read_proc 函数进行初始化。1234567891011121314151617181920212223242526272829/* Create a directory in the proc filesystem */struct proc_dir_entry *proc_mkdir( const char *name, struct proc_dir_entry *parent );/* Create a symlink in the proc filesystem */struct proc_dir_entry *proc_symlink( const char *name, struct proc_dir_entry *parent, const char *dest );/* Create a proc_dir_entry with a read_proc_t in one call */struct proc_dir_entry *create_proc_read_entry( const char *name, mode_t mode, struct proc_dir_entry *base, read_proc_t *read_proc, void *data );/* Copy buffer to user-space from kernel-space */unsigned long copy_to_user( void __user *to, const void *from, unsigned long n );/* Copy buffer to kernel-space from user-space */unsigned long copy_from_user( void *to, const void __user *from, unsigned long n );/* Allocate a 'virtually' contiguous block of memory */void *vmalloc( unsigned long size );/* Free a vmalloc'd block of memory */void vfree( void *addr );/* Export a symbol to the kernel (make it visible to the kernel) */EXPORT_SYMBOL( symbol );/* Export all symbols in a file to the kernel (declare before module.h) */EXPORT_SYMTAB 由 proc 文件系统实现财富分发下面是可以支持读写的 LKM。在加载了这个模块后，用户可以使用 echo 命令向其中导入文本财富。再利用 cat 命令逐一输出。下面给出了基本的模块函数和变量。init 函数（init_fortune_module）负责使用 vmalloc 来为这个点心罐分配空间，然后使用 memset 将其全部清零。使用所分配并已经清空的 cookie_pot 内存，我们在 /proc 中创建了一个 proc_dir_entry 项，并将其称为 fortune。当 proc_entry 成功创建之后，对自己的本地变量和 proc_entry 结构进行了初始化。我们加载了 /proc read 和 write 函数，并确定这个模块的所有者。cleanup 函数简单地从 /proc 文件系统中删除这一项，然后释放 cookie_pot 所占据的内存。cookie_pot 是一个固定大小（4KB）的页，它使用两个索引进行管理。第一个是 cookie_index，标识了要将下一个 cookie 写到哪里去。变量 next_fortune 标识了下一个 cookie 应该从哪里读取以便进行输出。在所有的 fortune 项都读取之后，我们简单地回到了 next_fortune。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/proc_fs.h&gt;#include &lt;linux/string.h&gt;#include &lt;linux/vmalloc.h&gt;#include &lt;asm/uaccess.h&gt;MODULE_LICENSE(\"GPL\");MODULE_DESCRIPTION(\"Fortune Cookie Kernel Module\");MODULE_AUTHOR(\"M. Tim Jones\");#define MAX_COOKIE_LENGTH PAGE_SIZEstatic struct proc_dir_entry *proc_entry;static char *cookie_pot; // Space for fortune stringsstatic int cookie_index; // Index to write next fortunestatic int next_fortune; // Index to read next fortuneint init_fortune_module( void )&#123; int ret = 0; cookie_pot = (char *)vmalloc( MAX_COOKIE_LENGTH ); if (!cookie_pot) &#123; ret = -ENOMEM; &#125; else &#123; memset( cookie_pot, 0, MAX_COOKIE_LENGTH ); proc_entry = create_proc_entry( \"fortune\", 0644, NULL ); if (proc_entry == NULL) &#123; ret = -ENOMEM; vfree(cookie_pot); printk(KERN_INFO \"fortune: Couldn't create proc entry\\n\"); &#125; else &#123; cookie_index = 0; next_fortune = 0; proc_entry-&gt;read_proc = fortune_read; proc_entry-&gt;write_proc = fortune_write; proc_entry-&gt;owner = THIS_MODULE; printk(KERN_INFO \"fortune: Module loaded.\\n\"); &#125; &#125; return ret;&#125;void cleanup_fortune_module( void )&#123; remove_proc_entry(\"fortune\", &amp;proc_root); vfree(cookie_pot); printk(KERN_INFO \"fortune: Module unloaded.\\n\");&#125;module_init( init_fortune_module );module_exit( cleanup_fortune_module ); 向这个罐中新写入一个 cookie 非常简单。使用这个写入 cookie 的长度，我们可以检查是否有这么多空间可用。如果没有，就返回 -ENOSPC，它会返回给用户空间。否则，就说明空间存在，我们使用 copy_from_user 将用户缓冲区中的数据直接拷贝到 cookie_pot 中。然后增大 cookie_index（基于用户缓冲区的长度）并使用 NULL 来结束这个字符串。最后，返回实际写入 cookie_pot 的字符的个数，它会返回到用户进程。123456789101112131415ssize_t fortune_write( struct file *filp, const char __user *buff, unsigned long len, void *data )&#123; int space_available = (MAX_COOKIE_LENGTH-cookie_index)+1; if (len &gt; space_available) &#123; printk(KERN_INFO \"fortune: cookie pot is full!\\n\"); return -ENOSPC; &#125; if (copy_from_user( &amp;cookie_pot[cookie_index], buff, len )) &#123; return -EFAULT; &#125; cookie_index += len; cookie_pot[cookie_index-1] = 0; return len;&#125; 对 fortune 进行读取也非常简单，如下所示。由于我们刚才写入数据的缓冲区（page）已经在内核空间中了，因此可以直接对其进行操作，并使用 sprintf 来写入下一个 fortune。如果 next_fortune 索引大于 cookie_index（要写入的下一个位置），那么我们就将 next_fortune 返回为 0，这是第一个 fortune 的索引。在将这个 fortune 写入用户缓冲区之后，在 next_fortune 索引上增加刚才写入的 fortune 的长度。这样就变成了下一个可用 fortune 的索引。这个 fortune 的长度会被返回并传递给用户。1234567891011121314int fortune_read( char *page, char **start, off_t off, int count, int *eof, void *data )&#123; int len; if (off &gt; 0) &#123; *eof = 1; return 0; &#125; /* Wrap-around */ if (next_fortune &gt;= cookie_index) next_fortune = 0; len = sprintf(page, \"%s\\n\", &amp;cookie_pot[next_fortune]); next_fortune += len; return len;&#125; 从这个简单的例子中，我们可以看出通过 /proc 文件系统与内核进行通信实际上是件非常简单的事情。现在让我们来看一下这个 fortune 模块的用法：1234567891011[root@younixPC]# insmod fortune.ko[root@younixPC]# echo &quot;Success is an individual proposition. Thomas Watson&quot; &gt; /proc/fortune[root@younixPC]# echo &quot;If a man does his best, what else is there? Gen. Patton&quot; &gt; /proc/fortune[root@younixPC]# echo &quot;Cats: All your base are belong to us. Zero Wing&quot; &gt; /proc/fortune[root@younixPC]# cat /proc/fortuneSuccess is an individual proposition. Thomas Watson[root@younixPC]# cat /proc/fortuneIf a man does his best, what else is there? General Patton /proc 虚拟文件系统可以广泛地用来报告内核的信息，也可以用来进行动态配置。我们会发现它对于驱动程序和模块编程来说都是非常完整的。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"Linux likely() 和 unlikely()","slug":"Linux/[Linux] likely() 和 unlikely()","date":"2015-12-30T22:06:06.000Z","updated":"2018-11-08T01:55:19.735Z","comments":true,"path":"2015/12/31/Linux/[Linux] likely() 和 unlikely()/","link":"","permalink":"http://iyounix.com/2015/12/31/Linux/[Linux] likely() 和 unlikely()/","excerpt":"","text":"[TOC] Version: linux-2.6.32 定义/include/linux/compiler.h12#define likely(x) __builtin_expect(!!(x), 1)#define unlikely(x) __builtin_expect(!!(x), 0) 12//gcc 中提供的预处理命令，利于代码优化。long __builtin_expect (long exp, long c) [Built-in Function] 注解You may use __builtin_expect to provide the compiler with branch prediction information. In general, you should prefer to use actual profile feedback for this (‘-fprofile-arcs’), as programmers are notoriously bad at predicting how their programs actually perform. However, there are applications in which this data is hard to collect.The return value is the value of exp, which should be an integral expression. The semantics of the built-in are that it is expected that exp == c. likely(exp, c) 表示 exp == c 是很可能发生的。unlikely(exp, c) 表示 exp == c 是很可能不会发生的。 用法用在 if 后。使用likely ，执行if后面语句的可能性大些，编译器将if{}是的内容编译到前面。使用unlikely ，执行else后面语句的可能性大些,编译器将else{}里的内容编译到前面。这样有利于cpu预取,提高预取指令的正确率,因而可提高效率。 实例linux-2.6.32.67/arch/arm/lib/uaccess_with_memcpy.c123pgd = pgd_offset(current-&gt;mm, addr);if (unlikely(pgd_none(*pgd) || pgd_bad(*pgd))) return 0; 编译过程中，会将if后面{}里的内容编译到前面。若将likely换成unlikely 则正好相反。 总之,likely与unlikely互换或不用都不会影响程序的正确性。但可能会影响程序的效率。12if(likely(foo)) //认为foo通常为1if(unlikely(foo)) //认为foo通常为0","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"Linux 程序内存检查工具 Valgrind","slug":"Linux/[Linux][Tool] 程序内存检查工具 Valgrind","date":"2015-12-30T22:06:06.000Z","updated":"2018-11-08T01:54:10.173Z","comments":true,"path":"2015/12/31/Linux/[Linux][Tool] 程序内存检查工具 Valgrind/","link":"","permalink":"http://iyounix.com/2015/12/31/Linux/[Linux][Tool] 程序内存检查工具 Valgrind/","excerpt":"","text":"应用 Valgrind 发现 Linux 程序的内存问题：https://www.ibm.com/developerworks/cn/linux/l-cn-valgrind/#icomments","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"Linux passwd 文件格式详解","slug":"Linux/[Linux] passwd 文件格式详解","date":"2015-12-30T22:06:06.000Z","updated":"2018-11-08T01:50:33.721Z","comments":true,"path":"2015/12/31/Linux/[Linux] passwd 文件格式详解/","link":"","permalink":"http://iyounix.com/2015/12/31/Linux/[Linux] passwd 文件格式详解/","excerpt":"","text":"[TOC] 今天发现 /etc/passwd 内容如下12345＃cat/etc/passwdroot:x:0:0:Superuser:/:daemon:x:1:1:Systemdaemons:/etc:bin:x:2:2:Ownerofsystemcommands:/bin:sys:x:3:3:Ownerofsystemfiles:/usr/sys: passwd 格式/etc/passwd 中一行记录对应着一个用户。每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell 用户名代表用户账号的字符串。通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。 口令一些系统中，存放着加密后的用户口令字。虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于 /etc/passwd 文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux系统（如SVR4）都使用了 shadow 技术，把真正的加密后的用户口令字存放到 /etc/shadow 文件中，而在 /etc/passwd 文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。 用户标识号是一个整数，系统内部用它来标识用户。一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。通常用户标识号的取值范围是0～65535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。 组标识号记录的是用户所属的用户组。它对应着/etc/group文件中的一条记录。 注释性描述记录着用户的一些信息 主目录也就是用户的起始工作目录，它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。 登录 shell用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。 伪用户（psuedousers）这些用户在Linux /etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。常见的伪用户如下所示。伪用户含义bin拥有可执行的用户命令文件sys拥有系统文件adm拥有帐户文件uucpUUCP使用lplp或lpd子系统使用nobodyNFS使用拥有帐户文件除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit,cron,mail,usenet等，它们也都各自为相关的进程和文件所需要。 真正的密码（shadow）由于Linux /etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。只有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"Linux 阻塞与非阻塞（等待队列、轮询）","slug":"Linux/[Linux] 中的阻塞与非阻塞（等待队列、轮询）","date":"2015-12-30T22:06:06.000Z","updated":"2018-11-08T01:49:26.013Z","comments":true,"path":"2015/12/31/Linux/[Linux] 中的阻塞与非阻塞（等待队列、轮询）/","link":"","permalink":"http://iyounix.com/2015/12/31/Linux/[Linux] 中的阻塞与非阻塞（等待队列、轮询）/","excerpt":"","text":"[TOC] 基本概念阻塞指执行设备操作时，不能获得资源则挂起进程，被挂起的进程进入休眠，从调度器的进行队列中移走。非阻塞指在不能获得资源的情况下，要么放弃，要么不停地查询，直到可以操作。 等待队列（Wait Queue）Linux 中采用等待队列来实现阻塞进程的唤醒。等待队列以队列为基础数据结构，结合进程调度机制，用来同步对系统资源的访问。 1. 定义等待队列头1wait_queue_head_t my_queue; 2.初始化等待队列头123init_waitqueue_head(&amp;my_queue);//或者DECLAR_WAIT_QUEUE_HEAD(name) 3.定义等待队列元素1DECLARE_WAITQUEUE(name,tsk) 4.添加/移除等待队列1234//将等待队列元素 wait 添加到等待队列头 q 指向的双向链表中void add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait);//将等待队列元素 wait 从由 q 头部指向的链表中移除void remove_wait_queue(wait_queue_head_t *q, wait_queue_t *wait); 5.等待事件123456//等待队列头 queue 被唤醒//condition 必须满足，否则继续阻塞wait_event(queue,condition) wait_event_interruptible(queue, condition) //可以被信号唤醒wait_event_timeout(queue, condition, timeout) //timeout 为阻塞等待超时时间, jiffy 为单位wait_event_interruptible_timeout(queue, condition, timeout) 6.唤醒队列12void wake_up(wait_queue_head_t *queue);void wake_up_interruptible(wait_queue_head_t *queue); 上述操作会唤醒以 queue 作为等待队列头部的队列中的所有进程。wake_up 可以唤醒处于 TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE 的进程。wake_up_interruptible 只能唤醒处于 TASK_INTERRUPTIBLE 的进程。 7.在等待队列上睡眠12sleep_on(wait_queue_head_t *q);interruptible_sleep_on(wait_queue_head_t *q); 轮询select()+poll() 或 epoll123456/* readfds、writefds、 exceptfds 是监视的 读、写、异常处理的文件描述符集合 numfs 是需要检查的号码的最高值+1 readfds 如果有任何文件变得可读 或者 writefds 如果有任何文件变得可写，select() 就会返回*/int select(int numfs, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout) 1234FD_ZERO(fd_set *set) //清除FD_SET(int fd, fd_set *set) //添加FD_CLR(int fd, fd_set *set) //删除FD_ISSET(int fd,fd_set *set) //判断是否被置为 1int poll(struct pollfd *fds, nfds_t nfds, int timeout); 但是我们一般用 epoll()12345678910111213141516171819202122//1. 创建 epoll 句柄（返回文件描述符 epfd），size 是内核要监听的 fd 的个数int epoll_create(int size);//2. 监听事件类型int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);/* op: EPOLL_CTL_ADD 添加 EPOLL_CTL_MOD 修改 EPOLL_CTL_DEL 删除 event: EPOLLIN 可读 EPOLLOUT 可写 EPOLLPRI 紧急可读（有 socket 带外数据到来） EPOLLERR fd 发生错误 EPOLLHUP fd 被挂断 EPOLLET 设置为边缘触发（高速模式：如果 fd 从未就绪变为就绪，内核通过 epoll 告诉用户，一次就绪通知） EPOLLONESHOT 一次性监听（监听完后不再监听）*///3. 等待事件发生int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);events 输入maxevents 表示个数 &lt; epoll_create 创建时的 sizetimeout 超时时间 0 立即 -1 永久 设备驱动中的 poll() 模板见实例 实例等待队列1234567891011121314151617181920212223242526272829303132static ssize_t xxx_write(struct file *file, const char *buffer, size_t count, loff_t *ppos)&#123; ... DECLARE_WAITQUEUE(wait, current); /* 定义等待队列元素 */ add_wait_queue( &amp;xxx_wait , &amp;wait); /* 添加元素 wait 到等待队列 xxx_wait */ /* 等待设备缓冲区可写 */ do&#123; avail = device_writable(...); if( avail &lt; 0)&#123; if(file-&gt;f_flags &amp; O_NONBLOCK) //是非阻塞 &#123; ret = -EAGAIN; goto out; &#125; __set_current_state(TASK_INTERRUPTIBLE); /* 改变进程状态 */ schedule(); /* 调度其他进程执行 */ if(signal_pending(current)) /* 如果是因为信号唤醒*/ &#123; ret = -ERESTARTSYS; goto out; &#125; &#125; &#125; while( avail &lt; 0); /* 写设备缓冲区 */ device_write(...);out: remove_wait_queue(&amp;xxx_wait, &amp;wait); set_current_sate(TASK_RUNNING); return ret;&#125; 轮询1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;sys/select.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#define FIFO_CLEAR 0x1#define BUFFER_LEN 20void main(void)&#123; int fd, num; char rd_ch[BUFFER_LEN]; fd_set rfds, wfds; /* 读/写文件描述符集 */ /* 以非阻塞方式打开/dev/globalfifo设备文件 */ fd = open(&quot;/dev/globalfifo&quot;, O_RDONLY | O_NONBLOCK); if (fd != -1) &#123; /* FIFO清0 */ if (ioctl(fd, FIFO_CLEAR, 0) &lt; 0) printf(&quot;ioctl command failed\\n&quot;); while (1) &#123; FD_ZERO(&amp;rfds); //FD_ZERO 清除文件描述符合集 FD_ZERO(&amp;wfds); FD_SET(fd, &amp;rfds); //FD_SET 将 fd 加入合集中 FD_SET(fd, &amp;wfds); select(fd + 1, &amp;rfds, &amp;wfds, NULL, NULL); /* 数据可获得 */ if (FD_ISSET(fd, &amp;rfds)) printf(&quot;Poll monitor:can be read\\n&quot;); /* 数据可写入 */ if (FD_ISSET(fd, &amp;wfds)) printf(&quot;Poll monitor:can be written\\n&quot;); &#125; &#125; else &#123; printf(&quot;Device open failure\\n&quot;); &#125;&#125;","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"Linux 中的互斥机制（中断屏蔽、原子操作、自旋锁、信号量）","slug":"Linux/[Linux] 中的互斥机制（中断屏蔽、原子操作、自旋锁、信号量）","date":"2015-12-30T22:06:06.000Z","updated":"2018-11-08T01:49:49.141Z","comments":true,"path":"2015/12/31/Linux/[Linux] 中的互斥机制（中断屏蔽、原子操作、自旋锁、信号量）/","link":"","permalink":"http://iyounix.com/2015/12/31/Linux/[Linux] 中的互斥机制（中断屏蔽、原子操作、自旋锁、信号量）/","excerpt":"","text":"基本概念临界区对某段代码而言，可能会在程序中多次被执行，每次执行的过程我们称作代码的执行路径。当两个或多个代码路径要竞争共同的资源的时候，该代码段就是临界区。 互斥机制访问共享资源的代码叫做临界区。共享资源被多个线程需要，但共享资源又不能被同时访问。所以临界区需要以某种互斥机制来加以保护，确保共享资源被互斥访问。 用户空间和内核空间为了安全考虑，Linux系统分为内核态和用户态，分别运行在内核空间和用户空间。内核态的程序可以执行特权指令，操作系统本身也在其中运行；用户态则不允许直接访问操作系统的核心数据、设备等关键资源，必须先通过系统调用或者中断进入内核态才可以访问，当系统调用或中断返回时，重新回到用户空间运行。 Linux 的互斥机制四种方式：中断屏蔽、原子操作、自旋锁、信号量 内核空间互斥方式：中断屏蔽、原子操作、自旋锁用户空间互斥方式：信号量 中断屏蔽中断是一个完全异步的事件，它的发生与正在运行的进程没有任何关系，它没有进程上下文切换。CPU具备屏蔽中断和打开中断的功能，这项功能可以保证正在执行的内核执行路径不被中断处理程序抢占，防止竞态的产生。但是，内核的正常运行依赖于中断机制。在屏蔽中断期间，任何中断都无法得到处理，而必须等待屏蔽解除。因此长时间屏蔽中断对内核的运行起到很大的影响，其后果可能导致数据丢失，甚至系统崩溃。实际情况是：在中断服务全过程屏蔽中断会丢失中断；如果开中断，又容易引起互斥问题。为了解决这个问题，Linux 把中断分为顶半部TH（Top Half）和底半部BH（Bottom Half）。TH 屏蔽中断，执行一些少量的关键性动作；BH 可以开中断，允许中断延迟执行。 原子操作原子操作底层表现为一条汇编指令（ldrex、strex）。所以他们在执行过程中不会被别的代码路径所中断。Linux 内核提供了两类函数来实现内核中的原子操作，分别是整型原子操作和位原子操作。它们的共同点是所有的操作都是原子的，内核可以安全的调用它们而不被中断，而且它们都依赖底层CPU的原子操作实现，因此所有的这些函数都是与CPU架构相关的。 自旋锁自旋锁是为实现保护共享资源而提出一种锁机制。 自旋锁的原理：一个执行单元要想访问被自旋锁保护的共享资源，必须先得到锁，并且在任何时刻最多只能有一个执行单元获得锁；而在访问完共享资源后，必须释放锁。如果在获取自旋锁时，没有任何执行单元保持该锁，那么将立即得到锁；如果在获取自旋锁时锁已经有保持者，那么获取锁操作将一直循环在那里，直到该自旋锁的保持者释放了锁，”自旋”一词就是因此而得名。 事实上，自旋锁的初衷是：在短期间内进行轻量级的锁定。一个被争用的自旋锁使得请求它的线程在等待锁重新可用的期间进行自旋(特别浪费处理器时间)，所以自旋锁被持有的时间不应该过长。如果需要长时间锁定的话, 最好使用信号量。 信号量在用户空间只有进程的概念。当一个临界区有多个用户态进程竞争时，最好的方法是用信号量保护这个临界区。只有得到信号量进程才能执行临界区代码，当获取不到信号量时，进程进入休眠状态。 因此，我们可以说，信号量是进程级的互斥机制，它代表进程来争夺共享资源，如果竞争失败，就会发生进程上下文切换，当前进程进入睡眠状态，CPU运行其他进程。由于进程上下文切换的开销很大，因此，只有当进程占用资源时间较长时，用信号量才是最好的选择。 此外，信号量在SMP（对称多处理器）系统同样起作用。 浅显的比方浅显的来说，可以理解为大家在一套房子里合租，共用一个厕所。厕所就是共享资源，去上厕所的行为被称作代码路径。中断屏蔽就是，有一个人想要用厕所，但是呢他在上厕所前在门口贴上纸条说厕所坏了，如果他很快出来倒还不要紧，但是如果他要上很长时间，那一起住的其他人可能就要憋爆了。所以中断屏蔽最开始不会被用于处理需要耗时很长的操作。但是大家想，这样不是个解决办法啊，我有时候确实要拉很长时间怎么办呢。于是发明了顶半部TH和底半部BH，TH用于执行少量的关键性的动作，BH用于处理中断中耗时的部分。可以理解为，某人A特别特别想上厕所的时候，就进入TH（可以看作一个状态），此时A去应个急，拉一点点，让肚子不那么疼，此时A是不可以被打断的。如果没人用厕所他就直接慢条斯理的开始拉了（BH）。但是他这个BH状态是可以打断的，如果此时来个人B 非常非常急，B进入TH说，我受不了啦要憋死啦，A就会暂停自己的状态（保护现场）让B进来拉一会（TH），等B拉了一点点，让肚子不那么疼了就出去。此时 A继续（恢复现场）。等A 的BH部分完全结束后B再执行B的BH部分。原子操作很好理解，就是大家每次上厕所都用时非常短，短到什么程度呢，只要一条汇编指令的时间。当然拉的量也非常少（只改变一个整型或者是位）。所以就不存在抢厕所的问题了。自旋锁顾名思义，给这个厕所上把锁，只有拥有这个锁钥匙的人A才能进厕所。进去后把锁锁上，外面的人B急得团团转（自旋），出来后把锁释放，在门口等着的B拿了钥匙赶紧开了锁进去了。但是缺点就是，B在外面团团转，没有功夫去做别的事情，所以一旦 A 上厕所的时间很长，B就浪费了很长时间在自旋上。对系统的性能有所影响。信号量信号量就是，我们的房子有 N 个厕所，N 不为 1, 且 N 为有限个，上厕所的人是有限的。即共享这一块资源的进程是有限个数的。这时候我们就可以在厕所门口挂上 N 吧钥匙，拿到钥匙的就可以进去，钥匙架空了，其他进程就只能在门口等待出来的人还钥匙。 区别分析代码实现中断屏蔽123local_irq_disable() /local_irq_save(flags);// 访问临界区local_irq_enable() /local_irq_restore(flags); 原子操作位原子操作：set_bit/clear_bit/change_bit/test_bit整型原子操作：atomic_set/atomic_read/atomic_add/atomic_sub/atomic_inc/atomic_dec/步骤：1234//1. 分配整形原子变量 atomic_t v = ATOMIC_INIT(1);//2.操作原子变量 atomic_set/atomic_read/atomic_add/atomic_sub/atomic_inc加加/atomic_dec减减/... 实例：12static int open_cnt = 1;open_cnt++; //不具备原子性 方法一，中断屏蔽，不适用于多核1234unsigned long flags;local_irq_save(flags);open_cnt++;local_irq_restore(flags); 方法二，原子操作12static atomic_t open_cnt = ATOMIC_INIT(1);atomic_inc(&amp;open_cnt); //具有原子性 自旋锁1234567891011//1.分配自旋锁spinlock_t lock;//2.初始化自旋锁spin_lock_init(&amp;lock);//3.访问临界区之前获取锁：spin_lock(&amp;lock); //获取自旋锁，立即返回，如果没有获取锁，将进行忙等待 或者spin_trylock(&amp;lock); //获取锁，返回true,否则返回false,所以这个函数一定要对返回值进行判断！//4 .访问临界区//5.释放自旋锁 spin_unlock(&amp;lock); 衍生自旋锁1234567891011121314//1.分配自旋锁spinlock_t lock;//2.初始化自旋锁spin_lock_init(&amp;lock);//3.访问临界区前获取锁：unsigned long flags;spin_lock_irq(&amp;lock); // = spin_lock() + local_irq_disable()或者spin_lock_irqsave(&amp;lock, flags); // = spin_lock() local_irq_save()//4.访问临界区//5.释放自旋锁spin_unlock_irq(&amp;lock); // = spin_unlock()+ local_irq_enable()或者spin_unlock_irqrestore(&amp;lock, flags); // = spin_unlock() + local_irq_restore() 信号量12345678910111213141516171819//1.分配信号量对象 struct semaphore sema;//2.初始化为互斥信号量 init_MUTEX(&amp;sema);或者： DECLARE_MUTEX(sema);//3.访问临界区之前获取信号量 down(&amp;sema); //如果获取信号量，立即返回 //如果信号量不可用，进程将在此休眠，并且休眠的状态是 [ 不可中断的休眠状态 TASK_UNINTERRUPTIBLE] ！ 或者 down_interruptible(&amp;sema); //如果信号量不可用，进程将进入 [ 可中断的休眠状态 TASK_INTERRUPTIBLE ]，如果返回0表示正常获取信号，如果返回非0，表示接受到了信号 down_trylock(); //获取信号，如果信号量不可用，返回非0，如果信号量可用，返回0；不会引起休眠，可以在中断上下文使用。返回值也要做判断！//4.访问临界区：临界区可以休眠//5.释放信号量 up(&amp;sema); //不仅仅释放信号量，然后唤醒休眠的进程，让这个进程去获取信号量来访问临界区 参考文章：Linux 互斥机制：http://www.cnblogs.com/jan5/articles/3351186.html线程同步之详解自旋锁（windows平台）：http://www.cnblogs.com/cposture/p/SpinLock.html 可以参考读写自旋锁详解，第 1 部分：https://www.ibm.com/developerworks/cn/linux/l-cn-rwspinlock1/ 以自动机的观点阐述读写自旋锁的原理多种自旋锁形式之间的区别：http://www.360doc.com/content/11/0302/14/3038654_97459411.shtml","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"Linux DTS 架构下 Device 与 Driver 匹配流程","slug":"Linux/[Linux] DTS 架构下 Device 与 Driver 匹配流程","date":"2015-12-30T22:06:06.000Z","updated":"2018-11-08T01:55:36.385Z","comments":true,"path":"2015/12/31/Linux/[Linux] DTS 架构下 Device 与 Driver 匹配流程/","link":"","permalink":"http://iyounix.com/2015/12/31/Linux/[Linux] DTS 架构下 Device 与 Driver 匹配流程/","excerpt":"","text":"旧与新我们知道原来采用 板级文件 架构的时候，device 与 driver 匹配的方式是 调用 platform 的 match 函数。如果 板级结构体 borad_info 中的 name 与 driver 中的 name 相同（匹配），则调用 probe 函数。 但是现在引入了 DTS 架构。所以这个流程也有些变化，加上最近在调 spi 的 Sensor，刚编写完最小驱动模块却发现 probe 没有被调用，所以借此机会梳理一下 device 与 driver 的匹配流程。 分析初始化流程。（扫描 dts 生成的 dtb 文件，并展开成为 Device Tree Structure） platform的识别流程与分析 Device Tree Structure 是如何加入 linux kernel 的设备驱动模型的 初始化流程系统初始化流程可以参见 展讯平台启动流程（uboot） unflat我们知道 dtb 是 dts 与 dtsi 编译的二进制文件，在系统初始化的过程中，我们将 dtb 转化成 device_node 的树状结构，便于后续的方便操作：setup_ArchName -&gt; unflatten_device_treedrivers/of/fdt.c, line 11191234567891119 void __init unflatten_device_tree(void)1120 &#123;1121 __unflatten_device_tree(initial_boot_params, &amp;of_root,1122 early_init_dt_alloc_memory_arch);1123 1124 /* Get pointer to \"/chosen\" and \"/aliases\" nodes for use everywhere */1125 of_alias_scan(early_init_dt_alloc_memory_arch);1126 &#125;1127 我们利用 struct device_node 来抽象 设备树 中的一个节点：1234567891011121314151617struct device_node &#123; const char *name; //device node name const char *type; //对应device_type的属性 phandle phandle; //对应该节点的phandle属性 const char *full_name; //从“/”开始的，表示该node的full path struct property *properties; //该节点的属性列表 struct property *deadprops; //如果需要删除某些属性，kernel并非真的删除，而是挂入到deadprops的列表 struct device_node *parent; //parent、child以及sibling将所有的device node连接起来 struct device_node *child; struct device_node *sibling; struct device_node *next; //通过该指针可以获取相同类型的下一个node struct device_node *allnext; //通过该指针可以获取node global list下一个node struct proc_dir_entry *pde; //开放到userspace的proc接口信息 struct kref kref; //该node的reference count unsigned long _flags; void *data; &#125;; 如上 device_node 被组织成1.global list。全局变量struct device_node *of_allnodes就是指向设备树的global list2.tree。_ _unflatten_device_tree 的主要功能就是扫描 DTB。123456789101112131415161718192021static void __unflatten_device_tree(struct boot_param_header *blob;//需要扫描的DTB struct device_node **mynodes,//global list指针 void * (*dt_alloc)(u64 size, u64 align))//内存分配函数 &#123; unsigned long size; void *start, *mem; struct device_node **allnextp = mynodes; 此处删除了health check代码，例如检查DTB header的magic，确认blob的确指向一个DTB。 /* scan过程分成两轮，第一轮主要是确定device-tree structure的长度，保存在size变量中 */ start = ((void *)blob) + be32_to_cpu(blob-&gt;off_dt_struct); size = (unsigned long)unflatten_dt_node(blob, 0, &amp;start, NULL, NULL, 0); size = ALIGN(size, 4); /* 初始化的时候，并不是扫描到一个node或者property就分配相应的内存，实际上内核是一次性的分配了一大片内存，这些内存包括了所有的struct device_node、node name、struct property所需要的内存。*/ mem = dt_alloc(size + 4, __alignof__(struct device_node)); memset(mem, 0, size); *(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef); //用来检验后面unflattening是否溢出 /* 这是第二轮的scan，第一次scan是为了得到保存所有node和property所需要的内存size，第二次就是实打实的要构建device node tree了 */ start = ((void *)blob) + be32_to_cpu(blob-&gt;off_dt_struct); unflatten_dt_node(blob, mem, &amp;start, NULL, &amp;allnextp, 0); //... 此处略去校验溢出和校验OF_DT_END。 &#125; platform的识别流程与分析Device Tree 是如何完成运行时的参数传递和 platform 识别功能的? 汇编部分代码分析（关于参数传递）linux/arch/arm/kernel/head.S文件定义了bootloader和kernel的参数传递要求：1MMU = off, D-cache = off, I-cache = dont care, r0 = 0, r1 = machine nr, r2 = atags or dtb pointer. 目前的kernel支持旧的 tag list 的方式，同时也支持 device tree 的方式。r2可能是device tree binary file的指针（bootloader要传递给内核之前要copy到memory中），也可以能是tag list的指针。在ARM的汇编部分的启动代码中（主要是 head.S 和 head-common.S），machine type ID和指向DTB或者atags的指针被保存在变量machine_arch_type和atags_pointer中，这么做是为了后续c代码进行处理。 setup_ARCHarch/arm/kernel/setup.c#L10521234567891011void __init setup_arch(char **cmdline_p) &#123; const struct machine_desc *mdesc;…… mdesc = setup_machine_fdt(__atags_pointer); if (!mdesc) mdesc = setup_machine_tags(__atags_pointer, __machine_arch_type); machine_desc = mdesc; machine_name = mdesc-&gt;name;…… &#125; 对于如何确定HW platform这个问题。旧的方法是静态定义若干的machine描述符（struct machine_desc ），在启动过程中，通过machine type ID作为索引，在这些静态定义的machine描述符中扫描，找到那个ID匹配的描述符。在新的内核中，首先使用 setup_machine_fdt 来 setup machine描述符，如果返回 NULL，才使用传统的方法setup_machine_tags来setup machine描述符。传统的方法需要给出_._machine_arch_type（bootloader通过r1寄存器传递给kernel的）和tag list的地址（用来进行tag parse）。_._machine_arch_type用来寻找machine描述符；tag list用于运行时参数的传递。随着内核的不断发展，相信有一天linux kernel会完全抛弃tag list的机制。 匹配 platform（machine 描述符）setup_machine_fdt 函数的功能就是根据Device Tree的信息，找到最适合的machine描述符。12345678910111213const struct machine_desc * __init setup_machine_fdt(unsigned int dt_phys) &#123; const struct machine_desc *mdesc, *mdesc_best = NULL; if (!dt_phys || !early_init_dt_scan(phys_to_virt(dt_phys))) return NULL; mdesc = of_flat_dt_match_machine(mdesc_best, arch_get_next_mach); if (!mdesc) &#123; 出错处理 &#125; /* Change machine number to match the mdesc we're using */ __machine_arch_type = mdesc-&gt;nr; return mdesc; &#125; early_init_dt_scan 函数有两个功能，一个是为后续的DTB scan进行准备工作，另外一个是运行时参数传递。具体请参考下面一个section的描述。of_flat_dt_match_machine是在machine描述符的列表中scan，找到最合适的那个machine描述符。我们首先看如何组成machine描述符的列表。和传统的方法类似，也是静态定义的。DT_MACHINE_START和MACHINE_END用来定义一个machine描述符。编译的时候，compiler会把这些machine descriptor放到一个特殊的段中（.arch.info.init），形成machine描述符的列表。machine描述符用下面的数据结构来标识（删除了不相关的member）：12345struct machine_desc &#123; unsigned int nr; /* architecture number */ const char *const *dt_compat; /* array of device tree 'compatible' strings */…… &#125;; nr成员就是过去使用的machine type ID。内核machine描述符的table有若干个entry，每个都有自己的ID。bootloader传递了machine type ID，指明使用哪一个machine描述符。目前匹配machine描述符使用compatible strings，也就是dt_compat成员，这是一个string list，定义了这个machine所支持的列表。在扫描machine描述符列表的时候需要不断的获取下一个machine描述符的compatible字符串的信息，具体的代码如下：12345678910static const void * __init arch_get_next_mach(const char *const **match) &#123; static const struct machine_desc *mdesc = __arch_info_begin; const struct machine_desc *m = mdesc; if (m &gt;= __arch_info_end) return NULL; mdesc++; *match = m-&gt;dt_compat; return m; &#125; _._arch_info_begin指向machine描述符列表第一个entry。通过mdesc++不断的移动machine描述符指针（Note：mdesc是static的）。match返回了该machine描述符的compatible string list。具体匹配的算法倒是很简单，就是比较字符串而已，一个是root node的compatible字符串列表，一个是machine描述符的compatible字符串列表，得分最低的（最匹配的）就是我们最终选定的machine type。 运行时传递参数运行时参数是在扫描DTB的chosen node时候完成的，具体的动作就是获取chosen node的bootargs、initrd等属性的value，并将其保存在全局变量（boot_command_line，initrd_start、initrd_end）中。使用tag list方法是类似的，通过分析tag list，获取相关信息，保存在同样的全局变量中。具体代码位于early_init_dt_scan函数中：12345678910111213141516171819bool __init early_init_dt_scan(void *params) &#123; if (!params) return false; /* 全局变量initial_boot_params指向了DTB的header*/ initial_boot_params = params; /* 检查DTB的magic，确认是一个有效的DTB */ if (be32_to_cpu(initial_boot_params-&gt;magic) != OF_DT_HEADER) &#123; initial_boot_params = NULL; return false; &#125; /* 扫描 /chosen node，保存运行时参数（bootargs）到boot_command_line，此外，还处理initrd相关的property，并保存在initrd_start和initrd_end这两个全局变量中 */ of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line); /* 扫描根节点，获取 &#123;size,address&#125;-cells信息，并保存在dt_root_size_cells和dt_root_addr_cells全局变量中 */ of_scan_flat_dt(early_init_dt_scan_root, NULL); /* 扫描DTB中的memory node，并把相关信息保存在meminfo中，全局变量meminfo保存了系统内存相关的信息。*/ of_scan_flat_dt(early_init_dt_scan_memory, NULL); return true; &#125; 设定meminfo（该全局变量确定了物理内存的布局）有若干种途径：1、通过tag list（tag是ATAG_MEM）传递memory bank的信息。2、通过command line（可以用tag list，也可以通过DTB）传递memory bank的信息。3、通过DTB的memory node传递memory bank的信息。目前当然是推荐使用Device Tree的方式来传递物理内存布局信息。 Device Tree Structure 是如何加入 linux kernel 的设备驱动模型的在linux kernel引入统一设备模型之后，bus、driver和device形成了设备模型中的铁三角。在驱动初始化的时候会将代表该driver的一个数据结构（一般是xxx_driver）挂入bus上的driver链表。device挂入链表分成两种情况，一种是即插即用类型的bus，在插入一个设备后，总线可以检测到这个行为并动态分配一个device数据结构（一般是xxx_device，例如usb_device），之后，将该数据结构挂入bus上的device链表。bus上挂满了driver和device，那么如何让device遇到“对”的那个driver呢？那么就要靠缘分了，也就是bus的match函数。上面是一段导论，我们还是回到Device Tree。导致Device Tree的引入ARM体系结构的代码其中一个最重要的原因的太多的静态定义的表格。例如：一般代码中会定义一个static struct platform_device *xxx_devices的静态数组，在初始化的时候调用platform_add_devices。这些静态定义的platform_device往往又需要静态定义各种resource，这导致静态表格进一步增大。如果ARM linux中不再定义这些表格，那么一定需要一个转换的过程，也就是说，系统应该会根据Device tree来动态的增加系统中的platform_device。当然，这个过程并非只是发生在platform bus上（具体可以参考“Platform Device”的设备），也可能发生在其他的非即插即用的bus上，例如AMBA总线、PCI总线。一言以蔽之，如果要并入linux kernel的设备驱动模型，那么就需要根据device_node的树状结构（root是of_allnodes）将一个个的device node挂入到相应的总线device链表中。只要做到这一点，总线机制就会安排device和driver的约会。当然，也不是所有的device node都会挂入bus上的设备链表，比如cpus node，memory node，choose node等。 1、cpus node的处理这部分的处理可以参考setup_arch-&gt;arm_dt_init_cpu_maps中的代码，具体的代码如下：123456789101112131415161718192021222324252627282930313233343536void __init arm_dt_init_cpu_maps(void) &#123; scan device node global list，寻找full path是“/cpus”的那个device node。cpus这个device node只是一个容器，其中包括了各个cpu node的定义以及所有cpu node共享的property。 cpus = of_find_node_by_path(\"/cpus\"); for_each_child_of_node(cpus, cpu) &#123; 遍历cpus的所有的child node u32 hwid; if (of_node_cmp(cpu-&gt;type, \"cpu\")) 我们只关心那些device_type是cpu的node continue; if (of_property_read_u32(cpu, \"reg\", &amp;hwid)) &#123; 读取reg属性的值并赋值给hwid return; &#125; reg的属性值的8 MSBs必须设置为0，这是ARM CPU binding定义的。 if (hwid &amp; ~MPIDR_HWID_BITMASK) return; 不允许重复的CPU id，那是一个灾难性的设定 for (j = 0; j &lt; cpuidx; j++) if (WARN(tmp_map[j] == hwid, \"Duplicate /cpu reg \" \"properties in the DT\\n\")) return;数组tmp_map保存了系统中所有CPU的MPIDR值（CPU ID值），具体的index的编码规则是： tmp_map[0]保存了booting CPU的id值，其余的CPU的ID值保存在1～NR_CPUS的位置。 if (hwid == mpidr) &#123; i = 0; bootcpu_valid = true; &#125; else &#123; i = cpuidx++; &#125; tmp_map[i] = hwid; &#125;根据DTB中的信息设定cpu logical map数组。 for (i = 0; i &lt; cpuidx; i++) &#123; set_cpu_possible(i, true); cpu_logical_map(i) = tmp_map[i]; &#125; &#125; 要理解这部分的内容，需要理解ARM CUPs binding的概念，可以参考linux/Documentation/devicetree/bindings/arm目录下的CPU.txt文件的描述。2、memory的处理这部分的处理可以参考setup_arch-&gt;setup_machine_fdt-&gt;early_init_dt_scan-&gt;early_init_dt_scan_memory中的代码。具体如下：12345678910111213141516171819202122232425262728int __init early_init_dt_scan_memory(unsigned long node, const char *uname, int depth, void *data) &#123; char *type = of_get_flat_dt_prop(node, \"device_type\", NULL); 获取device_type属性值 __be32 *reg, *endp; unsigned long l; 在初始化的时候，我们会对每一个device node都要调用该call back函数，因此，我们要过滤掉那些和memory block定义无关的node。和memory block定义有的节点有两种，一种是node name是memory@形态的，另外一种是node中定义了device_type属性并且其值是memory。 if (type == NULL) &#123; if (depth != 1 || strcmp(uname, \"memory@0\") != 0) return 0; &#125; else if (strcmp(type, \"memory\") != 0) return 0; 获取memory的起始地址和length的信息。有两种属性和该信息有关，一个是linux,usable-memory，不过最新的方式还是使用reg属性。reg = of_get_flat_dt_prop(node, \"linux,usable-memory\", &amp;l); if (reg == NULL) reg = of_get_flat_dt_prop(node, \"reg\", &amp;l); if (reg == NULL) return 0; endp = reg + (l / sizeof(__be32));reg属性的值是address，size数组，那么如何来取出一个个的address/size呢？由于memory node一定是root node的child，因此dt_root_addr_cells（root node的#address-cells属性值）和dt_root_size_cells（root node的#size-cells属性值）之和就是address，size数组的entry size。 while ((endp - reg) &gt;= (dt_root_addr_cells + dt_root_size_cells)) &#123; u64 base, size; base = dt_mem_next_cell(dt_root_addr_cells, ®); size = dt_mem_next_cell(dt_root_size_cells, ®); early_init_dt_add_memory_arch(base, size); 将具体的memory block信息加入到内核中。 &#125; return 0; &#125; 3、interrupt controller的处理初始化是通过start_kernel-&gt;init_IRQ-&gt;machine_desc-&gt;init_irq()实现的。我们用S3C2416为例来描述interrupt controller的处理过程。下面是machine描述符的定义。12345DT_MACHINE_START(S3C2416_DT, \"Samsung S3C2416 (Flattened Device Tree)\") …… .init_irq = irqchip_init, …… MACHINE_END 在driver/irqchip/irq-s3c24xx.c文件中定义了两个interrupt controller，如下：12IRQCHIP_DECLARE(s3c2416_irq, \"samsung,s3c2416-irq\", s3c2416_init_intc_of);IRQCHIP_DECLARE(s3c2410_irq, \"samsung,s3c2410-irq\", s3c2410_init_intc_of); 当然，系统中可以定义更多的irqchip，不过具体用哪一个是根据DTB中的interrupt controller node中的compatible属性确定的。在driver/irqchip/irqchip.c文件中定义了irqchip_init函数，如下：1234void __init irqchip_init(void) &#123; of_irq_init(__irqchip_begin); &#125; _._irqchip_begin就是所有的irqchip的一个列表，of_irq_init函数是遍历Device Tree，找到匹配的irqchip。具体的代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071void __init of_irq_init(const struct of_device_id *matches) &#123; struct device_node *np, *parent = NULL; struct intc_desc *desc, *temp_desc; struct list_head intc_desc_list, intc_parent_list; INIT_LIST_HEAD(&amp;intc_desc_list); INIT_LIST_HEAD(&amp;intc_parent_list); 遍历所有的node，寻找定义了interrupt-controller属性的node，如果定义了interrupt-controller属性则说明该node就是一个中断控制器。 for_each_matching_node(np, matches) &#123; if (!of_find_property(np, \"interrupt-controller\", NULL) || !of_device_is_available(np)) continue; 分配内存并挂入链表，当然还有根据interrupt-parent建立controller之间的父子关系。对于interrupt controller，它也可能是一个树状的结构。 desc = kzalloc(sizeof(*desc), GFP_KERNEL); if (WARN_ON(!desc)) goto err; desc-&gt;dev = np; desc-&gt;interrupt_parent = of_irq_find_parent(np); if (desc-&gt;interrupt_parent == np) desc-&gt;interrupt_parent = NULL; list_add_tail(&amp;desc-&gt;list, &amp;intc_desc_list); &#125; 正因为interrupt controller被组织成树状的结构，因此初始化的顺序就需要控制，应该从根节点开始，依次递进到下一个level的interrupt controller。 while (!list_empty(&amp;intc_desc_list)) &#123; intc_desc_list链表中的节点会被一个个的处理，每处理完一个节点就会将该节点删除，当所有的节点被删除，整个处理过程也就是结束了。 list_for_each_entry_safe(desc, temp_desc, &amp;intc_desc_list, list) &#123; const struct of_device_id *match; int ret; of_irq_init_cb_t irq_init_cb; 最开始的时候parent变量是NULL，确保第一个被处理的是root interrupt controller。在处理完root node之后，parent变量被设定为root interrupt controller，因此，第二个循环中处理的是所有parent是root interrupt controller的child interrupt controller。也就是level 1（如果root是level 0的话）的节点。 if (desc-&gt;interrupt_parent != parent) continue; list_del(&amp;desc-&gt;list); －－－－－从链表中删除 match = of_match_node(matches, desc-&gt;dev);－－－－－匹配并初始化 if (WARN(!match-&gt;data,－－－－－－－－－－match-&gt;data是初始化函数 \"of_irq_init: no init function for %s\\n\", match-&gt;compatible)) &#123; kfree(desc); continue; &#125; irq_init_cb = (of_irq_init_cb_t)match-&gt;data; ret = irq_init_cb(desc-&gt;dev, desc-&gt;interrupt_parent);－－－－－执行初始化函数 if (ret) &#123; kfree(desc); continue; &#125; 处理完的节点放入intc_parent_list链表，后面会用到 list_add_tail(&amp;desc-&gt;list, &amp;intc_parent_list); &#125; 对于level 0，只有一个root interrupt controller，对于level 1，可能有若干个interrupt controller，因此要遍历这些parent interrupt controller，以便处理下一个level的child node。 desc = list_first_entry_or_null(&amp;intc_parent_list, typeof(*desc), list); if (!desc) &#123; pr_err(\"of_irq_init: children remain, but no parents\\n\"); break; &#125; list_del(&amp;desc-&gt;list); parent = desc-&gt;dev; kfree(desc); &#125; list_for_each_entry_safe(desc, temp_desc, &amp;intc_parent_list, list) &#123; list_del(&amp;desc-&gt;list); kfree(desc); &#125; err: list_for_each_entry_safe(desc, temp_desc, &amp;intc_desc_list, list) &#123; list_del(&amp;desc-&gt;list); kfree(desc); &#125; &#125; 只有该node中有interrupt-controller这个属性定义，那么linux kernel就会分配一个interrupt controller的描述符（struct intc_desc）并挂入队列。通过interrupt-parent属性，可以确定各个interrupt controller的层次关系。在scan了所有的Device Tree中的interrupt controller的定义之后，系统开始匹配过程。一旦匹配到了interrupt chip列表中的项次后，就会调用相应的初始化函数。如果CPU是S3C2416的话，匹配到的是irqchip的初始化函数是s3c2416_init_intc_of。OK，我们已经通过compatible属性找到了适合的interrupt controller，那么如何解析reg属性呢？我们知道，对于s3c2416的interrupt controller而言，其#interrupt-cells的属性值是4，定义为。每个域的解释如下：（1）ctrl_num表示使用哪一种类型的interrupt controller，其值的解释如下： - 0 ... main controller - 1 ... sub controller - 2 ... second main controller （2）parent_irq。对于sub controller，parent_irq标识了其在main controller的bit position。（3）ctrl_irq标识了在controller中的bit位置。（4）type标识了该中断的trigger type，例如：上升沿触发还是电平触发。为了更顺畅的描述后续的代码，我需要简单的介绍2416的中断控制器，其block diagram如下：53个Samsung2416的中断源被分成两种类型，一种是需要sub寄存器进行控制的，例如DMA，系统中的8个DMA中断是通过两级识别的，先在SRCPND寄存器中得到是DMA中断的信息，具体是哪一个channel的DMA中断需要继续查询SUBSRC寄存器。那些不需要sub寄存器进行控制的，例如timer，5个timer的中断可以直接从SRCPND中得到。中断MASK寄存器可以控制产生的中断是否要报告给CPU，当一个中断被mask的时候，虽然SRCPND寄存器中，硬件会set该bit，但是不会影响到INTPND寄存器，从而不会向CPU报告该中断。对于SUBMASK寄存器，如果该bit被set，也就是该sub中断被mask了，那么即便产生了对应的sub中断，也不会修改SRCPND寄存器的内容，只是修改SUBSRCPND中寄存器的内容。不过随着硬件的演化，更多的HW block加入到SOC中，这使得中断源不够用了，因此中断寄存器又被分成两个group，一个是group 1（开始地址是0X4A000000，也就是main controller了），另外一个是group2（开始地址是0X4A000040，叫做second main controller）。group 1中的sub寄存器的起始地址是0X4A000018（也就是sub controller）。了解了上面的内容后，下面的定义就比较好理解了： 12345678910111213static struct s3c24xx_irq_of_ctrl s3c2416_ctrl[] = &#123; &#123; .name = \"intc\", －－－－－－－－－－－main controller .offset = 0, &#125;, &#123; .name = \"subintc\", －－－－－－－－－sub controller .offset = 0x18, .parent = &amp;s3c_intc[0], &#125;, &#123; .name = \"intc2\", －－－－－－－－－－second main controller .offset = 0x40, &#125; &#125;; 对于s3c2416而言，irqchip的初始化函数是s3c2416_init_intc_of，s3c2416_ctrl作为参数传递给了s3c_init_intc_of，大部分的处理都是在s3c_init_intc_of函数中完成的，由于这个函数和中断子系统非常相关，这里就不详述了，后续会有一份专门的文档描述之。4、GPIO controller的处理暂不描述，后续会有一份专门的文档描述GPIO sub system。5、machine初始化machine初始化的代码可以沿着start_kernel-&gt;rest_init-&gt;kernel_init-&gt;kernel_init_freeable-&gt;do_basic_setup-&gt;do_initcalls路径寻找。在do_initcalls函数中，kernel会依次执行各个initcall函数，在这个过程中，会调用customize_machine，具体如下：1234567891011static int __init customize_machine(void) &#123; if (machine_desc-&gt;init_machine) machine_desc-&gt;init_machine(); else of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL); return 0; &#125; arch_initcall(customize_machine); 在这个函数中，一般会调用machine描述符中的init_machine callback函数来把各种Device Tree中定义的platform device设备节点加入到系统（即platform bus的所有的子节点，对于device tree中其他的设备节点，需要在各自bus controller初始化的时候自行处理）。如果machine描述符中没有定义init_machine函数，那么直接调用of_platform_populate把所有的platform device加入到kernel中。对于s3c2416，其machine描述符中的init_machine callback函数就是s3c2416_dt_machine_init，代码如下：123456static void __init s3c2416_dt_machine_init(void) &#123; of_platform_populate(NULL, --------传入NULL参数表示从root node开始scanof_default_bus_match_table, s3c2416_auxdata_lookup, NULL); s3c_pm_init(); －－－－－－－－power management相关的初始化 &#125; 由此可见，最终生成platform device的代码来自of_platform_populate函数。该函数的逻辑比较简单，遍历device node global list中所有的node，并调用of_platform_bus_create处理，of_platform_bus_create函数代码如下：12345678910111213141516171819202122232425262728293031323334353637static int of_platform_bus_create(struct device_node *bus,-------------要创建的那个device node const struct of_device_id *matches,-------要匹配的list const struct of_dev_auxdata *lookup,------附属数据 struct device *parent, bool strict)---------------parent指向父节点。strict是否要求完全匹配 &#123; const struct of_dev_auxdata *auxdata; struct device_node *child; struct platform_device *dev; const char *bus_id = NULL; void *platform_data = NULL; int rc = 0;删除确保device node有compatible属性的代码。 auxdata = of_dev_lookup(lookup, bus); 在传入的lookup table寻找和该device node匹配的附加数据 if (auxdata) &#123; bus_id = auxdata-&gt;name;-----------------如果找到，那么就用附加数据中的静态定义的内容 platform_data = auxdata-&gt;platform_data; &#125;ARM公司提供了CPU core，除此之外，它设计了AMBA的总线来连接SOC内的各个block。符合这个总线标准的SOC上的外设叫做ARM Primecell Peripherals。如果一个device node的compatible属性值是arm,primecell的话，可以调用of_amba_device_create来向amba总线上增加一个amba device。 if (of_device_is_compatible(bus, \"arm,primecell\")) &#123; of_amba_device_create(bus, bus_id, platform_data, parent); return 0; &#125; 如果不是ARM Primecell Peripherals，那么我们就需要向platform bus上增加一个platform device了 dev = of_platform_device_create_pdata(bus, bus_id, platform_data, parent); if (!dev || !of_match_node(matches, bus)) return 0; 一个device node可能是一个桥设备，因此要重复调用of_platform_bus_create来把所有的device node处理掉。 for_each_child_of_node(bus, child) &#123; pr_debug(\" create child: %s\\n\", child-&gt;full_name); rc = of_platform_bus_create(child, matches, lookup, &amp;dev-&gt;dev, strict); if (rc) &#123; of_node_put(child); break; &#125; &#125; return rc; &#125; 具体增加platform device的代码在of_platform_device_create_pdata中，代码如下：12345678910111213141516171819202122232425static struct platform_device *of_platform_device_create_pdata( struct device_node *np, const char *bus_id, void *platform_data, struct device *parent) &#123; struct platform_device *dev; if (!of_device_is_available(np))---------check status属性，确保是enable或者OK的。 return NULL; of_device_alloc除了分配struct platform_device的内存，还分配了该platform device需要的resource的内存（参考struct platform_device 中的resource成员）。当然，这就需要解析该device node的interrupt资源以及memory address资源。 dev = of_device_alloc(np, bus_id, parent); if (!dev) return NULL;设定platform_device 中的其他成员 dev-&gt;dev.coherent_dma_mask = DMA_BIT_MASK(32); if (!dev-&gt;dev.dma_mask) dev-&gt;dev.dma_mask = &amp;dev-&gt;dev.coherent_dma_mask; dev-&gt;dev.bus = &amp;platform_bus_type; dev-&gt;dev.platform_data = platform_data; if (of_device_add(dev) != 0) &#123;------------------把这个platform device加入统一设备模型系统中 platform_device_put(dev); return NULL; &#125; return dev; &#125;","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"Linux 中的 SPI 设备驱动模型（SPI 协议基础）","slug":"Linux/[Linux] 下的 SPI 设备驱动模型（SPI 协议基础）","date":"2015-12-30T22:06:06.000Z","updated":"2018-11-08T01:50:19.837Z","comments":true,"path":"2015/12/31/Linux/[Linux] 下的 SPI 设备驱动模型（SPI 协议基础）/","link":"","permalink":"http://iyounix.com/2015/12/31/Linux/[Linux] 下的 SPI 设备驱动模型（SPI 协议基础）/","excerpt":"","text":"SPI 总线概念及特点概念SPI（Serial Peripheral Interface）穿行外围设备接口，全双工三线同步串行通信接口。在点对点的通信中，SPI 不需要进行寻址操作。当有多个从设备时，可以增加一条设备选择线（低电平有效的 CS）。 特点 单主多从 时钟由 Master 控制，在时钟移位脉冲下，数据按位传输，高位在前，低位在后（MSB first）。 全双工（可以同时发出和接收串行数据），速率达 12Mbps 提供频率可编程时钟; 发送结束 中断标志 ; 写冲突保护 ; 总线竞争保护缺点是 无法校验 总线结构 GPIO 模拟如果用 GPIO 模拟 SPI 总线，需要一个输出口（SDO）、一个输入口（SDI）。如果实现主从设备，需要 SDO 和 SDI; 如果只实现主设备，需要实现 SDO; 如果只实现从设备，需要实现 SDI。 接口定义标准 SPI 有 4 根线（片选 CS、时钟 SCLK、输出 MOSI、输入 MISO）MOSI – 主器件数据输出,从器件数据输入MISO – 主器件数据输入,从器件数据输出SCLK – 时钟信号,由主器件 Master 产生/CS – 从器件使能信号,由主器件控制 内部逻辑结构Master 和 Slave 内部分别有两个 8bit 移位寄存器。 其实这就相当于一个 环形的总线结构。在 SCLK 的控制下，两个 8bit shift register 进行数据交换。example：主机 buffer = 0xAA，从机 buffer = 0x55，假设上升沿发送数据（SPI 有四种发送数据的模式，下一节再讲解）如上图，完成了两个8bit寄存器的数据交换。 工作模式有四种工作模式。由 时钟极性和时钟相位 （CPOL &amp; CPHA） 决定。CPOL = Clock Polarity CPHA =Clock Phase CPOL 设置时钟空闲时的电平CPOL = 0 :串行同步时钟的空闲状态为低电平CPOL =1 :串行同步时钟的空闲状态为高电平 CPHA 设置读取数据和发送数据的时钟沿CPHA =0 :串行同步时钟第一个跳变沿(上升或下降)数据采样CPHA =1 :串行同步时钟第二个跳变沿(上升或下降)数据采样 第一个跳变沿进行采样：第二个跳变沿进行采样： 最后：分析 SPI 的四种传输协议可以发现，根据一种协议，只要对串行同步时钟进行转换，就能得到其余的三种协议。为了简化设计规定，如果要连续传输多个数据，在两个数据传输之间插入一个串行时钟的空闲等待，这样状态机只需两种状态（空闲和工作）就能正确工作。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"英雄如你，少年如我，不负这移动盛世","slug":"Life/InnerPath/15-10-26英雄如你少年如我不负这移动盛世","date":"2015-10-26T14:00:00.000Z","updated":"2018-11-08T01:30:40.291Z","comments":true,"path":"2015/10/26/Life/InnerPath/15-10-26英雄如你少年如我不负这移动盛世/","link":"","permalink":"http://iyounix.com/2015/10/26/Life/InnerPath/15-10-26英雄如你少年如我不负这移动盛世/","excerpt":"","text":"周五在Lanny姐的号召下和Jeremy与星星哥一同参加了”第四届全球安卓开发者大会”，感触良多，利用周末，细细整理，逐一道来。 一、互联网金融与投资在最开始是新浪网副总裁邓庆旭所做的一个推广，推广他们的一款理财产品，大致是讲的运用大数据的思路来分析舆论走向确定投资方向，大会的最后是高层论坛，IDG的副总裁与锐波创始人孙宇晨等人聊互联网金融与传统金融的区别。想将这两块放在一起，先谈谈对互联网金融这方面的理解与感触。首先感慨一下大数据的威力，大数据与云是几年前就炒得很火的两个字眼了。虽然颇知其威力，但是却没有想到当他被运用到投资这一块的时候效果如此震撼。新浪利用它的子业务，新浪微博新浪财经等作为资源，实现了一套分析舆论走向的系统。利用这套系统的算法计算出了舆论的走向，最后的效果是可以帮助投资师更有效的来进行投资。而且邓给出了一个数据是它们所分析的这个舆论走向与相对应股市的震荡曲线相似度极其之高。新浪将所有复杂的资讯解读、图形解读、数据解读全部用可视化的方式凝结在了几款APP上。结合后来所讲的互联网金融与传统金融的区别，不得不感慨投资越来越容易了。想起昨天（24日）央行降息的举措，房价不断高涨的现状，似乎可以推断出以后房价稳定甚至下跌的必然性。稍微梳理一下逻辑链条。中国人现在有钱人中越来越人的理财投资意识逐渐升高，但是意识提高知识却仍然有所局限，所以导致了很多手持大笔资金的人来购房囤地。但是随着人们投资意识和知识贮备的提升，大家会趋于尝试与采用更多其他的投资方式，另外央行的不断降息也会刺激大家把钱从银行拿出来进行各种投资方式的尝试。加上老龄化社会现象的加剧（对房产的需求量减少），我大胆的推测在央行年利率降到和国外一样接近于零的时候，房价应该会趋于稳定波动（一线城市）。二三线城市可能会下降。就如同今天的日本一样。 二、电商转型目标：社群商业京东副总裁路骋分享了这个话题。现在的PC互联网（传统互联网）中，像京东、阿里。唯品会这些，不管是自采模式、平台模式或是特卖的方式都是中心化流量分配，是电子商务的1.0形态，而2.0 是基于移动端的去中心化的模式。他提到的一个很有意思的概念让我印象很深。“羊毛出在猪身上，狗来买单”。因为我们知道传统的工业逻辑证明了为了减少生产成本最好标准化、单一化，通过规模化的生产来实现边际成本的降低。但是我们突然又发现，典型如小米的企业做着手机做着做着突然又开始做空气净化器，又做智能家居。而且因为有手机拉拢聚合的一批用户粘性很高的消费者，所以一卖就断货。这是就是羊毛出在猪身上，先用羊毛将大家吸引过来，然后通过范围经济在用户身上进行作用。在商业逻辑方面，原来是抢占入口，现在是抢占时间。消费行为方面，原来企业价值都是单向传递，我的企业价值有明确的定位，让你来接受我，认可我。但是现在更多的是双向的或者倾向于用户主导的，如小米的参与感，用户参与产品迭代中来。而社群经济就是这样，基于此和一群有共同兴趣、认知、价值观的用户抱成团，发生群蜂效应，在一起互动、交流、协作、感染，对产品品牌本身产生反哺的价值关系，这种建立在产品与粉丝群体之间的情感信任和价值反哺，共同作用形成自运转、自循环的范围经济系统就是社群经济。类似逻辑思维和微博上万能的大熊组织的社团。他们塑造自己的形象，卖产品都是很快售罄，现在有很多人都在向这个方向转型。从原来的内容+广告，到现在的内容+用户+关系。路骋提到各大互联网公司别用什么连接人，他说有人讲 百度 是用信息链连接人，天猫 或者 淘宝 阿里 是用商铺连接人，京东 是用货连接人，小米 是用设备在连接人，腾讯 是在用人在连接人。得人（用户）着得天下。 三、VR/裸眼3D带来的变革与机会四、无人机/飞行器的普及化五、90后是一种价值观这个很想着重谈一下，从这个话题到演讲者到演讲内容，我都觉得很有意思。 先明确目的，因为现在大部分互联网移动的受众就是90后95后，所以开发移动互联网产品不得不考虑90后的特质。孙宇晨的结论结论就是“90后是一种价值观”，展开为“自由，颠覆，个性化”。在开发APP的时候我们需要思考是否将这些 特质考虑进来。 自由上一辈的生存方式是什么？是学习。上一代人的生存技能，到了90后，完全不一样了，移动互联网的产生，让我们不用学习上一代人的想法，弯道超车，上一辈的人甚至不知道我们是在干什么。 颠覆90后在媒体的表达中不是颠覆别人就是被人颠覆，但其实颠覆的这个词并没有褒贬之分，孙宇晨的理解是颠覆就是迭代。一个健康的生态本来就是颠覆和反颠覆。就像最近被媒体渲染的非常恐怖的的资本寒冬即将到来，大部分投资即将失败等。这些媒体忽略了一个重要的因素就是，在移动互联网时代，失败是非常频繁的，而取得成功的一个方式就是，加快失败的频率，降低失败的成本，增大失败的次数。 个性化最典型的例子就是90后没有一个明星，类似张学友、周杰伦这种，90后都是一群，像EXO、TF。他们与企业的关系，叫做必须互相欣赏、三观统一、灵魂契合，这就是90后和企 业、品牌、APP之间的关系，它不是以前工业化流程和思考的方式。必须在精神与价值观层面赢得90后，90后喜欢创造与享受前人不曾发现、不知道的东西，不会停留在改进生活的基础 上，所以90后是自己创造一个东西自己玩。总结而言就是，90后是精神共创、荣辱与共、共同成长，这是移动互联网做一个APP的指导思想和 90后互动的方式，最后真正把这些用户变成你的粉丝或者教徒，这个APP就成功了。如果APP这个商业模式没有做好，你再做一个新的他们还会过来跟你玩。 只要做到这一个你就是成功的。孙宇晨所讲的内容中的失败与成功的关系确实让我眼前一亮，然而细思确实是这样，经历很多的小失败后很可能就是一个大的成功，同样积累很多小成功后也许就是一个大的失败。加速失败的频率，降低失败的成本，增加失败的次数确实缩短了走向成功的时间。类比到开发产品而言可以翻译成快速试错、小版本迭代，加快开发的时间，多去发布小的版本升级，勇于试错，如果你这次产品很糟糕，90后可能会骂你，但是他们不会忽略你，一个产品（或者是企业）最大的失败就是被忽略，如果你成功了，他们仍然会喜欢这款产品，而不会有多少人将你曾经失败的产品耿耿于心。 其实还有很多说的，不过限于周末有限的时间暂时不表，恰好也可以等一些脑海中的一些想法好好地沉淀一下。参加这次大会就好像是孩童第一次进玩具店，一切的观点就好像各种琳琅满目的玩具，每个都想摸一下，揣怀里带走。越来越喜欢深圳这个地方，总是不乏有这种大牛们将思维苹果抛出的活动，也多谢了Lanny姐带我们出来捡苹果。总而言之，山底的风景就已让人叹为观止，哪能让人不想攀到山巅去览一览众山之貌！","categories":[],"tags":[{"name":"InnerPath","slug":"InnerPath","permalink":"http://iyounix.com/tags/InnerPath/"}]},{"title":"巴迪闲侃","slug":"Life/InnerPath/15-09-20巴迪闲侃","date":"2015-09-20T14:00:00.000Z","updated":"2018-11-08T01:30:40.291Z","comments":true,"path":"2015/09/20/Life/InnerPath/15-09-20巴迪闲侃/","link":"","permalink":"http://iyounix.com/2015/09/20/Life/InnerPath/15-09-20巴迪闲侃/","excerpt":"","text":"昨天是傻V呀的生日，和小伙伴们欢快的玩耍了一天。抱着high了一天后必须要好好学习的念头背好书包来公司蹭蹭空调。恰好碰到Buddy哥在给傻V做一些心路面包，于是偷偷的凑了过去学着揉了几坨面。感触有一些，不明白的地方有两些。也许最后自己理解的配方和Buddy传授的已然不同，但还是决定趁着自己的热面包新鲜出炉的时候拍两张照片。姑俟异日观。 1.交配交的人，做爱做的事Buddy哥在讲关于交友和职业选择的时候我偷偷的插入了他和傻V的闲侃。题目为这一部分的中心思想。他俩都蛮相信缘分和风水这个的，Buddy哥祭出了他的soulmate，实在好生羡慕。听的时候脑海中闪过了许多人，我的感触就是，其实，我们每个人就好像是不同形状的积木，我们在人生的不同阶段会遇到很多不同的积木，有的十分的契合，那么很幸运，我们现在是无话不谈互相very easy to catch point的soulmate，但是我们因为各种原因不得不在另一阶段分开，在不同的地方遇见不同的积木，这些积木与周围的环境都会慢慢的改变我们的形状，当我们再次相遇，我们尝试在一起的时候会突然发现彼此已经不再契合了。会伤感，会遗憾，但是请不要埋怨。这并不是意味着我们不再是朋友了，虽然我们在不同的路上走着，以后的交集也可能会越来越少，但是我们要知道自己现在的形状的一部分也是由彼此塑造的，我们心底依旧埋藏有彼此的回忆。这就够了。 再者是做事，大到择业，小到QPI，要记住的是不要给自己退路。人们在遇到困难的时候，都会潜意识的去寻找逃避的方法，但是切莫去强化这种想法，一旦你觉得这种想法是可行的，你会对你现在处理得事情越来越不专注，总想从背后的这个缺口逃脱出去。最终的结果当然是无法完成任务。比如刚入职的时候我在纠结了很长时间关于ATME和RD的选择问题，Lanny姐和Evils哥都善意的告诉我他们觉得我的性格可能不适合做RD，我花了不少时间去思考对于我个人而言孰优孰劣，但纠结仅仅是浪费大量的精力。公司的平台很大，现在的定位并不是板上钉丁的事情，人生的平台更大，马云还卖过花呢。最后我明确了自己的方向。一定要成为一个不仅是合格，更是优秀的RD后，在具有了一个更宽广的眼界后再来思考这个问题，也许会有更加明智的答案。 2.量变引起质变，厚积终会薄发Buddy哥说他原来喜欢每周六喝一瓶大雪碧，喝完后就直接丢在阳台，喝着喝着有一周再去阳台丢雪碧瓶的时候猛地发现了不知不觉自己已经喝了这么多雪碧了。学习和做事更是这样，buddy哥告诉我们可以每三个月进行一个回顾和制定下阶段计划。这个时间是经验时间。恰好我们公司给我们制定QPI也是三个月一定。可以在保证质量的完成公司任务的基础上增加提升自我个人能力的计划。具体的计划具体分析，甚至请Buddy哥或是其他师兄给一些参考意见我觉得也是极好的。保证每天提升一点点，也许几年后回头一看，会突然发现，“啧，我还是挺牛逼的嘛”。 3.学内核学的是思想Buddy哥说了一个我从未听过而且听过后觉得很悬而空泛的观点。他说对内核的学习，学的是思想。内核是世界上各种大牛思维的沉淀和结晶。所以看内核代码的时候获得的更多的是思想。而且软件程序中有的思想也能利用到为人处世之中。对于这点我的疑惑还是很多。不过我相信每个人在很认真的告诉你一件事情的时候，绝对是他对经历过的某些事情的感悟。所以我暂且将这个观点记下。也许以后某日就会发现，“有点意思，原来真的是这样”，或者“我靠，当年他欺负我读书少尽忽悠我”。恩，不管怎样，总之不要忘了有这么一档子事儿就是了。 言罢，吃大餐","categories":[],"tags":[{"name":"InnerPath","slug":"InnerPath","permalink":"http://iyounix.com/tags/InnerPath/"}]},{"title":"Linux i2c 与 spi 设备在新版内核中不采用DTS设备树形式 在驱动添加设备信息(board_info)的方法","slug":"Linux/[Linux] i2c 与 spi 设备在新版内核中不采用DTS设备树形式 在驱动添加设备信息(board_info)的方法","date":"2015-08-30T22:06:06.000Z","updated":"2018-11-08T01:55:08.305Z","comments":true,"path":"2015/08/31/Linux/[Linux] i2c 与 spi 设备在新版内核中不采用DTS设备树形式 在驱动添加设备信息(board_info)的方法/","link":"","permalink":"http://iyounix.com/2015/08/31/Linux/[Linux] i2c 与 spi 设备在新版内核中不采用DTS设备树形式 在驱动添加设备信息(board_info)的方法/","excerpt":"","text":"i2c 设备模型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;linux/module.h&gt;#include &lt;linux/i2c.h&gt;#define SENSOR_BUS_NUM 0#define SENSOR_SLAVE_ADDRESS 0x3e#define SENSOR_NAME \"sensor\"struct i2c_client *sensor_client=NULL;static int sensor_probe(struct i2c_client *client,const struct i2c_device_id *id)&#123; sensor_client=client; return 0;&#125;static int sensor_remove(struct i2c_client *client)&#123; return 0;&#125;//首先需要一个 id_tablestatic const struct i2c_device_id sensor_id[] = &#123; &#123;SENSOR_NAME, 0&#125;, &#123; &#125;&#125;;MODULE_DEVICE_TABLE(i2c, sensor_id);//在 driver中添加 id_tablestatic struct i2c_driver sensor_driver = &#123; .driver = &#123; .name = SENSOR_NAME, &#125;, .probe = sensor_probe, .remove = sensor_remove, .id_table = sensor_id,&#125;;//填充 board_info static struct i2c_board_info sensor_device = &#123; I2C_BOARD_INFO(\"hmc5883l-i2c\", SENSOR_SLAVE_ADDRESS),&#125;;static int __init sensor_init(void)&#123; struct i2c_adapter *adap; struct i2c_client *client; adap = i2c_get_adapter(sensor_bus_num); if (!adap) &#123; printk(\"i2c adapter %d\\n\",sensor_bus_num); return -ENODEV; &#125; else &#123; printk(\"get ii2 adapter %d ok\\n\", sensor_bus_num); client = i2c_new_device(adap, &amp;sensor_device); &#125; if (!client) &#123; printk(\"get i2c client %s @ 0x%02x fail!\\n\", sensor_device.type, sensor_device.addr); return -ENODEV; &#125; else &#123; printk(\"get i2c client ok!\\n\"); &#125; i2c_put_adapter(adap); i2c_add_driver(&amp;sensor_driver); printk(\"sensor init success!\\n\"); return 0;&#125;static void __exit sensor_exit(void)&#123; i2c_del_driver(&amp;sensor_driver); if(sensor_client!=NULL) i2c_unregister_device(sensor_client); printk(\"Module removed\\n\");&#125;module_init(sensor_init);module_exit(sensor_exit);ODULE_AUTHOR(\"GPL\");ODULE_LICENSE(\"GPL\"); spi设备驱动模型spi的驱动模板如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;linux/module.h&gt;#include &lt;linux/spi/spi.h&gt;#define DEVICE_NAME \"sensor\"#define SENSOR_SPI_BUS 0struct spi_device *sensor_spi=NULL;int sensor_spi_write(void)&#123; return 0;&#125;int sensor_spi_read(void)&#123; return 0;&#125;static const struct spi_device_id sensor_spi_id[] = &#123; &#123; DEVICE_NAME, 0 &#125;, &#123; &#125;&#125;;MODULE_DEVICE_TABLE(spi, sensor_spi_id);static int sensor_probe(struct spi_device *spi)&#123; sensor_spi=spi; return 0;&#125;static int sensor_remove(struct spi_device *spi)&#123; return 0;&#125;static struct spi_driver sensor_driver = &#123; .driver = &#123; .name = DEVICE_NAME, .owner = THIS_MODULE, &#125;, .probe = sensor_probe, .remove = sensor_remove, .id_table = sensor_spi_id,&#125;;static __init int sensor_spi_init(void)&#123; int status=-1; struct spi_master *master; struct spi_device *spi; struct spi_board_info chip = &#123; .modalias = DEVICE_NAME, .mode = 0x00, .bus_num = 0, .chip_select = 0, .max_speed_hz = 2000000, &#125;; spi_register_driver(&amp;sensor_driver); if (status&lt;0) &#123; pr_err(\"%s: spi_register_driver spi_driver failure. status = %d\\n\", __func__, status); &#125; pr_err(\"%s: spi_register_driver spi_driver success. status = %d\\n\", __func__, status); master = spi_busnum_to_master(SENSOR_SPI_BUS); if (!master) &#123; status = -ENODEV; goto error_busnum; &#125; spi = spi_new_device(master, &amp;chip); if (!spi) &#123; status = -EBUSY; goto error_mem; &#125; return status;error_mem:error_busnum: spi_unregister_driver(&amp;sensor_driver); return status;&#125;static __exit void sensor_spi_exit(void)&#123; spi_unregister_driver(&amp;sensor_driver); if(sensor_spi!=NULL) spi_unregister_device(sensor_spi);&#125;module_init(sensor_spi_init);module_exit(sensor_spi_exit);MODULE_LICENSE(\"GPL v2\");","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://iyounix.com/tags/Linux/"}]},{"title":"深圳深圳","slug":"Life/InnerPath/15-08-22深圳深圳","date":"2015-08-22T14:00:00.000Z","updated":"2018-11-08T01:30:40.287Z","comments":true,"path":"2015/08/22/Life/InnerPath/15-08-22深圳深圳/","link":"","permalink":"http://iyounix.com/2015/08/22/Life/InnerPath/15-08-22深圳深圳/","excerpt":"","text":"不得不感慨深圳是个好地方，网上轻轻一搜就发现每个周末都有很多好活动，从免费电影到收费旅行，还有个人比较感兴趣的这类鸡汤or干货类讲座。利用这两天参加了些活动，还算有意思，先总结下这两天的收获。 8.22 智能家居&amp;智能硬件博览会内行看门道，外行看热闹。显然我是后者。不过这并不影响我将这些浅薄的观点记下来的冲动。 1. NFC放眼望去频率出现最高的字眼第一个是物联网，第二个就是NFC了。为什么这么多厂商都在做 NFC ？前段时间在共通性培训中了解到，中国的移动支付这块蛋糕很大，但是银行能力有限吃不了这块蛋糕，却也死死地盯着支付宝等支付平台通过限额啊等手段不让他们好好吃。尤其是NFC支付。据说各大平台都在和银行谈合作，但是后者始终没有松口。而这次 NFC 如此之多可见移动支付浪潮可能就要汹涌袭来。 2.智能硬件这个涵盖的面实在是太广了，从可穿戴设备到智能电视、智能家居、智能汽车、医疗各个方面。产业链有Chip、OS、Sensor、LCD、Connectivity、Software等。但是总的来说给我的感觉就是太杂了，而且都感觉做不大，因为没有一个统一的平台。就拿智能家居这块的智能硬件来说，每个厂商都各做各的，要用一个产品的就必须下载一个APP，然后手机端无线控制这样的产品。第一，这种体验很不好，难道以后普及了智能家居后满手机的几十个APP来控制全家的电器？第二，个人认为这种形式根本算不上智能，这无外乎是将开关集成到了手机上，和传统的硬件开关没有本质差别，只是缩小了一点点体力成本，但是体验并没有质的飞跃。什么才是真正的智能家居，你完全不用去干预，你以为它不存在，但是没有它幸福感下降了一大截的家居我认为才能叫智能家居。就比智能空调，先不谈硬件实现，可以想象这样一幅场景。你回家前几分钟空调自动打开调节家里温度，一到家心旷神怡，当你离空调较近，你戴的手环感受到你体温较低，自动反馈数据给空调（更有可能是网关），然后空调（或者网关）控制温度到合适的度数。到了这一步，才能算是实现了智能家居。 3.前沿技术当天晚上有未能去的同学问我，这次展览会有哪些前沿技术。我说不上来，一则是深入的技术实现确实不知道，二则是到底怎么样去定义前沿技术？可以拿前段时间学过的 RearMirror和 TypeC来举例。最近出的像ZUK手机等，很多厂商陆续开始采用typeC的接口，大家都以为这是前沿技术，但是实际上呢，2013年底这个东西就已经出来了，一直在推广了，但是直到现在才慢慢开始普及。RearMirror后视镜导航也是一样，公司两年前就开始推广了，但是现在其实仍然没有普及。不过这次博览会确实看到了不少车载硬件。所以对于现在的自己而言，以为现在公司正在推广的有些方案算前沿了，但是实际上也有可能Vendor早就做完了。没有达到一定的高度是看不到这个行业的全貌的。并且，隔行如隔山，学无止境。 8.22 UbuntuHackathon手机开发者比赛恰巧赶上了下午的snappy讲座，见到了微博上久仰的大牛，兴奋溢于言表。世界上还有这么多这么多厉害的人，真想和他们交流一下。虽然没有赶上上午的抽奖，不过前台小妹送了一套纪念品给我，也是很开心。 8.23 百度和个推联合沙龙主要是几个创业team的leader来分享一下创业路上碰到的困难和能够走到现在所积累的一些经验。归纳概括一下。 一、嗒嗒巴士 选择互联网产品定位 彭总有时候确定一款产品可以根据价格区间来定，比如现在的上班方式有三种，公交/地铁（0.2元/人/公里）、出租车（1.6元/人/公里）、自驾车（3元/人/公里），会发现在低端和终端市场中出现一种人群（白领），他们既厌恶挤公交却又因工资局限无法负担每天的出租车上下班的昂贵费用。他们愿意提升一点点的价格来换取更优质一点的出行方式。所以这个产品应运而生。期间还提到了确定产品的一点就是 高频、海量、刚需、痛点，满足这四个点的产品才是好产品。 二、小恩爱 如何搭建初创团队 钟总 避免大家能力模型相似 明确分工，每个方向有一个大拿，避免陷入不必要的争辩。 说话直接透明。 对事不对人。 重项目，轻管理，保证速度和灵活。 只招聘更牛的人。 快招快裁，发现不能胜任立刻裁掉。 三、酱知 如何争取大牛来加入团队 站长 一定程度上提升自己的技术实力，并且多与比自己厉害的小牛们交流，并处理好关系。 和小牛抱团，利用小牛的力量争取大牛入伙。 在士气方面。要知道一段时间内没有可见的成效会极大地挫败士气，需要定阶段性目标，并激励成员。 方向比努力更重要！","categories":[],"tags":[{"name":"InnerPath","slug":"InnerPath","permalink":"http://iyounix.com/tags/InnerPath/"}]},{"title":"RockChip parameter.txt 文件详解","slug":"Environment/[RockChip] parameter.txt 文件详解","date":"2015-08-05T15:01:05.000Z","updated":"2018-11-08T02:08:40.195Z","comments":true,"path":"2015/08/05/Environment/[RockChip] parameter.txt 文件详解/","link":"","permalink":"http://iyounix.com/2015/08/05/Environment/[RockChip] parameter.txt 文件详解/","excerpt":"","text":"Platform: RK3399OS: Android 6.0Version: v2016.08 [TOC] Parameter 最大为 64KB。其中的参数由 Bootloader 解析。 parameter 分析固件版本，打包 update.img 用到。升级工具据此识别固件版本FIRMWARE_VER: 6.0.1 #机型，打包 update.img 用到。用于升级工具显示。MACHINE_MODEL: RK3399 #产品ID，为数字或字母组合，打包 update.img 使用。MACHINE_ID: 007 #机型，打包 update.img 用到。用于升级工具显示。MANUFACTURER: RK3399 #无法修改MAGIC: 0x5041524B #无法修改ATAG: 0x00200800 #无法修改，内核识别用MACHINE: 3399 #无法修改CHECK_MASK: 0x80 #PWR_HLD:0,0,C,7,1 //控制 GPIO0C7 输出高电平 #PWR_HLD:0,0,C,7,2 //控制 GPIO0C7 输出低电平 #PWR_HLD:0,0,A,0,3 //配置 PWR_HLD 为 GPIO0A0,在 Loader 需要锁定电源时,输出高电平锁定电源最后一位是电平判断，解释:1:= 解析 parameter 时,输出高电平2:= 解析 parameter 时,输出低电平3:= 在 Loader 需要控制电源时,输出高电平0:= 在 Loader 需要控制电源时,输出低电平这里是控制 GPIO0 A0 输出高电平PWR_HLD: 0,0,A,0,1 #内核地址，bootloader 将加载此地址，如果 kernel 编译地址改变，需要修改此值#KERNEL_IMG: 0x00280000 #FDT_NAME: rk-kernel.dtb #按键类型 0 普通按键，GPIO 定义 （三位），电平判断比如 0,4,C,5,0 代表 普通按键，GPIO4 C5, 低电平有效 #按键类型 1 AD按键，AD 定义 （三位），保留比如 1,1,0,20,0 代表 AD按键，ADC 通道，下限值为 00，上限值为 200 即 AD值在 0～200 之间的按键都认为是 RECOVER_KEY#RECOVER_KEY: 1,1,0,20,0 #in section; per section 512(0x200) bytesCMDLINE:androidboot.baseband=N/Aandroidboot.selinux=disabled 安全强化 Linux 是否打开androidboot.hardware=rk30board 硬件平台androidboot.console=ttyFIQ0 串口定义init=/init #MTD分区 RK30xx、RK29xx 和 RK292x 都是用 rk29xxnand 做标识mtdparts=rk29xxnand:0x00002000@0x00002000(uboot),0x00002000@0x00004000(trust),0x00002000@0x00006000(misc),0x00008000@0x00008000(resource),0x00008000@0x00010000(kernel),0x00010000@0x00018000(boot),0x00010000@0x00028000(recovery),0x00038000@0x00038000(backup),0x00040000@0x00070000(cache),0x00200000@0x000B0000(system),0x00008000@0x002B0000(metadata),0x00002000@0x002B8000(baseparamer),-@0x002BA000(userdata) @符号前是分区的大小@符号后是分区的起始地址括号中是分区的名字单位都是 sector（512Bytes）比如 uboot 起始地址为 0x2000 sectors （4MB）的位置，大小为 0x2000 sectors（4M）另外 flash 最大的 block 是 4M（0x2000 sectors），所以每个分区需要 4MB 对齐，即每个分区必须为 4MB 的整数倍。 ,0x00038000@0x00038000(backup)backup 分区前的分区为固件区 uboot、trust、misc、resource、kernel、boot、recovery 。后续升级时不能修改分区大小backup 分区后的分区 cache、system、metadata、baseparamer、userdata是可以读写的，可以调整分区大小。但是修改分区大小后需要进入 recovery 系统格式化 cache 常见问题1. system 分区改为 ext3 后，parameter 中 mtd 分区如何定义ext3 为可写文件系统，system 分区需要定义在 backup 后。 2. 系统固件变大，backup 分区起始位置和大小变大，系统异常backup 之前的分区只可改小，不可变大，所以请预留足够空间。出现问题后，按住 recovery 进入 loader 升级模式，“修复模式升级固件” 或者 擦出 idb 功能低格 flash 后再升级。另外现在 backup 已经不再备份 system.img 了。","categories":[],"tags":[{"name":"RockChip","slug":"RockChip","permalink":"http://iyounix.com/tags/RockChip/"}]},{"title":"Android eng、user、userdebug区别","slug":"Environment/[Android] eng、user、userdebug区别","date":"2015-08-05T15:01:05.000Z","updated":"2018-11-08T02:08:20.924Z","comments":true,"path":"2015/08/05/Environment/[Android] eng、user、userdebug区别/","link":"","permalink":"http://iyounix.com/2015/08/05/Environment/[Android] eng、user、userdebug区别/","excerpt":"","text":"user userdebug eng 仅安装标签为 user 的模块 安装标签为 user、debug 的模块 设定属性 ro.secure=1，打开安全检查功能 设定属性 ro.secure=1，打开安全检查功能 设定属性 ro.secure=0，关闭安全检查功能 设定属性 ro.debuggable=0，关闭应用调试功能 设定属性 ro.debuggable=1，启用应用调试功能 设定属性 ro.debuggable=1，启用应用调试功能 设定属性 ro.kernel.android.checkjni=1，启用 JNI 调用检查 默认关闭 adb 功能 默认打开 adb 功能 默认打开 adb 功能 打开 Proguard 混淆器 打开 Proguard 混淆器 关闭 Proguard 混淆器 打开 DEXPREOPT 预先编译优化 打开 DEXPREOPT 预先编译优化 关闭 DEXPREOPT 预先编译优化 如果目标构建变体为 user，则 adb 无法获取 root 权限。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://iyounix.com/tags/Android/"}]},{"title":"基本功","slug":"Life/InnerPath/15-08-01基本功","date":"2015-08-01T14:04:00.000Z","updated":"2018-11-08T01:30:40.287Z","comments":true,"path":"2015/08/01/Life/InnerPath/15-08-01基本功/","link":"","permalink":"http://iyounix.com/2015/08/01/Life/InnerPath/15-08-01基本功/","excerpt":"","text":"Lawrence今天滔滔不绝的给我们讲了两个半小时的基本功。总的来说以下几点： 一、相信。 T I P E 8:2法则 打造学习型自己。 二、基本功 拜访客户，实地/电话拜访、没有借口、建立人脉。 meeting minutes，帮助复习和归纳、创造和主管与老板沟通的机会。 换位思考。 三、入势、顺势、创势 一、相信Lawrence说，我们现在会有很多想法，会有很多彩色的气泡在头上飘着。比如会觉得几年后可能会成为某某主管现在的样子，几年后会有多么多么成功，但是，那是不现实的。他给我们绘制了职场三角形。慢慢的将我们意淫的彩色气泡一个个戳破。当时确实有些难受，因为我就是如他所描述一般那么想的。但是现在却发现，被戳破了彩色泡泡的自己似乎更加踏实了一点。Lawrence的意思应该是指每个人都会有幻想，有憧憬，有梦想在某个云端，但是你得把这朵云放到身后，一步一个台阶的踏实的往上走。TIPE 团队 诚信 专业 高效，将自己打造成具有这四点素质的人。并且八分精力工作，两分精力学习。不学习就会被淘汰。（想起之前听罗胖子的一期节目，他说200年前美国人口的40%都是农民，但是十年前就只有2%了，那还有38%的农民呢，慢慢的被淘汰了，被挤压到其他的行业去了。这种改变现在正无时不刻的发生在我们身边。美国农民用了200年的时间来慢慢接受这个改变，然而我们可能只有十几年来接受这种巨变。而在这种巨变中不被淘汰的关键因素就是学习能力。）而且要有前瞻性地学习，学习未来可能会用到的技术。比如后视镜导航，来大联大前确实没听说过这个产品。但是阿诺却说这个早已在一两年前就开始在做了，以后可能会更加普及。似乎当一个东西已经被消费者完全熟知的时候，某种意义上可能已经不再需要更多的具有相关技术能力的从业者了。想要把握住风口前瞻性的学习能力是必不可少的（即使暂时自己没有这种能力，靠公司的分析来把握学习方向也是一种很好的策略）。 二、基本功拜访客户这里的客户实际上指的是广义的客户，我理解的它除了可以是和你发生生意上关系的人还可以是老板，是同事。对于工作相关的客户你需要实地或者电话来推广自己的产品。对于老板对于同事，更多的是维护一定的关系。而无论是对什么样的人，最重要的就是销售自己。 没有借口让我想起了西点军校的校规，有一条就是No Excuse。在工作上，碰到困难需要的是立即去想出解决办法。不要将时间浪费在无谓的争辩或者是推卸责任上。Lawrence说这样做的好处首先当然是解决了问题，其次也是更重要的一点就是这种No Excuse的行为让你给其他人留下了一个很好的印象。其实作为一个Newbie，别人并不会对我们有过多的期待，犯错也是十分正常的，而逃避责任这种态度却会给别人留下很糟糕的感觉。同样，如果能积极的承认错误并且及时的解决问题，这才是共事者更愿意看到的。并且这也对接下来的一点大有裨益。那就是 建立人脉关于这点Lawrence给了两点建议。其一，不要轻易承诺，承诺了一定要实现。还记得小时候某人对说，承诺就像蝴蝶，盘旋着飞然后消失不见。从那个时候开始对于承诺便很谨慎。觉得不对别人承诺别人会觉得你不够义气，承诺了却又没有实现会让自己越来越不靠谱。但是Lawrence说，其实并没有人对你有过度的期待，这一切都是你内心的自以为。要会讨价还价，当最后许下承诺，答应完成任务的时候不要有委屈。（我认为这个观点还是要辩证的来看，我觉得承诺的时候有时恰恰需要超出一点自己的实际能力才好，这样才能有所进步，用承诺去推动着自己前进，未尝不是一件好事）。其二，有争吵一定要及时的抹除。这一点其实说起来比做起来容易太多。当真正的矛盾降临在自己身上的时候，在争吵的那一段期间可能就不会这么理性的去思考及时化解矛盾。但还是在脑中浅浅的打上这样的烙印，更希望不要出现用到这个方法的时候。 Meeting Minutes就说说日报，从开始写日报开始确实感觉学习更有效率了。记忆的东西有个艾宾浩斯曲线，每过一段时间其实遗忘的内容是越来越多的，加上了一个daily report强行让自己复习了一天所学内容，不管是在现在学习内容的记忆还是以后的复习都有不小的帮助。Meeting minutes 应该是同理。 换位思考一般的换位思考指的就是为他人着想，站在其他人的角度来思考问题，从而改变自己的一些不恰当的行为。但是Lawrence把这个观点具象化了。他举得例子是说给不同的对象写信的时候需要站在不同的角度不同的身份来措辞。比如给Vendor的FAE写信和给Customer的RD写信措辞不同，给不同的Vendor发mail又有什么不同。 以上。 三、入势、顺势、创势Lawrence说，这三个的是循序渐进的。当你进入一个行业，你需要经历这三个阶段，当你进入一家公司你也要经历这三个阶段。我们现在就是在入势的阶段，不仅是入行业而且是入公司。关于这个话题他提出了很多观点。不想罗列，也不置可否。 将这节课所有的观点和感受暂且都放在心中，虽然现在持有一种看法但是也许过段时间经历了一些事情后又会有新的想法，这谁说的准呢。最终，随着时间沉淀下来仍旧记忆犹新的东西才是最适合自己的。","categories":[],"tags":[{"name":"InnerPath","slug":"InnerPath","permalink":"http://iyounix.com/tags/InnerPath/"}]},{"title":"入职杂谈","slug":"Life/InnerPath/15-07-27入职杂谈","date":"2015-07-27T14:00:00.000Z","updated":"2018-11-08T01:30:40.287Z","comments":true,"path":"2015/07/27/Life/InnerPath/15-07-27入职杂谈/","link":"","permalink":"http://iyounix.com/2015/07/27/Life/InnerPath/15-07-27入职杂谈/","excerpt":"","text":"转瞬入职已经第三个星期了。不得不感叹，人类真的是一种神奇而强大的生物，从最开始的生理上的水土不服，到现在已经能很完美的和工作节奏进行共振，才用了三周不到的时间。 想分享和记录的东西有很多。一点一点慢慢的道来吧。 Team我好担心。因为我们这个Team太棒了，我觉得以后要分开的时候一定会痛苦的死去活来。像阿诺哥说的一样，“啊，刚开始玩的很好的朋友跳槽了会很伤心很伤心，不过后来来的多了走的多了也就习惯了，哈哈，恩，哎，真的是这样的”。再想想Bear说的二十个人三年后可能就留四五个人，于是更加伤感了。不扯伤感的了，我们的Team简直不能更赞。一个一个掰。小组长,Jeremy，双子座，闷骚，虽然看起来正经的很，但是就是个闷骚，我无意中说个拟声词啪啪啪他都能笑半天，然后的然后我们才后知后觉的get到他的点。Fawn，英文名奇怪的不行，人逗且笨，还强行在我手机联系人叫clever，勇气可嘉。不过Funny逗虽逗，人还是很好的，尤其是零食总是准备的很充足。Zaki，不错不错，不错不错，不错不错，明骚，而且荤素通吃，他就是team中那个能完美catch my point的人，真正的战斗力实在是未知。Hugo，厉害，任何课任何位置360度无死角睡着。厉害，并且具有随时随地随身都能掏出两只以上的笔的特技。Locke，也是强，感觉隐藏战斗力应该蛮高的。仅从课堂上面的表现来看硬件软件感觉都懂，但是这么适合嵌入式的一坨料竟然被安排去造云，实在是有点奇怪。Ivy，和Locke一起去造云的“BOSS的女儿”，一开始寡言少语，后来熟络后也渐渐的聊了一些，温润如玉的女子，但是现在感觉还是颇具有一些隐藏属性有待挖掘。Jemma，哦，简直帅爆了，就一个字，帅，太帅了，帅爆了。真的帅。好帅。Silvia，这个孩子..笑点低，反射弧长。哦，还有处女座，Gosh。 MasterLanny姐，感觉萌萌哒，总是给人激情四射的感觉，将实验室的一群闷骚弄得服服帖帖的。Raven哥，虽然一开始在我们面前表现的很严肃，但后来越来越熟才发现原来也是ATU这么多逗逼中的一个。Benson哥，一个字，酷，一看就是大神级别，不过却不高冷，每次有问题问他都会非常耐心地指导。Bert哥，每天就只有早上打招呼会有一点点交集，也是寡言少语，但是不出意料应该也是个闷骚。Bert哥旁边的师兄暂时还不知道名字，但我觉得值得一提。太荤了，任何正常的词被他重复一遍就能引申出奇怪的含义。有这种特殊能力的人已经不仅仅是用一个骚字能形容得了的了。Bear哥，实在难以想象他是91年的，虽然虎背熊腰的但是人却很温柔，当然如果忽略掉腹黑的话。阿诺哥，偶尔自顾自的笑的满脸通红，但是我们并不能get到他的点，于是大家尴尬的跟着傻笑，然后他就笑的更厉害了。Recky哥，说话不急不忙，但是却很犀利。想想后面他还要给我讲解7715的电路图便有点期待和害怕。Luff，暂时还没有讲过话，但是，帅。 Schedule从第一天开始，每天都很充实。但是和当初所想的上班情景完全不一样啊，第一个星期的时候感觉忙的要爆炸了，不过还是蛮佩服我们自己的，慢慢地竟然适应了这种日子。 确实站在一个高一点的地方看到的风景也会不一样。没有进入这个行业之前，通过媒体看到的东西加上一点自己的脑补就以为是现状或者是未来的趋势了。但其实那就是管中窥豹。现在站在一个更高的平台上，获得了一根更粗的管子，虽然视野仍旧局限，但是和前几个月的那个在象牙塔中的自己相比，已经截然不同了。知道了我们这个行业的22个Applications，对每个应用都有了初步的了解和一定的认识。这种了解也不再是空想，而是基于框图的更加实际的认知。这种感觉很棒。后面的专业性培训也十分让人期待，虽然感觉压力会越来越大，但是我相信几个月后收获到的知识也不会少。 Fighting！","categories":[],"tags":[{"name":"InnerPath","slug":"InnerPath","permalink":"http://iyounix.com/tags/InnerPath/"}]},{"title":"六月的尾巴","slug":"Life/InnerPath/15-07-19六月","date":"2015-07-19T14:01:05.000Z","updated":"2018-11-08T01:30:40.287Z","comments":true,"path":"2015/07/19/Life/InnerPath/15-07-19六月/","link":"","permalink":"http://iyounix.com/2015/07/19/Life/InnerPath/15-07-19六月/","excerpt":"","text":"写这篇日志的时候已然是七月，转眼已经将这个Blog搁置了有一个月有余。其实看看微博看看空间回顾起来，这个月发生的事情有很多，比如比如毕业，比如手术，比如一不小心被罗胖子的节目颠覆了或者说更新了三观。但是现在站在七月的尾巴看着六月，其实也并没有什么值得怀念的。 关于毕业，人有悲欢离合，月有阴晴圆缺。从大三就一直很期待着毕业，期待着工作，期待着去探索象牙塔外的世界。但是越临近毕业越是害怕，还有太多的事情没有做，还有太多的情没有珍惜。有段时间很难受，因为想想要离开这个呆了21年的城市，想想要去新的城市开始后面的生活，想想每个周末武汉的基友们都会在一起把酒言欢，而我不在，想想想想，光是想想就有很多的不安和无奈，有时甚至后悔了自己的抉择。像一开始跑招聘狠下心觉得非杭州非深圳不去，非嵌入式不做，但是越临近毕业，越是会想，“那又如何？”，喧嚣和繁华其实都是别人的，其实和自己并不会有什么关系，一辈子最重要的不就是朋友情和开心么。甚至有想过去推了OFFER然后再去在武汉找一家离朋友们近点的公司。六月的主基调就是躁动。现在看来，后悔仍然是有的，却又有点庆幸当时没有那么冲动。现在说人生可能太早，但是人生有时可能就是这样，总是在不断地后悔中前行，但是其实无论是怎样的环境来迎接你，你都能接受并且融入。因为四个月前的选择，来到了现在这家公司，见到了新的人，认识了新的朋友，站上了新的平台。站在这个平台上，看到了很多曾经无法看到的世界。想想常常和室友们卧床长谈，各种文韬武略，挥斥方遒。现在看看然而那都是山脚下的风景。现在终于有了一点点的机会慢慢登上山腰，光是攀登的路上偷偷回头眺望远处，风景的旖旎就已经让我窒息。刚开始总希望将我看到的风景分享给基友们。但是却发现，不同的行业确实越往上共通的东西越少。慢慢的也不再和他们分享了。因为我知道，他们也在攀登，也可能在山底与山腰之间，也可能因感叹美景，也可能被荆棘挡住去路，但是，我们终究爬的不是一座山。我们只要互相知道，彼此都还拼搏着快乐着就够了。 关于逻辑思维，这个节目真的是awesome，说再多溢美之词都不为过。做手术修养的那段时间每天躺在床上，就静静的听着罗振宇罗胖子滔滔不绝的讲，讲历史，讲互联网，讲世界。当时我让老妈拿来本子和笔，我就躺在床上从120集一直倒着听，听到了30集，边听便在纸上写下感想和关键字。最后大概十来天修养完后，急不可耐地翻开本子从最开始记录的地方开始看，看着本子上鸡飞凤舞的字和凌乱不堪的排版，和我脑海中整齐的排版完全不一样，但是收获到的确实很多。当时也想着将每个感触很深的点都更到微博上去，后来也作罢，一则因为懒，二则因为没必要，因为这些观念的改变用言语表述是远远不够的，更多的是一钟逻辑思维方式的提升。逻辑思维，推荐，真的很棒。 最后，总结一下，二零一五年六月，一不小心就22岁了，却还没有学会舍得。","categories":[],"tags":[{"name":"InnerPath","slug":"InnerPath","permalink":"http://iyounix.com/tags/InnerPath/"}]},{"title":"开始的废话总是特别多","slug":"Life/InnerPath/15-05-04开始的废话总是特别多","date":"2015-05-14T04:01:05.000Z","updated":"2018-11-08T01:30:40.287Z","comments":true,"path":"2015/05/14/Life/InnerPath/15-05-04开始的废话总是特别多/","link":"","permalink":"http://iyounix.com/2015/05/14/Life/InnerPath/15-05-04开始的废话总是特别多/","excerpt":"","text":"很久以前便有了建立个人站点的想法了。但是总是想着等学会PHP再建吧，等学会HTML再建吧，等着等着犹豫太多而行动太少，等到现在仍然什么都不会。直到昨天毕业论文大致搞定，慢慢闲下来的时候，这个念头猛的又冒了出来，于是在什么也不会的情况下一咬牙去Godaddy上买了域名和服务器。果然有的事情就像是踩脚踏车，第一脚总是最为艰难，但是一旦使劲踏下去了后面便慢慢的轻松了。 因为暂时还没有语言基础，便准备用wordpress建站，果然很傻瓜，不过用着用着就喜欢上了，因为能有更多的时间构思内容而不是前端了。现在还正琢磨着怎么把ChinaUnix和CSDN上的博客导入进来，还在摆弄着微博接口，还想把年少时QQ空间里面的稚嫩观点导进来，毕竟实在是舍不得那个可爱的曾经。 自顾自的碎碎念了这么多最后就介绍下建这个个人站点的目的吧：一来为了记录学习生活的心路历程。也许若干年后的自己闲来无事驻足回首一看，兴许因现在的不成熟而忍俊不禁，这便足够了。二来为了分享干货。好记性不如烂笔头，站在岸上学不会游泳（新人教版小学四年级上册）。三则是为了锻炼锻炼自己的文笔和表达，微博上有个做自媒体的叫大熊，虽然他很喜欢装逼，文章也有些恶俗全是谈钱钱钱的一些事，但是我仍然很欣赏他的三观。他的文章中有一篇就是讲定期的写文章所带来的好处。慢慢的逻辑思维能力变强了，看问题的角度更加多元了，定期推送文章也使微博微信粉丝变多了，影响力也随之变大了。总之，偶尔抽出一两个小时来记录生活记录想法是有利而无害的。 恩，就这些吧，以上。 update:2016-01-01 新的一年，把服务器转到了 Github 上，一来每年可以省个几十块钱喝咖啡，二来再也不用忍受间歇性被墙的苦痛。新站点不再采用 wordpress ，改用 Hexo 后整个人都 Geek 了。学习了 Markdown 也觉得确实更专注了一些，写点东西，“姑肆异日观”，况修短随化，终期于尽，希望他日观之，亦将有感于斯文吧。","categories":[],"tags":[{"name":"InnerPath","slug":"InnerPath","permalink":"http://iyounix.com/tags/InnerPath/"}]}]}