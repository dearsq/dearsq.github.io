<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://iyounix.com/"/>
  <updated>2018-11-09T07:20:33.367Z</updated>
  <id>http://iyounix.com/</id>
  
  <author>
    <name>Younix</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux device 操作接口</title>
    <link href="http://iyounix.com/2018/11/09/Linux/Linux%20device%20%E6%93%8D%E4%BD%9C%E6%8E%A5%E5%8F%A3/"/>
    <id>http://iyounix.com/2018/11/09/Linux/Linux device 操作接口/</id>
    <published>2018-11-09T13:00:00.000Z</published>
    <updated>2018-11-09T07:20:33.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="device-操作-API"><a href="#device-操作-API" class="headerlink" title="device 操作 API"></a>device 操作 API</h2><h3 id="将新的-device-注册到设备模型"><a href="#将新的-device-注册到设备模型" class="headerlink" title="将新的 device 注册到设备模型"></a>将新的 device 注册到设备模型</h3><p>device_create-&gt;device_create_vargs-&gt;device_register-&gt;device_add<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct device *device_create(struct class *class, struct device *parent,</span><br><span class="line">                 dev_t devt, void *drvdata, const char *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    dev = device_create_vargs(class, parent, devt, drvdata, fmt, vargs);</span><br><span class="line">    ......</span><br><span class="line">    return dev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct device *device_create_vargs(struct class *class, struct device *parent,</span><br><span class="line">                   dev_t devt, void *drvdata, const char *fmt,</span><br><span class="line">                   va_list args)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    dev-&gt;devt = devt;</span><br><span class="line">    dev-&gt;class = class;</span><br><span class="line">    dev-&gt;parent = parent;</span><br><span class="line">    dev-&gt;release = device_create_release;</span><br><span class="line">    dev_set_drvdata(dev, drvdata);</span><br><span class="line">    ......</span><br><span class="line">    retval = device_register(dev);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int device_register(struct device *dev) &#123;</span><br><span class="line">device_initialize(dev); // 调用初始化 device 结构</span><br><span class="line">return device_add(dev); // 真正将 device 对象 dev 插入设备模型中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>device_initialize()</code> 初始化嵌入的 kobject 结构 dev-&gt;kobj, 初始化列表中的孩子列表 kobj-&gt;klist_children，初始化 DMA 冲池 dev-&gt;dma_pools, 初始化自旋锁 dev-&gt;devres_lock等<br><code>device_add()</code>首先是通过kboject_add()函数将它添加到kobject层次，再把它添加都全局和兄弟链表中，最后添加到其他相关的子系统的驱动程序模型，完成device对象的注册。</p><h3 id="从设备模型销毁-device"><a href="#从设备模型销毁-device" class="headerlink" title="从设备模型销毁 device"></a>从设备模型销毁 device</h3><p>device_destroy() 用于从linux内核系统设备驱动程序模型中移除一个设备，并删除/sys/devices/virtual目录下对应的设备目录及/dev/目录下对应的设备文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void device_destroy(struct class *dev, dev_t devt);</span><br></pre></td></tr></table></figure></p><h3 id="补充-device-create-register-add-区别"><a href="#补充-device-create-register-add-区别" class="headerlink" title="补充 device create register add 区别"></a>补充 device create register add 区别</h3><p>可以参考这篇文章 : <a href="https://blog.csdn.net/zifehng/article/details/73844845" target="_blank" rel="noopener">https://blog.csdn.net/zifehng/article/details/73844845</a></p><h3 id="补充-class-create-和-device-create-区别"><a href="#补充-class-create-和-device-create-区别" class="headerlink" title="补充 class_create 和 device_create 区别"></a>补充 class_create 和 device_create 区别</h3><p>条件: 如果用户空间支持 <strong>udev</strong><br>可以利用内核为我们提供的一组 API , 实现在模块加载的时候自动在 /dev 目录下创建相应设备节点，并在卸载模块时删除该节点.<br>内核中定义了struct class结构体，其实例化的对象对应一个类，<br>内核同时提供了class_create(…)函数，可以用它来创建一个类，这个类存放于sysfs下面，<br>一旦创建好了这个类，再调用device_create(…)函数来在/dev目录下创建相应的设备节点。<br>这样，加载模块的时候，用户空间中的udev会自动响应device_create(…)函数，去/sysfs下寻找对应的类从而创建设备节点。</p><p>SOP 如下:</p><ol><li><code>mem_class = class_create(THIS_MODULE,&quot;younix_class_char&quot;);</code><br>建立逻辑设备类, 在 /sys/class/ 下建立了 younix_class_char 目录</li><li><code>device_create(mem_class,NULL,MKDEV(MEM_MAJOR,MEM_MINOR),NULL,&quot;younix_class_char&quot;);</code><br>建立设备节点, 在 /dev/ 下自动建立 younix_class_char 建立设备节点</li></ol><p>Demo 可以参考 : <a href="https://blog.csdn.net/tq384998430/article/details/54342044" target="_blank" rel="noopener">https://blog.csdn.net/tq384998430/article/details/54342044</a> 中 字符设备驱动程序 的 Demo</p><h2 id="struct-device"><a href="#struct-device" class="headerlink" title="struct device"></a>struct device</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct device - The basic device structure</span><br><span class="line"> * @parent:The device&apos;s &quot;parent&quot; device, the device to which it is attached.</span><br><span class="line"> * In most cases, a parent device is some sort of bus or host</span><br><span class="line"> * controller. If parent is NULL, the device, is a top-level device,</span><br><span class="line"> * which is not usually what you want.</span><br><span class="line"> * @p:Holds the private data of the driver core portions of the device.</span><br><span class="line"> * See the comment of the struct device_private for detail.</span><br><span class="line"> * @kobj:A top-level, abstract class from which other classes are derived.</span><br><span class="line"> * @init_name:Initial name of the device.</span><br><span class="line"> * @type:The type of device.</span><br><span class="line"> * This identifies the device type and carries type-specific</span><br><span class="line"> * information.</span><br><span class="line"> * @mutex:Mutex to synchronize calls to its driver.</span><br><span class="line"> * @bus:Type of bus device is on.</span><br><span class="line"> * @driver:Which driver has allocated this</span><br><span class="line"> * @platform_data: Platform data specific to the device.</span><br><span class="line"> * Example: For devices on custom boards, as typical of embedded</span><br><span class="line"> * and SOC based hardware, Linux often uses platform_data to point</span><br><span class="line"> * to board-specific structures describing devices and how they</span><br><span class="line"> * are wired.  That can include what ports are available, chip</span><br><span class="line"> * variants, which GPIO pins act in what additional roles, and so</span><br><span class="line"> * on.  This shrinks the &quot;Board Support Packages&quot; (BSPs) and</span><br><span class="line"> * minimizes board-specific #ifdefs in drivers.</span><br><span class="line"> * @driver_data: Private pointer for driver specific info.</span><br><span class="line"> * @power:For device power management.</span><br><span class="line"> * See Documentation/power/devices.txt for details.</span><br><span class="line"> * @pm_domain:Provide callbacks that are executed during system suspend,</span><br><span class="line"> * hibernation, system resume and during runtime PM transitions</span><br><span class="line"> * along with subsystem-level and driver-level callbacks.</span><br><span class="line"> * @pins:For device pin management.</span><br><span class="line"> *See Documentation/pinctrl.txt for details.</span><br><span class="line"> * @numa_node:NUMA node this device is close to.</span><br><span class="line"> * @dma_mask:Dma mask (if dma&apos;ble device).</span><br><span class="line"> * @coherent_dma_mask: Like dma_mask, but for alloc_coherent mapping as not all</span><br><span class="line"> * hardware supports 64-bit addresses for consistent allocations</span><br><span class="line"> * such descriptors.</span><br><span class="line"> * @dma_pfn_offset: offset of DMA memory range relatively of RAM</span><br><span class="line"> * @dma_parms:A low level driver may set these to teach IOMMU code about</span><br><span class="line"> * segment limitations.</span><br><span class="line"> * @dma_pools:Dma pools (if dma&apos;ble device).</span><br><span class="line"> * @dma_mem:Internal for coherent mem override.</span><br><span class="line"> * @cma_area:Contiguous memory area for dma allocations</span><br><span class="line"> * @archdata:For arch-specific additions.</span><br><span class="line"> * @of_node:Associated device tree node.</span><br><span class="line"> * @acpi_node:Associated ACPI device node.</span><br><span class="line"> * @devt:For creating the sysfs &quot;dev&quot;.</span><br><span class="line"> * @id:device instance</span><br><span class="line"> * @devres_lock: Spinlock to protect the resource of the device.</span><br><span class="line"> * @devres_head: The resources list of the device.</span><br><span class="line"> * @knode_class: The node used to add the device to the class list.</span><br><span class="line"> * @class:The class of the device.</span><br><span class="line"> * @groups:Optional attribute groups.</span><br><span class="line"> * @release:Callback to free the device after all references have</span><br><span class="line"> * gone away. This should be set by the allocator of the</span><br><span class="line"> * device (i.e. the bus driver that discovered the device).</span><br><span class="line"> * @iommu_group: IOMMU group the device belongs to.</span><br><span class="line"> *</span><br><span class="line"> * @offline_disabled: If set, the device is permanently online.</span><br><span class="line"> * @offline:Set after successful invocation of bus type&apos;s .offline().</span><br><span class="line"> *</span><br><span class="line"> * At the lowest level, every device in a Linux system is represented by an</span><br><span class="line"> * instance of struct device. The device structure contains the information</span><br><span class="line"> * that the device model core needs to model the system. Most subsystems,</span><br><span class="line"> * however, track additional information about the devices they host. As a</span><br><span class="line"> * result, it is rare for devices to be represented by bare device structures;</span><br><span class="line"> * instead, that structure, like kobject structures, is usually embedded within</span><br><span class="line"> * a higher-level representation of the device.</span><br><span class="line"> */</span><br><span class="line">struct device &#123;</span><br><span class="line">struct device*parent; //指向父设备</span><br><span class="line"></span><br><span class="line">struct device_private*p; </span><br><span class="line"></span><br><span class="line">struct kobject kobj;         //内嵌的 kobj 对象</span><br><span class="line">const char*init_name; /* initial name of the device */</span><br><span class="line">const struct device_type *type;</span><br><span class="line"></span><br><span class="line">struct mutexmutex;/* mutex to synchronize calls to</span><br><span class="line"> * its driver.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">struct bus_type*bus;/* type of bus device is on */</span><br><span class="line">struct device_driver *driver;/* which driver has allocated this</span><br><span class="line">   device */</span><br><span class="line">void*platform_data;/* Platform specific data, device</span><br><span class="line">   core doesn&apos;t touch it */</span><br><span class="line">void*driver_data;/* Driver data, set and get with</span><br><span class="line">   dev_set/get_drvdata */</span><br><span class="line">struct dev_pm_infopower;</span><br><span class="line">struct dev_pm_domain*pm_domain;</span><br><span class="line"></span><br><span class="line">u64*dma_mask;/* dma mask (if dma&apos;able device) */</span><br><span class="line">u64coherent_dma_mask;/* Like dma_mask, but for</span><br><span class="line">     alloc_coherent mappings as</span><br><span class="line">     not all hardware supports</span><br><span class="line">     64 bit addresses for consistent</span><br><span class="line">     allocations such descriptors. */</span><br><span class="line">unsigned longdma_pfn_offset;</span><br><span class="line"></span><br><span class="line">struct device_dma_parameters *dma_parms;</span><br><span class="line"></span><br><span class="line">struct list_headdma_pools;/* dma pools (if dma&apos;ble) */</span><br><span class="line"></span><br><span class="line">struct dma_coherent_mem*dma_mem; /* internal for coherent mem</span><br><span class="line">     override */</span><br><span class="line">/* arch specific additions */</span><br><span class="line">struct dev_archdataarchdata;</span><br><span class="line"></span><br><span class="line">struct device_node*of_node; /* associated device tree node */</span><br><span class="line">struct acpi_dev_nodeacpi_node; /* associated ACPI device node */</span><br><span class="line"></span><br><span class="line">dev_tdevt;/* dev_t, creates the sysfs &quot;dev&quot; */</span><br><span class="line">u32id;/* device instance */</span><br><span class="line"></span><br><span class="line">spinlock_tdevres_lock;</span><br><span class="line">struct list_headdevres_head;</span><br><span class="line"></span><br><span class="line">struct klist_nodeknode_class;</span><br><span class="line">struct class*class;</span><br><span class="line">const struct attribute_group **groups;/* optional groups */</span><br><span class="line"></span><br><span class="line">void(*release)(struct device *dev);</span><br><span class="line">struct iommu_group*iommu_group;</span><br><span class="line"></span><br><span class="line">booloffline_disabled:1;</span><br><span class="line">booloffline:1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>以一个简单的led设备字符设备驱动为例 , 主要关注 <strong>创建设备节点</strong> 的实现 , 这里是以 device_create 进行创建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">static class *led_class;</span><br><span class="line"></span><br><span class="line">static int __init led_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    dev_t devno;</span><br><span class="line">    struct cdev *cdev;</span><br><span class="line">    struct dev *dev;</span><br><span class="line"></span><br><span class="line">    /* 注册设备号 */</span><br><span class="line">    ret = alloc_chrdev_region(&amp;devno, 0, 1, &quot;led&quot;);</span><br><span class="line">    if (ret &lt; 0) </span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line">    /* 分配、初始化、注册cdev*/</span><br><span class="line">    cdev = cdev_alloc();</span><br><span class="line">    if (IS_ERR(cdev)) &#123;</span><br><span class="line">        ret = PTR_ERR(cdev);</span><br><span class="line">        goto out_unregister_devno;</span><br><span class="line">    &#125;</span><br><span class="line">    cdev_init(&amp;cdev, &amp;led_fops);</span><br><span class="line">    cdev.owner = THIS_MODULE;</span><br><span class="line">    ret = cdev_add(&amp;cdev, devno, 1);    </span><br><span class="line">    if (ret) </span><br><span class="line">        goto out_free_cdev;</span><br><span class="line"></span><br><span class="line">    /* 创建设备类 */</span><br><span class="line">    led_class = class_create(THIS_MODULE, &quot;led_class&quot;);</span><br><span class="line">    if (IS_ERR(led_class)) &#123;</span><br><span class="line">        ret = PTR_ERR(led_class);</span><br><span class="line">        goto out_unregister_cdev;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    /* 创建设备节点 */</span><br><span class="line">    dev = device_create(led_class, NULL, devno, NULL, &quot;led&quot;);</span><br><span class="line">    if (IS_ERR(dev)) &#123;</span><br><span class="line">        ret = PTR_ERR(dev);</span><br><span class="line">        goto out_del_class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">out_del_class:</span><br><span class="line">    class_destroy(c78x_class); </span><br><span class="line">out_unregister_cdev:</span><br><span class="line">    cdev_del(cdev);</span><br><span class="line">out_free_cdev:</span><br><span class="line">    kfree(cdev);</span><br><span class="line">out_unregister_devno:</span><br><span class="line">    unregister_chrdev_region(devno, 1);</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_init);</span><br></pre></td></tr></table></figure></p><p>如果使用 device_register 进行创建, 对应 创建设备节点部分应该修改为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* 创建设备节点 */</span><br><span class="line">    dev = kzalloc(sizeof(*dev), GFP_KERNEL);</span><br><span class="line">    if (!dev) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        goto out_del_class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev-&gt;class = led_class;         // 关联设备类</span><br><span class="line">    dev-&gt;parent = NULL;             </span><br><span class="line">    dev-&gt;devt = devno;              // 关联设备号</span><br><span class="line">    dev_set_drvdata(dev, NULL);     </span><br><span class="line">    dev_set_name(dev, &quot;led&quot;);       // 设置节点名字</span><br><span class="line">    dev-&gt;release = device_create_release;</span><br><span class="line"></span><br><span class="line">    ret = device_register(dev);</span><br><span class="line">    if (ret) </span><br><span class="line">        goto out_put_dev;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">out_put_dev:</span><br><span class="line">    put_device(dev);</span><br><span class="line">    kree(dev);</span><br></pre></td></tr></table></figure></p><p>如果是使用 device_add() 进行创建, 进行如下修改:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/* 创建设备节点 */</span><br><span class="line">    dev = kzalloc(sizeof(*dev), GFP_KERNEL);</span><br><span class="line">    if (!dev) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        goto out_del_class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev-&gt;class = led_class;         // 关联设备类</span><br><span class="line">    dev-&gt;parent = NULL;             </span><br><span class="line">    dev-&gt;devt = devno;              // 关联设备号</span><br><span class="line">    dev_set_drvdata(dev, NULL);     </span><br><span class="line">    dev_set_name(dev, &quot;led&quot;);       // 设置节点名字</span><br><span class="line">    dev-&gt;release = device_create_release;</span><br><span class="line"></span><br><span class="line">    device_initialize(dev);         // 多了这一步</span><br><span class="line">    ret = device_add(dev);</span><br><span class="line">    if (ret) </span><br><span class="line">        goto out_put_dev;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">out_put_dev:</span><br><span class="line">    put_device(dev);</span><br><span class="line">    kree(dev);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;device-操作-API&quot;&gt;&lt;a href=&quot;#device-操作-API&quot; class=&quot;headerlink&quot; title=&quot;device 操作 API&quot;&gt;&lt;/a&gt;device 操作 API&lt;/h2&gt;&lt;h3 id=&quot;将新的-device-注册到设备模型&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://iyounix.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 链表操作接口</title>
    <link href="http://iyounix.com/2018/11/09/Linux/Linux%20%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C%E6%8E%A5%E5%8F%A3/"/>
    <id>http://iyounix.com/2018/11/09/Linux/Linux 链表操作接口/</id>
    <published>2018-11-09T13:00:00.000Z</published>
    <updated>2018-11-09T07:20:33.367Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>前提是假设大家有链表的基础<br><a href="https://www.ibm.com/developerworks/cn/linux/kernel/l-chain/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/kernel/l-chain/index.html</a></p><h2 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h2><p>Linux 只定义了链表的节点, 没有专门定义链表头.<br>链表结构是这样建立的</p><h3 id="声明时初始化链表-LIST-HEAD-INIT"><a href="#声明时初始化链表-LIST-HEAD-INIT" class="headerlink" title="声明时初始化链表 LIST_HEAD_INIT"></a>声明时初始化链表 LIST_HEAD_INIT</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span><br><span class="line">#define LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name)</span><br></pre></td></tr></table></figure><p><code>LIST_HEAD_INIT(name)</code>声明一个名为 name 的链表头时，它的next、prev指针都初始化为指向自己 , 这样，我们就有了一个空链表.<br>(Linux用头指针的next是否指向自己来判断链表是否为空)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static inline int list_empty(const struct list_head *head)</span><br><span class="line">&#123;</span><br><span class="line">        return head-&gt;next == head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="运行时初始化链表-INIT-LIST-HEAD"><a href="#运行时初始化链表-INIT-LIST-HEAD" class="headerlink" title="运行时初始化链表 INIT_LIST_HEAD"></a>运行时初始化链表 INIT_LIST_HEAD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define INIT_LIST_HEAD(ptr) do &#123; \</span><br><span class="line">    (ptr)-&gt;next = (ptr); (ptr)-&gt;prev = (ptr); \</span><br><span class="line">&#125; while (0)</span><br></pre></td></tr></table></figure><h2 id="插入-删除-搬移-合并"><a href="#插入-删除-搬移-合并" class="headerlink" title="插入 删除 搬移 合并"></a>插入 删除 搬移 合并</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>对链表的插入操作有两种：在表头插入和在表尾插入。Linux为此提供了两个接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static inline void list_add(struct list_head *new, struct list_head *head);</span><br><span class="line">static inline void list_add_tail(struct list_head *new, struct list_head *head);</span><br></pre></td></tr></table></figure></p><p>因为Linux链表是循环表，且表头的next、prev分别指向链表中的第一个和最末一个节点，所以，list_add和list_add_tail的区别并不大，实际上，Linux分别用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__list_add(new, head, head-&gt;next);</span><br><span class="line">__list_add(new, head-&gt;prev, head);</span><br></pre></td></tr></table></figure></p><p>来实现两个接口，可见，在表头插入是插入在head之后，而在表尾插入是插入在head-&gt;prev之后。<br>假设有一个新nf_sockopt_ops结构变量new_sockopt需要添加到nf_sockopts链表头，我们应当这样操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_add(&amp;new_sockopt.list, &amp;nf_sockopts);</span><br></pre></td></tr></table></figure></p><p>从这里我们看出，nf_sockopts链表中记录的并不是new_sockopt的地址，而是其中的list元素的地址。<br>如何通过链表访问到new_sockopt呢？下面会有详细介绍。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static inline void list_del(struct list_head *entry);</span><br></pre></td></tr></table></figure><p>当我们需要删除nf_sockopts链表中添加的new_sockopt项时，我们这么操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_del(&amp;new_sockopt.list);</span><br></pre></td></tr></table></figure></p><p>被剔除下来的new_sockopt.list，prev、next指针分别被设为LIST_POSITION2和LIST_POSITION1两个特殊值，<br>这样设置是为了保证不在链表中的节点项不可访问–对LIST_POSITION1和LIST_POSITION2的访问都将引起页故障。<br>与之相对应，list_del_init()函数将节点从链表中解下来之后，调用LIST_INIT_HEAD()将节点置为空链状态。</p><h3 id="搬移"><a href="#搬移" class="headerlink" title="搬移"></a>搬移</h3><p>Linux提供了将原本属于一个链表的节点移动到另一个链表的操作，并根据插入到新链表的位置分为两类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static inline void list_move(struct list_head *list, struct list_head *head);</span><br><span class="line">static inline void list_move_tail(struct list_head *list, struct list_head *head);</span><br></pre></td></tr></table></figure></p><p>例如list_move(&amp;new_sockopt.list,&amp;nf_sockopts)会把new_sockopt从它所在的链表上删除，并将其再链入nf_sockopts的表头。</p><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>除了针对节点的插入、删除操作，Linux链表还提供了整个链表的插入功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static inline void list_splice(struct list_head *list, struct list_head *head);</span><br></pre></td></tr></table></figure></p><p>假设当前有两个链表，表头分别是list1和list2（都是struct list_head变量），当调用list_splice(&amp;list1,&amp;list2)时，只要list1非空，list1链表的内容将被挂接在list2链表上，位于list2和list2.next（原list2表的第一个节点）之间。新list2链表将以原list1表的第一个节点为首节点，而尾节点不变。如图（虚箭头为next指针）：</p><p>图4 链表合并list_splice(&amp;list1,&amp;list2)<br><img src="https://.sinaimg.cn/large/ba061518gy1fx1lqrf07xg20fc04pmwy.gif" alt="链表合并list_splice"><br>当list1被挂接到list2之后，作为原表头指针的list1的next、prev仍然指向原来的节点，为了避免引起混乱，Linux提供了一个list_splice_init()函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static inline void list_splice_init(struct list_head *list, struct list_head *head);</span><br></pre></td></tr></table></figure></p><p>该函数在将list合并到head链表的基础上，调用INIT_LIST_HEAD(list)将list设置为空链。</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="由链表节点到数据项变量"><a href="#由链表节点到数据项变量" class="headerlink" title="由链表节点到数据项变量"></a>由链表节点到数据项变量</h3><p>我们知道，Linux链表中仅保存了数据项结构中list_head成员变量的地址，那么我们如何通过这个list_head成员访问到作为它的所有者的节点数据呢？<br>Linux为此提供了一个list_entry(ptr,type,member)宏，<br>ptr是指向该数据中list_head成员的指针，也就是存储在链表中的地址值，<br>type是数据项的类型，<br>member则是数据项类型定义中list_head成员的变量名，<br>例如，我们要访问nf_sockopts链表中首个nf_sockopt_ops变量，则如此调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_entry(nf_sockopts-&gt;next, struct nf_sockopt_ops, list);</span><br></pre></td></tr></table></figure></p><p>这里”list”正是nf_sockopt_ops结构中定义的用于链表操作的节点成员变量名。</p><p>list_entry的使用相当简单，相比之下，它的实现则有一些难懂：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define list_entry(ptr, type, member) container_of(ptr, type, member)</span><br></pre></td></tr></table></figure></p><p>container_of宏定义在[include/linux/kernel.h]中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define container_of(ptr, type, member) (&#123;          \</span><br><span class="line">        const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \</span><br><span class="line">        (type *)( (char *)__mptr - offsetof(type,member) );&#125;)</span><br></pre></td></tr></table></figure></p><p>offsetof宏定义在[include/linux/stddef.h]中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span><br></pre></td></tr></table></figure></p><p>size_t最终定义为unsigned int（i386）。</p><p>这里<code>container_of</code>使用的是一个利用编译器技术的小技巧，即先求得结构成员在与结构中的偏移量，然后根据成员变量的地址反过来得出属主结构变量的地址。</p><blockquote><p>container_of()和offsetof()并不仅用于链表操作，<br>这里最有趣的地方是<code>((type *)0)-&gt;member</code>，它将0地址强制”转换”为type结构的指针，再访问到type结构中的member成员。<br>在container_of宏中，它用来给typeof()提供参数（typeof()是gcc的扩展，和sizeof()类似），以获得member成员的数据类型；<br>在offsetof()中，这个member成员的地址实际上就是type数据结构中member成员相对于结构变量的偏移量。</p></blockquote><p>如果这么说还不好理解的话，不妨看看下面这张图：<br>图5 offsetof()宏的原理<br><img src="https://ws1.sinaimg.cn/large/ba061518gy1fx1ls58gc9g20fc05agle.gif" alt="offsetof宏原理"><br>对于给定一个结构，offsetof(type,member)是一个常量，list_entry()正是利用这个不变的偏移量来求得链表数据项的变量地址。</p><h3 id="遍历宏-list-for-each-entry"><a href="#遍历宏-list-for-each-entry" class="headerlink" title="遍历宏 list_for_each_entry()"></a>遍历宏 list_for_each_entry()</h3><p>list_for_each_entry = list_for_each() + list_entry()</p><p>在[net/core/netfilter.c]的nf_register_sockopt()函数中有这么一段话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">struct list_head *i;</span><br><span class="line">……</span><br><span class="line">    list_for_each(i, &amp;nf_sockopts) &#123;</span><br><span class="line">        struct nf_sockopt_ops *ops = (struct nf_sockopt_ops *)i;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure></p><p>函数首先定义一个<code>(struct list_head *)</code>指针变量i，然后调用list_for_each(i,&amp;nf_sockopts)进行遍历。<br>在[include/linux/list.h]中，list_for_each()宏是这么定义的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define list_for_each(pos, head) \</span><br><span class="line">for (pos = (head)-&gt;next, prefetch(pos-&gt;next); pos != (head); \</span><br><span class="line">        pos = pos-&gt;next, prefetch(pos-&gt;next))</span><br></pre></td></tr></table></figure></p><p>它实际上是一个for循环，利用传入的pos作为循环变量，从表头head开始，逐项向后（next方向）移动pos，直至又回到head（prefetch()可以不考虑，用于预取以提高遍历速度）。</p><p>那么在nf_register_sockopt()中实际上就是遍历nf_sockopts链表。为什么能直接将获得的list_head成员变量地址当成struct nf_sockopt_ops数据项变量的地址呢？我们注意到在struct nf_sockopt_ops结构中，list是其中的第一项成员，因此，它的地址也就是结构变量的地址。更规范的获得数据变量地址的用法应该是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct nf_sockopt_ops *ops = list_entry(i, struct nf_sockopt_ops, list);</span><br></pre></td></tr></table></figure></p><p>大多数情况下，遍历链表的时候都需要获得链表节点数据项，也就是说list_for_each()和list_entry()总是同时使用。</p><p>对此Linux给出了一个<code>list_for_each_entry()</code>宏：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define list_for_each_entry(pos, head, member)      ……</span><br></pre></td></tr></table></figure></p><p>与list_for_each()不同，这里的pos是数据项结构指针类型，而不是<code>(struct list_head *)</code>。<br>nf_register_sockopt()函数可以利用这个宏而设计得更简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">struct nf_sockopt_ops *ops;</span><br><span class="line">list_for_each_entry(ops,&amp;nf_sockopts,list)&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure></p><p>某些应用需要反向遍历链表，Linux提供了list_for_each_prev()和list_for_each_entry_reverse()来完成这一操作，使用方法和上面介绍的list_for_each()、list_for_each_entry()完全相同。</p><p>如果遍历不是从链表头开始，而是从已知的某个节点pos开始，则可以使用list_for_each_entry_continue(pos,head,member)。有时还会出现这种需求，即经过一系列计算后，如果pos有值，则从pos开始遍历，如果没有，则从链表头开始，为此，Linux专门提供了一个list_prepare_entry(pos,head,member)宏，将它的返回值作为list_for_each_entry_continue()的pos参数，就可以满足这一要求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;前提是假设大家有链表的基础&lt;br&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/kernel/l-chain/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://iyounix.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux Input 子系统分析</title>
    <link href="http://iyounix.com/2018/11/08/Linux/Linux%20Input%20%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/"/>
    <id>http://iyounix.com/2018/11/08/Linux/Linux Input 子系统分析/</id>
    <published>2018-11-08T13:00:00.000Z</published>
    <updated>2018-11-09T07:20:33.367Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h2><p>Input 子系统从上到下分为三层实现, 分别为 事件处理层 EventHandler / 核心层 InputCore / 驱动层 Driver<br><img src="http://my.csdn.net/uploads/201207/29/1343543828_9978.png" alt=""></p><p><strong>Driver 层</strong>: 硬件设备读写访问, 中断设置 , 将硬件产生的事件转换为核心层定义的规范提交给 EventHandler.<br><strong>InputCore 层</strong>: 为设备驱动层提供了规范和接口。<br>设备驱动层只要关心如何驱动硬件并获得硬件数据（例如按下的按键数据），然后调用核心层提供的接口，核心层会自动把数据提交给事件处理层。<br><strong>EventHandler 层</strong>: 用户编程的接口（设备节点），并处理驱动层提交的数据处理。</p><h2 id="驱动层流程"><a href="#驱动层流程" class="headerlink" title="驱动层流程"></a>驱动层流程</h2><p>驱动开发的工作:</p><ul><li>设置 input 设备支持的事件类型 (EV_SYN / EV_KEY 等)</li><li>注册中断处理函数</li><li>输入设备注册到输入子系统中</li></ul><p>整体的流程是:</p><ol><li><p>注册初始化, button_init 将被用于 insmod 或者 内核引导过程中 的调用<br>主要负责硬件设备资源 ( 内存 / IO内存 / 中断 / DMA ) 的获取.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module_init(button_init)</span><br></pre></td></tr></table></figure></li><li><p>在 button_init 中获取中断, 注册中断<br>当有键被按下 / 松开时 , 调用 button_interrupt 中断处理函数获取按键值 BUTTON_PORT</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request_irq(BUTTON_IRQ, button_interrupt, 0, &quot;button&quot;, NULL)</span><br></pre></td></tr></table></figure></li></ol><p>在 <code>button_interrupt</code> 中完成按键事件的上报需要两步: 1. <code>input_report_key</code> 2.<code>input_sync</code> .<br>这里因为只有一个按键事件, 所以体现不出 input_sync 的作用.<br>但是如果是 TP 事件, 在上报了 x y 坐标后, 需要 input_sync 将 x 和 y 完整地传给 input 子系统.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static irqreturn_t button_interrupt(int irq, void *dummy)</span><br><span class="line">&#123;</span><br><span class="line">input_report_key(button_dev, BTN_0, inb(BUTTON_PORT) &amp; 1);</span><br><span class="line">input_sync(button_dev);</span><br><span class="line">return IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li><p>注册input设备<br>由 InputCore (input.c) 中的 API 分配一个输入设备</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static struct input_dev *button_dev;</span><br><span class="line">button_dev=input_allocate_device();</span><br></pre></td></tr></table></figure></li><li><p>设置事件产生时候的事件类型<br><code>evbit</code> 事件产生时的事件类型(EV_KEY)<br><code>keybit</code>事件上报的按键值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">button_dev-&gt;evbit[0]= BIT(EV_KEY);</span><br><span class="line">button_dev-&gt;keybit[LONG(BTN_0)]= BIT(BTN_0); //#defineLONG(x) ((x)/BITS_PER_LONG) //返回位x的索引</span><br></pre></td></tr></table></figure></li><li><p>注册为输入设备</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input_register_device(button_dev);</span><br></pre></td></tr></table></figure></li></ol><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>Demo 是只有一个按键的设备. 当按压或者释放按键的时候, 会发出 BUTTON_IRQ 中断.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/input.h&gt;</span><br><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;asm/irq.h&gt;</span><br><span class="line">#include &lt;asm/io.h&gt;</span><br><span class="line"></span><br><span class="line">static struct input_dev *button_dev;</span><br><span class="line"></span><br><span class="line">static irqreturn_t button_interrupt(int irq, void *dummy)</span><br><span class="line">&#123;</span><br><span class="line">input_report_key(button_dev, BTN_0, inb(BUTTON_PORT) &amp; 1);</span><br><span class="line">input_sync(button_dev);</span><br><span class="line">return IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int __init button_init(void)</span><br><span class="line">&#123;</span><br><span class="line">int error;</span><br><span class="line">//注册中断</span><br><span class="line">if (request_irq(BUTTON_IRQ, button_interrupt, 0, &quot;button&quot;, NULL)) &#123;</span><br><span class="line">                printk(KERN_ERR &quot;button.c: Can&apos;t allocate irq %d\n&quot;, button_irq);</span><br><span class="line">                return -EBUSY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">button_dev = input_allocate_device();</span><br><span class="line">if (!button_dev) &#123;</span><br><span class="line">printk(KERN_ERR &quot;button.c: Not enough memory\n&quot;);</span><br><span class="line">error = -ENOMEM;</span><br><span class="line">goto err_free_irq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button_dev-&gt;evbit[0] = BIT_MASK(EV_KEY);</span><br><span class="line">button_dev-&gt;keybit[BIT_WORD(BTN_0)] = BIT_MASK(BTN_0);</span><br><span class="line"></span><br><span class="line">//注册input设备</span><br><span class="line">error = input_register_device(button_dev);</span><br><span class="line">if (error) &#123;</span><br><span class="line">printk(KERN_ERR &quot;button.c: Failed to register device\n&quot;);</span><br><span class="line">goto err_free_dev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line"> err_free_dev:</span><br><span class="line">input_free_device(button_dev);</span><br><span class="line"> err_free_irq:</span><br><span class="line">free_irq(BUTTON_IRQ, button_interrupt);</span><br><span class="line">return error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit button_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">        input_unregister_device(button_dev);</span><br><span class="line">free_irq(BUTTON_IRQ, button_interrupt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(button_init);</span><br><span class="line">module_exit(button_exit);</span><br></pre></td></tr></table></figure></p><h2 id="深入分析"><a href="#深入分析" class="headerlink" title="深入分析"></a>深入分析</h2><h3 id="Input-Initial"><a href="#Input-Initial" class="headerlink" title="Input Initial"></a>Input Initial</h3><ol><li>InputCore 初始化 </li><li>InputHandler 初始化 </li><li>InputDevice 初始化 </li><li>Core 将 Handler 和 Device 进行关联<h4 id="1-InputCore-初始化"><a href="#1-InputCore-初始化" class="headerlink" title="1. InputCore 初始化"></a>1. InputCore 初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static int __init input_init(void)</span><br><span class="line">&#123;</span><br><span class="line">int err;</span><br><span class="line">//1. 在设备模型 /sys/class 目录注册设备类</span><br><span class="line">err = class_register(&amp;input_class);</span><br><span class="line">//2. 在 /proc/bus/input 目录产生设备信息</span><br><span class="line">err = input_proc_init();</span><br><span class="line">//3. 字符设备驱动框架注册 input 子系统的接口操作集合</span><br><span class="line">err = register_chrdev_region(MKDEV(INPUT_MAJOR, 0),</span><br><span class="line">     INPUT_MAX_CHAR_DEVICES, &quot;input&quot;);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-InputHandler-初始化"><a href="#2-InputHandler-初始化" class="headerlink" title="2. InputHandler 初始化"></a>2. InputHandler 初始化</h4><p>拿 TP 的 event-handler 为例 (evdev.c)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static const struct input_device_id evdev_ids[] = &#123; //设备 ID</span><br><span class="line">&#123; .driver_info = 1 &#125;,/* Matches all devices */</span><br><span class="line">&#123; &#125;,/* Terminating zero entry */</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(input, evdev_ids);</span><br><span class="line">static struct input_handler evdev_handler = &#123;</span><br><span class="line">.event= evdev_event, </span><br><span class="line">.events= evdev_events,  // 消息处理接口</span><br><span class="line">.connect= evdev_connect, // InputCore 匹配到 device 后调用本接口 , 后面会详细分析</span><br><span class="line">.disconnect= evdev_disconnect,</span><br><span class="line">.legacy_minors= true, </span><br><span class="line">.minor= EVDEV_MINOR_BASE, //64 event-handler 处理的次设备号的起始点</span><br><span class="line">.name= &quot;evdev&quot;,          //handler 的名称</span><br><span class="line">.id_table= evdev_ids,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init evdev_init(void)</span><br><span class="line">&#123;</span><br><span class="line">// input-core 提供的接口, 供 input-handler 注册自己</span><br><span class="line">return input_register_handler(&amp;evdev_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">input_register_handler</span><br><span class="line">    INIT_LIST_HEAD</span><br><span class="line">list_add_tail//加入input_handler_list全局链表</span><br><span class="line">//遍历input_dev_list全局设备链表,寻找该handler支持的设备</span><br><span class="line">list_for_each_entry(dev, &amp;input_dev_list, node)input_attach_handler(dev, handler);</span><br></pre></td></tr></table></figure><p><code>evdev_connect</code> 的调用流程, 关键是注册了 fops.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">evdev_connect</span><br><span class="line">    input_get_new_minor //获取 minor 号</span><br><span class="line">device_initialize</span><br><span class="line">    input_register_handle //注册新的 input handle</span><br><span class="line">cdev_init(&amp;evdev-&gt;cdev, &amp;evdev_fops); //很关键, 注册fops, fops我们在后面单独说</span><br><span class="line">cdev_add</span><br><span class="line">device_add</span><br></pre></td></tr></table></figure></p><p>fops 如下, 包括了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static const struct file_operations evdev_fops = &#123;</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">.read= evdev_read,</span><br><span class="line">.write= evdev_write,</span><br><span class="line">.poll= evdev_poll,</span><br><span class="line">.open= evdev_open,</span><br><span class="line">.release= evdev_release,</span><br><span class="line">.unlocked_ioctl= evdev_ioctl,</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">.compat_ioctl= evdev_ioctl_compat,</span><br><span class="line">#endif</span><br><span class="line">.fasync= evdev_fasync,</span><br><span class="line">.flush= evdev_flush,</span><br><span class="line">.llseek= no_llseek,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="3-InputDevice-初始化"><a href="#3-InputDevice-初始化" class="headerlink" title="3. InputDevice 初始化"></a>3. InputDevice 初始化</h4><p>这里因设备而异. 比如拿汇顶的 TouchScreen IC GT911 来举例.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tpd_driver_init</span><br><span class="line">    tpd_get_dts_info</span><br><span class="line">tpd_driver_add(&amp;tpd_device_driver) &lt; 0)</span><br><span class="line"></span><br><span class="line">tpd_probe</span><br><span class="line">    input_register_device</span><br></pre></td></tr></table></figure></p><p><code>tpd_driver_add(&amp;tpd_device_driver) &lt; 0)</code><br>将 tpd_device_driver 添加到 tpd_driver_list 链表中, 关键是<code>tpd_driver_list[i].tpd_local_init = tpd_drv-&gt;tpd_local_init;</code><br>在 tp device 和 driver match 的时候, 会执行 tpd_probe , 通过 tpd_driver_list 中的 tpd_local_init 找到初始化过程中 device需要进行的动作 (初始化寄存器等)</p><h4 id="4-InputCore-和-InputHander-关联匹配"><a href="#4-InputCore-和-InputHander-关联匹配" class="headerlink" title="4. InputCore 和 InputHander 关联匹配"></a>4. InputCore 和 InputHander 关联匹配</h4><p>在 input_register_handler 和 input_register_device 最后都会使用 input_attach_handler 接口来匹配输入设备和对应的事件处理者。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)</span><br><span class="line">&#123;</span><br><span class="line">const struct input_device_id *id;</span><br><span class="line">int error;</span><br><span class="line">//匹配 handler 和 device 的 ID, event handler 默认处理所有事件类型的设备</span><br><span class="line">id = input_match_device(handler, dev);</span><br><span class="line">//匹配成功后调用 handler 的 connect 接口 (evdev_connect)</span><br><span class="line">error = handler-&gt;connect(handler, dev, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;框架结构&quot;&gt;&lt;a href=&quot;#框架结构&quot; class=&quot;headerlink&quot; title=&quot;框架结构&quot;&gt;&lt;/a&gt;框架结构&lt;/h2&gt;&lt;p&gt;Input 子系统从上到下分为三层实现, 分别为 事件处理层 EventHandler / 核心层
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://iyounix.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>组件_Service.md</title>
    <link href="http://iyounix.com/2018/11/08/Android_App/%E7%BB%84%E4%BB%B6_Service/"/>
    <id>http://iyounix.com/2018/11/08/Android_App/组件_Service/</id>
    <published>2018-11-08T03:20:49.990Z</published>
    <updated>2018-10-21T02:08:51.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Service 是 Android 中实现程序后台运行的解决方案,<br>适合执行那些不需要和用户交互而且还要求长期运行的任务.</p><p><img src="https://ws1.sinaimg.cn/large/ba061518gy1fui895t2mjj20mq0bpwg4.jpg" alt=""></p><h3 id="4个手动调用的方法"><a href="#4个手动调用的方法" class="headerlink" title="4个手动调用的方法"></a>4个手动调用的方法</h3><p>startService()    启动服务, 手动调用 startService() 后，自动调用内部方法：onCreate()、onStartCommand().<br>stopService()    关闭服务, 手动调用 stopService() 后，自动调用内部方法：onDestory(). 但是如果没有解绑, 是无法停止服务的<br>bindService()    绑定服务, 手动调用 bindService()后，自动调用内部方法：onCreate()、onBind().<br>unbindService()    解绑服务, 手动调用 unbindService()后，自动调用内部方法：onCreate()、onBind()、onDestory()</p><h3 id="内部自动调用的方法"><a href="#内部自动调用的方法" class="headerlink" title="内部自动调用的方法"></a>内部自动调用的方法</h3><p>onCreat()    创建服务<br>onStartCommand()    开始服务<br>onDestroy()    销毁服务<br>onBind()    绑定服务<br>onUnbind()    解绑服务</p><h3 id="重要知识点"><a href="#重要知识点" class="headerlink" title="重要知识点"></a>重要知识点</h3><p>startService()和 stopService()只能开启和关闭Service，无法操作Service；<br>bindService()和 unbindService()可以操作 Service</p><p>startService() 开启的Service，调用者退出后Service仍然存在；<br>BindService() 开启的Service，调用者退出后，Service随着调用者销毁。</p><h2 id="只使用-startService-启动服务的生命周期"><a href="#只使用-startService-启动服务的生命周期" class="headerlink" title="只使用 startService 启动服务的生命周期"></a>只使用 startService 启动服务的生命周期</h2><p>手动 startService()<br>onCreate()<br>onStartCommand()<br>手动 stopService()<br>onDestory()</p><h2 id="只使用-bindService-绑定服务的生命周期"><a href="#只使用-bindService-绑定服务的生命周期" class="headerlink" title="只使用 bindService 绑定服务的生命周期"></a>只使用 bindService 绑定服务的生命周期</h2><p>手动 bindService()<br>onCreate()<br>onBind()<br>手动 unBindService()<br>onUnbind()<br>onDestory()</p><h2 id="同时使用-startService-BindService-服务的生命周期"><a href="#同时使用-startService-BindService-服务的生命周期" class="headerlink" title="同时使用 startService BindService 服务的生命周期"></a>同时使用 startService BindService 服务的生命周期</h2><p>手动 startService()<br>onCreate()<br>onStartCommand()<br>手动 BindService()<br>onBind()<br>手动 unBindService()<br>onUnbind()<br>手动 StopService()<br>onDestory()</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;Service 是 Android 中实现程序后台运行的解决方案,&lt;br&gt;适合执行那些不需要和用户交互而且还要求长期运行的任
      
    
    </summary>
    
    
      <category term="android" scheme="http://iyounix.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>SOP_全局获取Context方法</title>
    <link href="http://iyounix.com/2018/08/11/Android_App/SOP_%E5%85%A8%E5%B1%80%E8%8E%B7%E5%8F%96Context%E6%96%B9%E6%B3%95/"/>
    <id>http://iyounix.com/2018/08/11/Android_App/SOP_全局获取Context方法/</id>
    <published>2018-08-11T03:12:05.000Z</published>
    <updated>2018-11-08T03:34:58.113Z</updated>
    
    <content type="html"><![CDATA[<p>利用 Application 类.<br>当应用程序启动时 , 系统会自动对 Applicaiton 类进行初始化.<br>我们可以定制自己的一个 Application 类, 以便于管理程序内的 <strong>全局状态信息</strong>.</p><h3 id="自定义-WholeApplication-类"><a href="#自定义-WholeApplication-类" class="headerlink" title="自定义 WholeApplication 类"></a>自定义 WholeApplication 类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class WholeApplication extends Application &#123;</span><br><span class="line">private static Context context;</span><br><span class="line">    </span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">    context = getApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static Context getContext() &#123;</span><br><span class="line">    return context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="告知系统-程序启动时应该初始化-WholeApplication-而不是-Application"><a href="#告知系统-程序启动时应该初始化-WholeApplication-而不是-Application" class="headerlink" title="告知系统,程序启动时应该初始化 WholeApplication 而不是 Application"></a>告知系统,程序启动时应该初始化 WholeApplication 而不是 Application</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span> </span></span><br><span class="line"><span class="tag"><span class="attr">android:name</span>=<span class="string">"com.iyounix.practice.wholeapplication"</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>任何想要用到 context 的地方 , 使用 WholeApplication.getContext() , 比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Toast.makeText(WholeApplication.getContext(), &quot;test&quot; , Toast.LENGTH_SHORT).show();</span><br></pre></td></tr></table></figure></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>比如为了让 litepal 正常工作 , 需要声明 :<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span> </span></span><br><span class="line"><span class="tag"><span class="attr">android:name</span>=<span class="string">"org.litepal.LitePalApplication"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>并且在 WholeApplication 的 onCreate() 中初始化:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void onCreate() &#123;</span><br><span class="line">context = getApplicationContext();</span><br><span class="line">    LitePalApplication.initialize(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;利用 Application 类.&lt;br&gt;当应用程序启动时 , 系统会自动对 Applicaiton 类进行初始化.&lt;br&gt;我们可以定制自己的一个 Application 类, 以便于管理程序内的 &lt;strong&gt;全局状态信息&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&quot;自
      
    
    </summary>
    
    
      <category term="RockChip" scheme="http://iyounix.com/tags/RockChip/"/>
    
      <category term="Android" scheme="http://iyounix.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>SOP_WebView_XML和JSON</title>
    <link href="http://iyounix.com/2018/08/11/Android_App/SOP_WebView_XML%E5%92%8CJSON/"/>
    <id>http://iyounix.com/2018/08/11/Android_App/SOP_WebView_XML和JSON/</id>
    <published>2018-08-11T03:12:05.000Z</published>
    <updated>2018-11-08T03:35:15.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>两种解析方法</p><h2 id="JSONObject"><a href="#JSONObject" class="headerlink" title="JSONObject"></a>JSONObject</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void parseJSONWithJSONObject(String jsonData) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 定义 JASON 数组 , 将服务器返回的数据传入到了 JSONObject 对象中</span><br><span class="line">            JSONArray jsonArray = new JSONArray(jsonData);</span><br><span class="line">            for(int i = 0; i &lt; jsonArray.length(); i++) &#123;</span><br><span class="line">                JSONObject jsonObject = jsonArray.getJSONObject(i);</span><br><span class="line">                String id = jsonObject.getString(&quot;id&quot;);</span><br><span class="line">                String name = jsonObject.getString(&quot;name&quot;);</span><br><span class="line">                String version = jsonObject.getString(&quot;version&quot;);</span><br><span class="line"></span><br><span class="line">                Log.d(TAG, &quot;parseJSONWithJSONObject: id is &quot;+id);</span><br><span class="line">                Log.d(TAG, &quot;parseJSONWithJSONObject: name is &quot;+name);</span><br><span class="line">                Log.d(TAG, &quot;parseJSONWithJSONObject: version is &quot;+version);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (JSONException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GSON"><a href="#GSON" class="headerlink" title="GSON"></a>GSON</h2><p>比如要解析 App 类型的数据</p><ol><li>先实现 App 类:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    private String id;</span><br><span class="line">    private String name;</span><br><span class="line">    private String version;</span><br><span class="line"></span><br><span class="line">    public String getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getVersion() &#123;</span><br><span class="line">        return version;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(String id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setVersion(String version) &#123;</span><br><span class="line">        this.version = version;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>然后直接利用 json 创建对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void parseJSONWithGSON(String jsonData) &#123;</span><br><span class="line">    Gson gson = new Gson();</span><br><span class="line">    List&lt;App&gt; appList = gson.fromJson(jsonData, new TypeToken&lt;List&lt;App&gt;&gt;()&#123;&#125;.getType());</span><br><span class="line">    for (App app : appList) &#123;</span><br><span class="line">        Log.d(TAG, &quot;parseJSONWithGSON: id is &quot; + app.getId());</span><br><span class="line">        Log.d(TAG, &quot;parseJSONWithGSON: name is &quot; + app.getName());</span><br><span class="line">        Log.d(TAG, &quot;parseJSONWithGSON: version is &quot; + app.getVersion());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="Pull-解析"><a href="#Pull-解析" class="headerlink" title="Pull 解析"></a>Pull 解析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseXMLWithPull</span><span class="params">(String xmlData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 工厂类 , 借助工厂类实例的 nuwPullParser() 获得 XmlPullParse 的实例</span></span><br><span class="line">            XmlPullParserFactory factory = XmlPullParserFactory.newInstance();</span><br><span class="line">            XmlPullParser xmlPullParser = factory.newPullParser();</span><br><span class="line">            <span class="comment">// 2. setInput() 将服务器返回的 XML 数据 (xmlData) 设置进去并开始解析</span></span><br><span class="line">            xmlPullParser.setInput(<span class="keyword">new</span> StringReader(xmlData));</span><br><span class="line">            <span class="comment">// 3. 开始解析</span></span><br><span class="line">            <span class="comment">// 3.1 getEventType() 获取当前的解析事件</span></span><br><span class="line">            <span class="keyword">int</span> eventType = xmlPullParser.getEventType();</span><br><span class="line">            String id = <span class="string">""</span>;</span><br><span class="line">            String name = <span class="string">""</span>;</span><br><span class="line">            String version = <span class="string">""</span>;</span><br><span class="line">            <span class="comment">// 3.2 循环解析当前节点 直到 文件结束</span></span><br><span class="line">            <span class="keyword">while</span> (eventType != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                String nodeName = xmlPullParser.getName();</span><br><span class="line">                <span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">                    <span class="comment">// 开始解析某个节点</span></span><br><span class="line">                    <span class="keyword">case</span> XmlPullParser.START_TAG: &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">"id"</span>.equals(nodeName))&#123;</span><br><span class="line">                            id = xmlPullParser.nextText();</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"version"</span>.equals(nodeName)) &#123;</span><br><span class="line">                            version = xmlPullParser.nextText();</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"name"</span>.equals(nodeName)) &#123;</span><br><span class="line">                            name = xmlPullParser.nextText();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 完成解析某个节点</span></span><br><span class="line">                    <span class="keyword">case</span> XmlPullParser.END_TAG: &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">"app"</span>.equals(nodeName)) &#123;</span><br><span class="line">                            Log.d(TAG, <span class="string">"parseXMLWithPull id is "</span> + id);</span><br><span class="line">                            Log.d(TAG, <span class="string">"parseXMLWithPull name is "</span> + name);</span><br><span class="line">                            Log.d(TAG, <span class="string">"parseXMLWithPull version is"</span> + version);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                eventType =  xmlPullParser.next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="SAX-解析"><a href="#SAX-解析" class="headerlink" title="SAX 解析"></a>SAX 解析</h2><p>MainActivity.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void parseXMLWithSAX(String xmlData) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 创建工厂类</span><br><span class="line">            SAXParserFactory factory = SAXParserFactory.newInstance();</span><br><span class="line">            // 通过工厂类获取 XMLReader 对象</span><br><span class="line">            XMLReader xmlReader = factory.newSAXParser().getXMLReader();</span><br><span class="line"></span><br><span class="line">            ContentHandler handler = new ContentHandler();</span><br><span class="line">            //设置 ContentHanlder 实例到 XMLReader 中</span><br><span class="line">            xmlReader.setContentHandler(handler);</span><br><span class="line">            //开始执行解析</span><br><span class="line">            xmlReader.parse(new InputSource(new StringReader(xmlData)));</span><br><span class="line">        &#125; catch (SAXException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ParserConfigurationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>ContentHandler.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class ContentHandler extends DefaultHandler &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG = &quot;ContentHandler&quot;;</span><br><span class="line"></span><br><span class="line">    private String nodeName;</span><br><span class="line">    private StringBuilder id;</span><br><span class="line">    private StringBuilder name;</span><br><span class="line">    private StringBuilder version;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Receive notification of the beginning of the document.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * &lt;p&gt;By default, do nothing.  Application writers may override this</span><br><span class="line">     * method in a subclass to take specific actions at the beginning</span><br><span class="line">     * of a document (such as allocating the root node of a tree or</span><br><span class="line">     * creating an output file).&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * @throws SAXException Any SAX exception, possibly</span><br><span class="line">     *                      wrapping another exception.</span><br><span class="line">     * @see org.xml.sax.ContentHandler#startDocument</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void startDocument() throws SAXException &#123;</span><br><span class="line">        id = new StringBuilder();</span><br><span class="line">        name = new StringBuilder();</span><br><span class="line">        version = new StringBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Receive notification of the end of the document.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * &lt;p&gt;By default, do nothing.  Application writers may override this</span><br><span class="line">     * method in a subclass to take specific actions at the end</span><br><span class="line">     * of a document (such as finalising a tree or closing an output</span><br><span class="line">     * file).&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * @throws SAXException Any SAX exception, possibly</span><br><span class="line">     *                      wrapping another exception.</span><br><span class="line">     * @see org.xml.sax.ContentHandler#endDocument</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void endDocument() throws SAXException &#123;</span><br><span class="line">        super.endDocument();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Receive notification of the start of an element.</span><br><span class="line">     * 记录当前节点名字</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * &lt;p&gt;By default, do nothing.  Application writers may override this</span><br><span class="line">     * method in a subclass to take specific actions at the start of</span><br><span class="line">     * each element (such as allocating a new tree node or writing</span><br><span class="line">     * output to a file).&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param uri        The Namespace URI, or the empty string if the</span><br><span class="line">     *                   element has no Namespace URI or if Namespace</span><br><span class="line">     *                   processing is not being performed.</span><br><span class="line">     * @param localName  The local name (without prefix), or the</span><br><span class="line">     *                   empty string if Namespace processing is not being</span><br><span class="line">     *                   performed.</span><br><span class="line">     * @param qName      The qualified name (with prefix), or the</span><br><span class="line">     *                   empty string if qualified names are not available.</span><br><span class="line">     * @param attributes The attributes attached to the element.  If</span><br><span class="line">     *                   there are no attributes, it shall be an empty</span><br><span class="line">     *                   Attributes object.</span><br><span class="line">     * @throws SAXException Any SAX exception, possibly</span><br><span class="line">     *                      wrapping another exception.</span><br><span class="line">     * @see org.xml.sax.ContentHandler#startElement</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123;</span><br><span class="line">        // 记录当前节点名字</span><br><span class="line">        nodeName = localName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Receive notification of character data inside an element.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * &lt;p&gt;By default, do nothing.  Application writers may override this</span><br><span class="line">     * method to take specific actions for each chunk of character data</span><br><span class="line">     * (such as adding the data to a node or buffer, or printing it to</span><br><span class="line">     * a file).&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param ch     The characters.</span><br><span class="line">     * @param start  The start position in the character array.</span><br><span class="line">     * @param length The number of characters to use from the</span><br><span class="line">     *               character array.</span><br><span class="line">     * @throws SAXException Any SAX exception, possibly</span><br><span class="line">     *                      wrapping another exception.</span><br><span class="line">     * @see org.xml.sax.ContentHandler#characters</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void characters(char[] ch, int start, int length) throws SAXException &#123;</span><br><span class="line">        // 根据当前的节点名判断将内容添加到哪一个 StringBuilder 中</span><br><span class="line">        if (&quot;id&quot;.equals(nodeName)) &#123;</span><br><span class="line">            id.append(ch, start, length);</span><br><span class="line">        &#125; else if (&quot;name&quot;.equals(nodeName)) &#123;</span><br><span class="line">            name.append(ch, start, length);</span><br><span class="line">        &#125; else if (&quot;version&quot;.equals(nodeName)) &#123;</span><br><span class="line">            version.append(ch, start, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Receive notification of the end of an element.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * &lt;p&gt;By default, do nothing.  Application writers may override this</span><br><span class="line">     * method in a subclass to take specific actions at the end of</span><br><span class="line">     * each element (such as finalising a tree node or writing</span><br><span class="line">     * output to a file).&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param uri       The Namespace URI, or the empty string if the</span><br><span class="line">     *                  element has no Namespace URI or if Namespace</span><br><span class="line">     *                  processing is not being performed.</span><br><span class="line">     * @param localName The local name (without prefix), or the</span><br><span class="line">     *                  empty string if Namespace processing is not being</span><br><span class="line">     *                  performed.</span><br><span class="line">     * @param qName     The qualified name (with prefix), or the</span><br><span class="line">     *                  empty string if qualified names are not available.</span><br><span class="line">     * @throws SAXException Any SAX exception, possibly</span><br><span class="line">     *                      wrapping another exception.</span><br><span class="line">     * @see org.xml.sax.ContentHandler#endElement</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void endElement(String uri, String localName, String qName) throws SAXException &#123;</span><br><span class="line">        if (&quot;app&quot;.equals(localName)) &#123;</span><br><span class="line">            Log.d(TAG, &quot;endElement: id is &quot; + id.toString().trim());</span><br><span class="line">            Log.d(TAG, &quot;endElement: name is &quot; + name.toString().trim());</span><br><span class="line">            Log.d(TAG, &quot;endElement: version is &quot; + version.toString().trim());</span><br><span class="line">            // 最后将 StringBuilder 清空</span><br><span class="line">            id.setLength(0);</span><br><span class="line">            name.setLength(0);</span><br><span class="line">            version.setLength(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JSON&quot;&gt;&lt;a href=&quot;#JSON&quot; class=&quot;headerlink&quot; title=&quot;JSON&quot;&gt;&lt;/a&gt;JSON&lt;/h1&gt;&lt;p&gt;两种解析方法&lt;/p&gt;
&lt;h2 id=&quot;JSONObject&quot;&gt;&lt;a href=&quot;#JSONObject&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="RockChip" scheme="http://iyounix.com/tags/RockChip/"/>
    
      <category term="Android" scheme="http://iyounix.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>SOP_动态权限</title>
    <link href="http://iyounix.com/2018/08/11/Android_App/SOP_%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90/"/>
    <id>http://iyounix.com/2018/08/11/Android_App/SOP_动态权限/</id>
    <published>2018-08-11T03:12:05.000Z</published>
    <updated>2018-11-08T03:34:48.649Z</updated>
    
    <content type="html"><![CDATA[<p>在程序运行的过程中由用户去授权执行某些可能是危险的的操作.</p><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ol><li><p>检查权限<br>ContextCompat.checkSelfPermission<br>参数 1 Context<br>参数 2 具体的权限名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.CALL_PHONE)</span><br><span class="line"></span><br><span class="line">判断有无权限:</span><br><span class="line">ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.CALL_PHONE) </span><br><span class="line"> != PackageManager.PERMISSION_GRANTED</span><br></pre></td></tr></table></figure></li><li><p>申请权限<br>ActivityCompat.requestPermissions<br>参数 1 Context<br>参数 2 权限名<br>参数 3 自定义权限码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123; Manifest.permission.CALL_PHONE &#125;, 1)</span><br></pre></td></tr></table></figure></li></ol><p>之后系统会弹出权限申请对话框, 再调用 onRequestPermissionResult .<br>授权结果会封装在 grantResults 参数中</p><ol start="3"><li>回调<br>onRequestPermissionResult<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void onRequestPermissionsResult ( int requestCode, String[] permissions , int[] grantResults) &#123;</span><br><span class="line">    switch (requestCode) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            if(grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                call();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Toast.makeText(this, &quot;You denied the permission&quot; , Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在程序运行的过程中由用户去授权执行某些可能是危险的的操作.&lt;/p&gt;
&lt;h2 id=&quot;实现步骤&quot;&gt;&lt;a href=&quot;#实现步骤&quot; class=&quot;headerlink&quot; title=&quot;实现步骤&quot;&gt;&lt;/a&gt;实现步骤&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;检查权限&lt;br&gt;ContextC
      
    
    </summary>
    
    
      <category term="RockChip" scheme="http://iyounix.com/tags/RockChip/"/>
    
      <category term="Android" scheme="http://iyounix.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>SOP_多线程编程</title>
    <link href="http://iyounix.com/2018/08/11/Android_App/SOP_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://iyounix.com/2018/08/11/Android_App/SOP_多线程编程/</id>
    <published>2018-08-11T03:12:05.000Z</published>
    <updated>2018-11-08T03:34:40.109Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通过实现-Runnable-接口的实例来创建线程"><a href="#通过实现-Runnable-接口的实例来创建线程" class="headerlink" title="通过实现 Runnable 接口的实例来创建线程"></a>通过实现 Runnable 接口的实例来创建线程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class RunnableDemo implements Runnable &#123;</span><br><span class="line">   private Thread t;</span><br><span class="line">   private String threadName;</span><br><span class="line">   </span><br><span class="line">   RunnableDemo( String name) &#123;</span><br><span class="line">      threadName = name;</span><br><span class="line">      System.out.println(&quot;Creating &quot; +  threadName );</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void run() &#123;</span><br><span class="line">      System.out.println(&quot;Running &quot; +  threadName );</span><br><span class="line">      try &#123;</span><br><span class="line">         for(int i = 4; i &gt; 0; i--) &#123;</span><br><span class="line">            System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i);</span><br><span class="line">            // 让线程睡眠一会</span><br><span class="line">            Thread.sleep(50);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;catch (InterruptedException e) &#123;</span><br><span class="line">         System.out.println(&quot;Thread &quot; +  threadName + &quot; interrupted.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(&quot;Thread &quot; +  threadName + &quot; exiting.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void start () &#123;</span><br><span class="line">      System.out.println(&quot;Starting &quot; +  threadName );</span><br><span class="line">      if (t == null) &#123;</span><br><span class="line">         t = new Thread (this, threadName);</span><br><span class="line">         t.start ();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class TestThread &#123;</span><br><span class="line"> </span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line">      RunnableDemo R1 = new RunnableDemo( &quot;Thread-1&quot;);</span><br><span class="line">      R1.start();</span><br><span class="line">      </span><br><span class="line">      RunnableDemo R2 = new RunnableDemo( &quot;Thread-2&quot;);</span><br><span class="line">      R2.start();</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过-Runnable-接口的匿名类来创建线程"><a href="#通过-Runnable-接口的匿名类来创建线程" class="headerlink" title="通过 Runnable 接口的匿名类来创建线程"></a>通过 Runnable 接口的匿名类来创建线程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">    // 处理具体的逻辑 (耗时)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><h2 id="Thread-基本概念"><a href="#Thread-基本概念" class="headerlink" title="Thread 基本概念"></a>Thread 基本概念</h2><p>创建一个线程的第二种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。<br>继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。<br>该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>使用继承导致耦合性高 , 不如使用接口</p><h2 id="Thread-实例"><a href="#Thread-实例" class="headerlink" title="Thread 实例"></a>Thread 实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class ThreadDemo extends Thread &#123;</span><br><span class="line">   private Thread t;</span><br><span class="line">   private String threadName;</span><br><span class="line">   </span><br><span class="line">   ThreadDemo( String name) &#123;</span><br><span class="line">      threadName = name;</span><br><span class="line">      System.out.println(&quot;Creating &quot; +  threadName );</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void run() &#123; // run() 中处理具体的逻辑</span><br><span class="line">      System.out.println(&quot;Running &quot; +  threadName );</span><br><span class="line">      try &#123;</span><br><span class="line">         for(int i = 4; i &gt; 0; i--) &#123;</span><br><span class="line">            System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i);</span><br><span class="line">            // 让线程睡眠一会</span><br><span class="line">            Thread.sleep(50);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;catch (InterruptedException e) &#123;</span><br><span class="line">         System.out.println(&quot;Thread &quot; +  threadName + &quot; interrupted.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(&quot;Thread &quot; +  threadName + &quot; exiting.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void start () &#123;</span><br><span class="line">      System.out.println(&quot;Starting &quot; +  threadName );</span><br><span class="line">      if (t == null) &#123;</span><br><span class="line">         t = new Thread (this, threadName);</span><br><span class="line">         t.start ();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class TestThread &#123; </span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line">      ThreadDemo T1 = new ThreadDemo( &quot;Thread-1&quot;);</span><br><span class="line">      T1.start();</span><br><span class="line">      </span><br><span class="line">      ThreadDemo T2 = new ThreadDemo( &quot;Thread-2&quot;);</span><br><span class="line">      T2.start();</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;通过实现-Runnable-接口的实例来创建线程&quot;&gt;&lt;a href=&quot;#通过实现-Runnable-接口的实例来创建线程&quot; class=&quot;headerlink&quot; title=&quot;通过实现 Runnable 接口的实例来创建线程&quot;&gt;&lt;/a&gt;通过实现 Runnable 
      
    
    </summary>
    
    
      <category term="RockChip" scheme="http://iyounix.com/tags/RockChip/"/>
    
      <category term="Android" scheme="http://iyounix.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>SOP_控件_Fragment</title>
    <link href="http://iyounix.com/2018/08/11/Android_App/SOP_%E6%8E%A7%E4%BB%B6_Fragment/"/>
    <id>http://iyounix.com/2018/08/11/Android_App/SOP_控件_Fragment/</id>
    <published>2018-08-11T03:12:05.000Z</published>
    <updated>2018-11-08T03:36:06.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Fragment-实例"><a href="#Fragment-实例" class="headerlink" title="Fragment 实例"></a>Fragment 实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 1. 创建待添加 fragment 实例</span><br><span class="line">    replaceFragment(fragment1);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void replaceFragment(Fragment fragment) &#123;</span><br><span class="line">    // 2. 获取 FragmentManager</span><br><span class="line">    FragmentManager fragmentManager = getSupportFragmentManager();</span><br><span class="line">    // 3. 开启一个 事务 transaction</span><br><span class="line">    FragmentTransaction transaction = fragmentManager.beginTransaction();</span><br><span class="line">    // 4. 向容器内添加或者替换 fragment</span><br><span class="line">    // 参数1 容器id     参数2 待添加fragment实例</span><br><span class="line">    transaction.replace(R.id.right_layout, fragment);</span><br><span class="line"></span><br><span class="line">    // 添加到返回栈</span><br><span class="line">    // 参数为名字,用来描述返回栈的状态</span><br><span class="line">    transaction.addToBackStack(null);</span><br><span class="line"></span><br><span class="line">    // 5. 提交 事务 transaction</span><br><span class="line">    transaction.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在-onClick-中使用"><a href="#在-onClick-中使用" class="headerlink" title="在 onClick 中使用"></a>在 onClick 中使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RightFragment fragment1 = new RightFragment();</span><br><span class="line">   AnotherRightFragment fragment2 = new AnotherRightFragment();</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void onClick(View v) &#123;</span><br><span class="line">       switch (v.getId())&#123;</span><br><span class="line">           case R.id.button1:</span><br><span class="line">               replaceFragment(fragment1);</span><br><span class="line">               break;</span><br><span class="line">           case R.id.button2:</span><br><span class="line">               replaceFragment(fragment2);</span><br><span class="line">           default:</span><br><span class="line">               break;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="Fragment-和-Activity-通信"><a href="#Fragment-和-Activity-通信" class="headerlink" title="Fragment 和 Activity 通信"></a>Fragment 和 Activity 通信</h2><h3 id="在-Activity-中调用-fragment-的方法-findFragmentById"><a href="#在-Activity-中调用-fragment-的方法-findFragmentById" class="headerlink" title="在 Activity 中调用 fragment 的方法 findFragmentById"></a>在 Activity 中调用 fragment 的方法 findFragmentById</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RightFragment rightFragment = (RightFragment) getFragmentManager().findFragmentById(R.id.right_fragment);</span><br></pre></td></tr></table></figure><h3 id="在-Fragment-中调用-Activity-的方法"><a href="#在-Fragment-中调用-Activity-的方法" class="headerlink" title="在  Fragment 中调用 Activity 的方法"></a>在  Fragment 中调用 Activity 的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MainActivity activity = (MainActivity)getActivity();</span><br></pre></td></tr></table></figure><h2 id="Fragment-的生命周期"><a href="#Fragment-的生命周期" class="headerlink" title="Fragment 的生命周期"></a>Fragment 的生命周期</h2><p><img src="https://ws1.sinaimg.cn/large/ba061518ly1ftf9x1v0grj208t0nj0ui.jpg" alt="Fragment 生命周期"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Fragment-实例&quot;&gt;&lt;a href=&quot;#Fragment-实例&quot; class=&quot;headerlink&quot; title=&quot;Fragment 实例&quot;&gt;&lt;/a&gt;Fragment 实例&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
      
    
    </summary>
    
    
      <category term="RockChip" scheme="http://iyounix.com/tags/RockChip/"/>
    
      <category term="Android" scheme="http://iyounix.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>SOP_控件_AlertDialog</title>
    <link href="http://iyounix.com/2018/08/11/Android_App/SOP_%E6%8E%A7%E4%BB%B6_AlertDialog/"/>
    <id>http://iyounix.com/2018/08/11/Android_App/SOP_控件_AlertDialog/</id>
    <published>2018-08-11T03:12:05.000Z</published>
    <updated>2018-11-08T03:37:49.787Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AlertDialog.Builder builder = <span class="keyword">new</span> AlertDialog.Builder(context);</span><br><span class="line">builder.setTitle(<span class="string">"Warning"</span>);</span><br><span class="line">builder.setMessage(<span class="string">"You are forced to be offline. Please try to login again."</span>);</span><br><span class="line">builder.setCancelable(<span class="keyword">false</span>); <span class="comment">// 设置为不可取消</span></span><br><span class="line">builder.setPositiveButton(<span class="string">"OK"</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">        ActivityCollector.finishAll(); <span class="comment">// 销毁所有的活动</span></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(context , LoginActivity.class);</span><br><span class="line">        context.startActivity(intent); <span class="comment">// 重新启动 LoginActivity</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">builder.show();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="RockChip" scheme="http://iyounix.com/tags/RockChip/"/>
    
      <category term="Android" scheme="http://iyounix.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>SOP_Intent传输对象的方法</title>
    <link href="http://iyounix.com/2018/08/11/Android_App/SOP_Intent%E4%BC%A0%E8%BE%93%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://iyounix.com/2018/08/11/Android_App/SOP_Intent传输对象的方法/</id>
    <published>2018-08-11T03:12:05.000Z</published>
    <updated>2018-11-08T03:33:02.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正常的-Intent-传值的方法"><a href="#正常的-Intent-传值的方法" class="headerlink" title="正常的 Intent 传值的方法"></a>正常的 Intent 传值的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(FirstActivity.this, SecondActivity.class);</span><br><span class="line">intent.putExtra(&quot;string_data&quot;,&quot;hello&quot;);</span><br><span class="line">intent.putExtra(&quot;int_data&quot;,100);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>在 SecondActivity 众通过 getIntent 获取值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getIntent().getStringExtra(&quot;string_data&quot;);</span><br><span class="line">getIntent().getIntExtra(&quot;int_data&quot;,0);</span><br></pre></td></tr></table></figure></p><h2 id="传输对象的方法"><a href="#传输对象的方法" class="headerlink" title="传输对象的方法"></a>传输对象的方法</h2><h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>比如有这样一个 class person<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Person implements Serializable &#123;</span><br><span class="line">private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public String getName() &#123; return name; &#125;</span><br><span class="line">    public void setName() &#123; this.name = name; &#125;</span><br><span class="line">    public int getAge() &#123; return age; &#125;</span><br><span class="line">    public void setAge() &#123; this.age = age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Serializable 用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person person = new Person();</span><br><span class="line">... //初始化赋值</span><br><span class="line">Intent intent = new Intent(FirstActivity.this, SecondActivity.class);</span><br><span class="line">intent.putExtra(&quot;person_data&quot;, person);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></p><p>在 SecondActivity 众通过 getIntent 获取值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person = (Person) getIntent().getSerializableExtra(&quot;person_data&quot;);</span><br></pre></td></tr></table></figure></p><h3 id="Parcelable"><a href="#Parcelable" class="headerlink" title="Parcelable"></a>Parcelable</h3><p>需要修改 class Person:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 首先实现 Parcelable 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.1 重写 describeContents 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="comment">//2.2 重写 writeToParcel 方法, 将 Person 中的字段一一写出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    dest.writeString(name); <span class="comment">// 写出name</span></span><br><span class="line">        dest.writeInt(age);<span class="comment">// 写出age</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//3. 提供 CREATOR 常量</span></span><br><span class="line">    <span class="comment">// 创建 Parcelable.Creator 接口的一个实现, 并将泛型指定为 Person.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Person&gt; CREATOR = <span class="keyword">new</span> Parcelable.Creator&lt;Person&gt;()&#123;</span><br><span class="line">    <span class="comment">//4.1 重写 createFromParcel , 读取刚才写出的 name 和 age 字段</span></span><br><span class="line">        <span class="comment">// 注意! 顺序必须和写出顺序完全相同</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">createFromParcel</span><span class="params">(Parcel source)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">            person.name = source.readString(); <span class="comment">//读取 name</span></span><br><span class="line">            person.age = source.readInt();<span class="comment">//读取 age</span></span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.2 重写 newArray</span></span><br><span class="line">        <span class="keyword">public</span> Person[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p><p>Parcelable 用法完全一样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person person = new Person();</span><br><span class="line">... //初始化赋值</span><br><span class="line">Intent intent = new Intent(FirstActivity.this, SecondActivity.class);</span><br><span class="line">intent.putExtra(&quot;person_data&quot;, person);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></p><p>在 SecondActivity 众通过 getIntent 获取值 , 有少许差别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person = (Person) getIntent().getParcelableExtra(&quot;person_data&quot;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;正常的-Intent-传值的方法&quot;&gt;&lt;a href=&quot;#正常的-Intent-传值的方法&quot; class=&quot;headerlink&quot; title=&quot;正常的 Intent 传值的方法&quot;&gt;&lt;/a&gt;正常的 Intent 传值的方法&lt;/h2&gt;&lt;figure class=&quot;hi
      
    
    </summary>
    
    
      <category term="RockChip" scheme="http://iyounix.com/tags/RockChip/"/>
    
      <category term="Android" scheme="http://iyounix.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>SOP_Notification</title>
    <link href="http://iyounix.com/2018/08/11/Android_App/SOP_Notification/"/>
    <id>http://iyounix.com/2018/08/11/Android_App/SOP_Notification/</id>
    <published>2018-08-11T03:12:05.000Z</published>
    <updated>2018-11-08T03:35:38.433Z</updated>
    
    <content type="html"><![CDATA[<ol><li>在 Activity 中创建</li><li>在 BoardCast 中创建</li><li>在 Service 中创建</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>管理 Notification</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NotificationManager manager = (NotificationManager) Context.getSystemService(Context.NOTIFICATION_SERVICE);</span><br></pre></td></tr></table></figure></li><li><p>构造 Notification 对象<br>通过 <code>NotificationCompat.Builder</code>构造</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Notification notification = new NotificationCompat.Builder(context).build();</span><br></pre></td></tr></table></figure></li></ol><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Notification notification = new NotificationCompat.Builder(context)</span><br><span class="line">.setContentTitle(&quot;This is content title&quot;)</span><br><span class="line">    .setContentText(&quot;This is content Text&quot;)</span><br><span class="line">    .setWhen(System.currentTimeMillis()) //被通知的时间</span><br><span class="line">    .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.large_icon)</span><br><span class="line">.build();</span><br></pre></td></tr></table></figure></p><ol start="3"><li>显示通知<br>调用 NotificationManager 的 notifiy() 方法.<br>参数1 id<br>参数2 Notification 对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manager.notify(1,notificaton)</span><br></pre></td></tr></table></figure></li></ol><h2 id="更多通知技巧1"><a href="#更多通知技巧1" class="headerlink" title="更多通知技巧1"></a>更多通知技巧1</h2><p>setSound() 设置通知音频<br>setVibrate() 设置振动<br>setLights() 设置光效<br>setDefaults(NotificationCompat.DEFAULT_ALL) 根据当前手机的默认参数设置一切</p><h2 id="setSound"><a href="#setSound" class="headerlink" title="setSound()"></a>setSound()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.setSound(Uri.fromFile(new File(&quot;/system/media/audio/ringtones/Luna.ogg&quot;)))</span><br></pre></td></tr></table></figure><h2 id="setVibrate"><a href="#setVibrate" class="headerlink" title="setVibrate()"></a>setVibrate()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0] 手机静止的时长</span><br><span class="line">[1] 手机振动的时长</span><br><span class="line">[2] 手机静止的时长</span><br><span class="line">[3] 手机振动的时长</span><br></pre></td></tr></table></figure><p>比如:<br>振 1s – 静 1s – 振 1s 代码为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.setVibrate(new long[] &#123;0, 1000, 1000, 1000&#125;)</span><br></pre></td></tr></table></figure></p><p>并且 AndroidManifest.xml 里面:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot;/&gt;</span><br></pre></td></tr></table></figure></p><h2 id="setLights"><a href="#setLights" class="headerlink" title="setLights"></a>setLights</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.setLights(Color.GREEN,1000,1000)</span><br></pre></td></tr></table></figure><h2 id="更多通知技巧2"><a href="#更多通知技巧2" class="headerlink" title="更多通知技巧2"></a>更多通知技巧2</h2><p>setStyle() 构建富文本通知内容<br>setPriority() 设置通知的重要程度</p><h2 id="setStyle"><a href="#setStyle" class="headerlink" title="setStyle"></a>setStyle</h2><p>参数1. NotificationCompat.Style</p><p>默认通知显示内容有限 , 比如 text , 如果过长 只能显示局部.<br>解决方法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.setStyle(new NotificationCompat.BigTextStyle().bigText(&quot;This is a longlonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglong Text&quot;))</span><br></pre></td></tr></table></figure></p><h2 id="setPriority"><a href="#setPriority" class="headerlink" title="setPriority"></a>setPriority</h2><p>参数1.<br>PRIORITY_MIN 最低;比如用户下拉通知栏<br>PRIORITY_LOW 较低;<br>PRIORITY_DEFAULT 默认;通知栏出现小图标<br>PRIORITY_HIGH 较高; 放大,排名靠前<br>PRIORITY_MAX 最高;立刻看到与响应, 比如微信通知弹窗</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>和 Intent 类似 , 都用于指明’意图’,可以用于启动 Activity/Service/BroadCast.<br>和 Intent 不同 , Intent 立即执行 , PendingIntent 延迟执行.</p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><h3 id="1-静态获取-PendingIntent-实例"><a href="#1-静态获取-PendingIntent-实例" class="headerlink" title="1. 静态获取 PendingIntent 实例"></a>1. 静态获取 PendingIntent 实例</h3><p>getActivity()<br>getBroadcast()<br>getService()<br>参数1 Context<br>参数2 0<br>参数3 Intent对象<br>参数4 PendingIntent 行为: FLAG_ONE_SHOT FLAG_NO_CREATE FLAG_CANCEL_CURRENT FLAG_UPDATE_CURRENT</p><h3 id="2-构造器连缀一个-setContentIntent"><a href="#2-构造器连缀一个-setContentIntent" class="headerlink" title="2. 构造器连缀一个 setContentIntent"></a>2. 构造器连缀一个 setContentIntent</h3><p>NotificationCompat.Builder.setContentIntent()<br>参数 PendingIntent 对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(this, NotificationActivity.class);</span><br><span class="line">PendingIntent pi = PendingIntent.getActivity(this,  0 ,intent, 0);</span><br><span class="line">...</span><br><span class="line">Notification notification = new NotificationCompat.Builder(this)</span><br><span class="line">.setContentIntent(pi)</span><br></pre></td></tr></table></figure></p><h3 id="3-取消系统状态栏上面的通知图标"><a href="#3-取消系统状态栏上面的通知图标" class="headerlink" title="3. 取消系统状态栏上面的通知图标"></a>3. 取消系统状态栏上面的通知图标</h3><p>3.1 NotificationCompat.Builder 连缀 .setAutoCancel(true)<br>3.2 利用 Manager 的 cancel()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line">manager.cancel(1);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;在 Activity 中创建&lt;/li&gt;
&lt;li&gt;在 BoardCast 中创建&lt;/li&gt;
&lt;li&gt;在 Service 中创建&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="RockChip" scheme="http://iyounix.com/tags/RockChip/"/>
    
      <category term="Android" scheme="http://iyounix.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>SOP_MediaPlayer</title>
    <link href="http://iyounix.com/2018/08/11/Android_App/SOP_MediaPlayer/"/>
    <id>http://iyounix.com/2018/08/11/Android_App/SOP_MediaPlayer/</id>
    <published>2018-08-11T03:12:05.000Z</published>
    <updated>2018-11-08T03:35:49.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用控制方法"><a href="#常用控制方法" class="headerlink" title="常用控制方法"></a>常用控制方法</h2><p>Android 通过控制播放器的状态的方式来控制媒体文件的播放，其中：</p><p><code>setDataSource()</code> 设置要播放的音频文件位置<br><code>prepare()和 prepareAsync()</code> 完成准备工作<br>提供了同步和异步两种方式设置播放器进入prepare状态，<br>需要注意的是，如果MediaPlayer实例是由create方法创建的，那么第一次启动播放前不需要再调用prepare（）了，因为create方法里已经调用过了。<br><code>start()</code>是真正启动文件播放的方法，<br><code>pause()</code> 暂停播放<br><code>stop()</code> 停止播放<br><code>seekTo()</code> 是定位方法，可以让播放器从指定的位置开始播放，<br>需要注意的是该方法是个异步方法，也就是说该方法返回时并不意味着定位完成，尤其是播放的网络文件，真正定位完成时会触发OnSeekComplete.onSeekComplete()，如果需要是可以调用 setOnSeekCompleteListener(OnSeekCompleteListener)设置监听器来处理的。<br><code>release()</code> 可以释放播放器占用的资源，一旦确定不再使用播放器时应当尽早调用它释放资源。<br><code>reset()</code> 可以使播放器从 Error 状态中恢复过来，重新会到 Idle 状态。<br><code>isPlaying()</code> 判断当前的 MediaPlayer 是否正在播放音频<br><code>getDuration()</code> 获取载入的音频文件的时长</p><h2 id="使用-SOP"><a href="#使用-SOP" class="headerlink" title="使用 SOP"></a>使用 SOP</h2><h3 id="1-实例化"><a href="#1-实例化" class="headerlink" title="1. 实例化"></a>1. 实例化</h3><p>可以使用直接new的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MediaPlayer mp = new MediaPlayer();</span><br></pre></td></tr></table></figure></p><p>也可以使用create的方式，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MediaPlayer mp = MediaPlayer.create(this, R.raw.test_media_file_rsid);//这时就不用调用setDataSource了</span><br></pre></td></tr></table></figure></p><h3 id="2-设置音频文件路径-setDataSource"><a href="#2-设置音频文件路径-setDataSource" class="headerlink" title="2. 设置音频文件路径 setDataSource"></a>2. 设置音频文件路径 setDataSource</h3><p>MediaPlayer要播放的文件主要包括3个来源：<br>a. 用户在应用中事先自带的resource资源<br>     例如：MediaPlayer.create(this, R.raw.test_media_file_rsid);<br>b. 存储在SD卡或其他文件路径下的媒体文件<br>     例如：mp.setDataSource(“/sdcard/test.mp3”);<br>c. 网络上的媒体文件<br>   例如：mp.setDataSource(“<a href="http://www.xxx.com/test.mp3&quot;)" target="_blank" rel="noopener">http://www.xxx.com/test.mp3&quot;)</a>;</p><p>MediaPlayer的setDataSource一共四个方法：<br>       setDataSource (String path)<br>       setDataSource (FileDescriptor fd)<br>       setDataSource (Context context, Uri uri)<br>       setDataSource (FileDescriptor fd, long offset, long length)</p><h3 id="3-进入准备状态-prepare"><a href="#3-进入准备状态-prepare" class="headerlink" title="3. 进入准备状态 prepare()"></a>3. 进入准备状态 prepare()</h3><h3 id="4-操作"><a href="#4-操作" class="headerlink" title="4. 操作"></a>4. 操作</h3><p>start() / pause() / reset()</p><p>4）设置播放器的监听器：</p><p>   MediaPlayer提供了一些设置不同监听器的方法来更好地对播放器的工作状态进行监听，以期及时处理各种情况，</p><p>如： setOnCompletionListener(MediaPlayer.OnCompletionListener listener)、</p><pre><code>setOnErrorListener(MediaPlayer.OnErrorListener listener)等,设置播放器时需要考虑到播放器可能出现的情况设置好监听和处理逻辑，以保持播放器的健壮性。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用控制方法&quot;&gt;&lt;a href=&quot;#常用控制方法&quot; class=&quot;headerlink&quot; title=&quot;常用控制方法&quot;&gt;&lt;/a&gt;常用控制方法&lt;/h2&gt;&lt;p&gt;Android 通过控制播放器的状态的方式来控制媒体文件的播放，其中：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;setDa
      
    
    </summary>
    
    
      <category term="RockChip" scheme="http://iyounix.com/tags/RockChip/"/>
    
      <category term="Android" scheme="http://iyounix.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>组件_ContentProvider</title>
    <link href="http://iyounix.com/2018/08/11/Android_App/%E7%BB%84%E4%BB%B6_ContentProvider/"/>
    <id>http://iyounix.com/2018/08/11/Android_App/组件_ContentProvider/</id>
    <published>2018-08-11T03:12:05.000Z</published>
    <updated>2018-11-08T03:38:39.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>用法两种:</p><ol><li>使用现有的ContentProvider来读取和操作相应程序中的数据</li><li>创建自己的内容提供器给我们的程序的数据提供外部访问接口</li></ol><h2 id="ContentResolver-使用方法"><a href="#ContentResolver-使用方法" class="headerlink" title="ContentResolver 使用方法"></a>ContentResolver 使用方法</h2><p>ContentResolver resolver = Context.getContentResolver();<br>resolver.insert //增<br>resolver.delete //删<br>resolver.update //改<br>resolver.query  //查</p><p>参数为 内容URI :<br><code>content://com.example.app.provider/table1</code><br>不过得先解析为 URI 对象:<br><code>Uri uri = Uri.parse(&quot;content://com.example.app.provider/table1&quot;)</code></p><p>使用 内容URI 查询 table1 的内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cursor cursor = getContentResolver().query(</span><br><span class="line">uri,</span><br><span class="line">    projection,//指定列名</span><br><span class="line">    selection,//Where约束</span><br><span class="line">    selectionArgs,//Where占位符提供具体的值</span><br><span class="line">    sortOrder//指定查询结果的排序方式</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>通过移动游标位置,遍历 Cursor:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (cursor != null)&#123;</span><br><span class="line">while (cursor.moveToNext()) &#123;</span><br><span class="line">    String column1 = cursor.getString(cursor.getColumnIndex(&quot;column1&quot;));</span><br><span class="line">        int column2 = cursor.getInt(cursor.getColumnIndex(&quot;column2&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    cursor.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="操作实例"><a href="#操作实例" class="headerlink" title="操作实例"></a>操作实例</h2><p>//增<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ContentValues values = new ContentValues();</span><br><span class="line">values.put(&quot;column1&quot;, &quot;text&quot;);</span><br><span class="line">values.put(&quot;column2&quot;, 1);</span><br><span class="line">getContentResolver().insert(uri,values); // 增</span><br></pre></td></tr></table></figure></p><p>//改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ContentValues values = new ContentValues();</span><br><span class="line">values.put(&quot;column1&quot;, &quot;&quot;);</span><br><span class="line">getContentResolver().update(uri. values, &quot;column1 = ? and column2 = ?&quot; , new String[] &#123;&quot;text&quot; , &quot;1&quot;&#125;); //改</span><br></pre></td></tr></table></figure></p><p>//删<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getContentResolver().delete(uri, &quot;column2 = ?&quot;, new String[] &#123;&quot;1&quot;&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;用法两种:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用现有的ContentProvider来读取和操作相应程序中的数据&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="RockChip" scheme="http://iyounix.com/tags/RockChip/"/>
    
      <category term="Android" scheme="http://iyounix.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>SOP_异步消息处理机制</title>
    <link href="http://iyounix.com/2018/08/11/Android_App/SOP_%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://iyounix.com/2018/08/11/Android_App/SOP_异步消息处理机制/</id>
    <published>2018-08-11T03:12:05.000Z</published>
    <updated>2018-11-08T03:34:30.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li><p>Message<br>线程之间传递的载体<br><code>.what</code> <code>.arg1</code> <code>.arg2</code>  字段可以携带整型数据</p></li><li><p>Handler<br>用于发送和处理 Message<br>Handler.sendMessage()<br>Handler.handleMessage()</p></li><li><p>MessageQueue<br>存放所有通过 Handler 发送的消息, 等待被处理<br>每个线程只会有一个 MessageQueue</p></li><li><p>Looper<br>Looper 是每个线程 MessageQueue 的管家.<br>Looper.loop() 后, 会进入循环, 当发现 MessageQueue 中存在消息, 就会取出, 并传递到 Handler.handleMessage 中.<br>每个线程也只会有一个 Looper 对象.</p></li></ol><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li>主线程创建 Handler 对象, 重写 handle Message() 方法</li><li>子线程中要操作 UI 时, 创建 Message 对象, 并通过 Handler 发送 Message 即可</li><li>Message 会被添加到 MessageQueue </li><li>Looper 会一直尝试从 MessageQueue 中取出 Msg, 最后分发到 handleMessage() 中</li></ol><h2 id="AsyncTask-基本概念"><a href="#AsyncTask-基本概念" class="headerlink" title="AsyncTask 基本概念"></a>AsyncTask 基本概念</h2><p>AsyncTask 为抽象类, 需要继承 并 指定三个泛形参数<br>泛形参数:<br>1.<code>Params</code> 在执行 AsyncTask 传入的参数, 用于后台任务中使用<br>2.<code>Progress</code> 后台任务执行时, 如果需要在界面上显示当前进度, 这里的泛形为进度单位<br>3.<code>Result</code> 任务执行完毕后, 对结果进行返回, 这里的泛形为返回类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">// Void 不需要参数给后台</span><br><span class="line">// Integer 用整型作进度单位</span><br><span class="line">// Boolean 作为返回值</span><br></pre></td></tr></table></figure></p><p>重写 4 个方法:</p><ol><li><p>onPreExecute()<br>在后台任务执行前开始调用,<br>完成界面初始化</p></li><li><p>doInBackground(Params…)<br>这里处理所有耗时内容, 将会运行在子线程中.<br>所以不可执行任何 UI 操作, 可以调用 publishProgress 方法进行 UI 更新</p></li><li><p>onProgressUpdate(Progress…)<br>当调用了 publishProgress 后, 调用本方法, 其中携带的参数就是后台任务中传递过来的<br>可以在此进行 UI 更新</p></li><li><p>onPostExecute(Result)<br>后台执行完毕 通过 return 返回时, 此方法被调用.<br><code>Result</code> 作为参数传递到此方法, 一般用其进行 UI 操作.</p></li></ol><h2 id="AsyncTask-实例"><a href="#AsyncTask-实例" class="headerlink" title="AsyncTask 实例"></a>AsyncTask 实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123;</span><br><span class="line"></span><br><span class="line">    protected void onPreExecute() &#123;</span><br><span class="line">    progressDialog.show(); //显示进度对话框</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected Boolean doInBackground(Void... params) &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">        int downloadPercent = doDownload(); //虚构的方法 //有嗯与计算当前下载进度并返回</span><br><span class="line">        publishProgress(downloadPercent);</span><br><span class="line">            if (downloadPercent &gt;= 100) &#123;</span><br><span class="line">            break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected void onProgressUpdate(Integer... values) &#123;</span><br><span class="line">    //更新下载进度</span><br><span class="line">        progressDialog.setMessage(&quot;Downloaded&quot; + values[0] + &quot;%&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected void onPostExecute(Boolean result) &#123;</span><br><span class="line">    progressDialog.dismiss(); // 关闭进度对话框</span><br><span class="line">        // 在这里提示下载结果</span><br><span class="line">        if (result) &#123;</span><br><span class="line">        Toast.makeText(context, &quot;Download succeeded&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        Toast.makeText(context, &quot;Download Failed&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Handler-实例"><a href="#Handler-实例" class="headerlink" title="Handler 实例"></a>Handler 实例</h2><h3 id="子线程"><a href="#子线程" class="headerlink" title="子线程"></a>子线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    public static final int UPDATE_TEXT = 1;</span><br><span class="line"></span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        switch (v.getId()) &#123;</span><br><span class="line">            case R.id.change_text:</span><br><span class="line">                new Thread(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">//                        不能直接在子线程中操作 UI</span><br><span class="line">//                        text.setText(&quot;Nice to meet you&quot;);</span><br><span class="line">                        Message message = new Message();</span><br><span class="line">                        message.what = UPDATE_TEXT;</span><br><span class="line">                        handler.sendMessage(message);</span><br><span class="line">                        Log.d(TAG, &quot;onClick run() handler sendMessage&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private Handler handler = new Handler() &#123; //创建 Handler 对象</span><br><span class="line"></span><br><span class="line">    // 重写父类 handleMessage 方法</span><br><span class="line">    // 接收到子线程发送的 sendMessage 后调用 handleMessage 进行处理</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        Log.d(TAG, &quot;handlerMessage: Got Message&quot;);</span><br><span class="line">        switch(msg.what) &#123;</span><br><span class="line">            case UPDATE_TEXT:</span><br><span class="line">                // 进行 UI 操作</span><br><span class="line">                text.setText(&quot;Nice To Meet You!&quot;);</span><br><span class="line">                Log.d(TAG, &quot;handlerMessage: Got Message: UI Update&quot;);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Message&lt;br&gt;线程之间传递的载体&lt;br&gt;&lt;code&gt;.what&lt;/code&gt; &lt;code&gt;.arg
      
    
    </summary>
    
    
      <category term="RockChip" scheme="http://iyounix.com/tags/RockChip/"/>
    
      <category term="Android" scheme="http://iyounix.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>组件_BroadcastReceiver</title>
    <link href="http://iyounix.com/2018/08/11/Android_App/%E7%BB%84%E4%BB%B6_BroadcastReceiver/"/>
    <id>http://iyounix.com/2018/08/11/Android_App/组件_BroadcastReceiver/</id>
    <published>2018-08-11T03:12:05.000Z</published>
    <updated>2018-11-08T03:33:23.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h1><h2 id="MainActivity-java"><a href="#MainActivity-java" class="headerlink" title="MainActivity.java"></a>MainActivity.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> IntentFilter intentFilter;</span><br><span class="line">    <span class="keyword">private</span> NetworkChangeReceiver networkChangeReceiver; <span class="comment">// 内部类</span></span><br><span class="line">    </span><br><span class="line">    onCreate &#123;</span><br><span class="line">        intentFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">        <span class="comment">// 添加 Action</span></span><br><span class="line">        intentFilter.addAction(<span class="string">"android.net.conn.CONNECTIVITY_CHANGE"</span>); </span><br><span class="line"></span><br><span class="line">        networkChangeReceiver = <span class="keyword">new</span> NetworkChangeReceiver(); <span class="comment">// 内部类实例</span></span><br><span class="line">        registerReceiver(networkChangeReceiver, intentFilter);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NetworkChangeReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获得系统服务类</span></span><br><span class="line">            ConnectivityManager connectivityManager = (ConnectivityManager)</span><br><span class="line">                    getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">            NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 具体的使用场景</span></span><br><span class="line">            <span class="keyword">if</span> (networkInfo != <span class="keyword">null</span> &amp;&amp; networkInfo.isAvailable()) &#123;</span><br><span class="line">                Toast.makeText(context, <span class="string">"network is available"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Toast.makeText(context, <span class="string">"network is unavailable"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        Log.d(TAG, <span class="string">"onDestroy"</span>);</span><br><span class="line">        unregisterReceiver(networkChangeReceiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h2><p>添加权限<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>接受开机广播<br>右击 包名 -&gt; New -&gt; Other -&gt; BroadcastReceiver<br>enabled = true 表示是否启用该 BoardcastReceiver<br>exported = ture 表示允许接受本程序以外的 Boardcast</p><h2 id="BootCompleteReceiver-java"><a href="#BootCompleteReceiver-java" class="headerlink" title="BootCompleteReceiver.java"></a>BootCompleteReceiver.java</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class BootCompleteReceiver extends BroadcastReceiver &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        // TODO: This method is called when the BroadcastReceiver is receiving</span><br><span class="line">        // an Intent broadcast.</span><br><span class="line">//        throw new UnsupportedOperationException(&quot;Not yet implemented&quot;);</span><br><span class="line">        Toast.makeText(context, &quot;Boot Complete&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AndroidManifest-xml-1"><a href="#AndroidManifest-xml-1" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;application</span><br><span class="line">    &lt;receiver</span><br><span class="line">        android:name=&quot;.BootCompleteReceiver&quot;</span><br><span class="line">        android:enabled=&quot;true&quot;</span><br><span class="line">        android:exported=&quot;true&quot;&gt;</span><br><span class="line">        &lt;intent-filter&gt;</span><br><span class="line">            &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">    &lt;/receiver&gt;</span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure><h1 id="自定义标准广播"><a href="#自定义标准广播" class="headerlink" title="自定义标准广播"></a>自定义标准广播</h1><h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><p>点击 Mainactivity 的 Button ,发送广播<br>然后 App 接收到并弹出 Toast</p><h2 id="Mainactivity-java"><a href="#Mainactivity-java" class="headerlink" title="Mainactivity.java"></a>Mainactivity.java</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Example 3 MY_BROADCAST</span><br><span class="line">Button button = findViewById(R.id.button);</span><br><span class="line">button.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        Intent intent = new Intent(&quot;com.iyounix.android.a010broadcasts.MY_BROADCAST&quot;);</span><br><span class="line">        sendBroadcast(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="MyBroadcastReceiver-java"><a href="#MyBroadcastReceiver-java" class="headerlink" title="MyBroadcastReceiver.java"></a>MyBroadcastReceiver.java</h2><p>public class MyBroadcastReceiver extends BroadcastReceiver {</p><pre><code>@Overridepublic void onReceive(Context context, Intent intent) {    Toast.makeText(context, &quot;received in Younix BoardcastReceiver&quot;,Toast.LENGTH_SHORT).show();}</code></pre><p>}</p><h2 id="AndroidManifest-xml-2"><a href="#AndroidManifest-xml-2" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot;</span><br><span class="line">    android:enabled=&quot;true&quot;</span><br><span class="line">    android:exported=&quot;true&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;com.iyounix.android.a010broadcasts.MY_BROADCAST&quot;/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;动态注册&quot;&gt;&lt;a href=&quot;#动态注册&quot; class=&quot;headerlink&quot; title=&quot;动态注册&quot;&gt;&lt;/a&gt;动态注册&lt;/h1&gt;&lt;h2 id=&quot;MainActivity-java&quot;&gt;&lt;a href=&quot;#MainActivity-java&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="RockChip" scheme="http://iyounix.com/tags/RockChip/"/>
    
      <category term="Android" scheme="http://iyounix.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>数据持久化_数据库_LitePal 和 SQLite</title>
    <link href="http://iyounix.com/2018/08/11/Android_App/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96_%E6%95%B0%E6%8D%AE%E5%BA%93_LitePal%20%E5%92%8C%20SQLite/"/>
    <id>http://iyounix.com/2018/08/11/Android_App/数据持久化_数据库_LitePal 和 SQLite/</id>
    <published>2018-08-11T03:12:05.000Z</published>
    <updated>2018-11-08T03:38:29.514Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LitePal-基本概念"><a href="#LitePal-基本概念" class="headerlink" title="LitePal 基本概念"></a>LitePal 基本概念</h2><p>LitePal 是开源的 Android 数据库框架, 采用了 对象关系映射 ORM 模式 .<br>封装了常用数据库功能</p><blockquote><p>ORM(对象关系映射) 指的是 面向对象语言 和 关系型数据库 之间建立一种映射关系.</p></blockquote><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">compile &apos;org.litepal.android:core:2.0.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:name=&quot;org.litepal.LitePalApplication&quot;</span><br></pre></td></tr></table></figure><h3 id="litepal-xml"><a href="#litepal-xml" class="headerlink" title="litepal.xml"></a>litepal.xml</h3><litepal><br>  <dbname value="BookStore"></dbname><br>  <version value="1"></version><br>  <list><br>    <mapping class="com.example.litepaltest.Book"></mapping><br>  </list><br></litepal><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connector.getDatabase()</span><br></pre></td></tr></table></figure><h2 id="SQLite-简介"><a href="#SQLite-简介" class="headerlink" title="SQLite 简介"></a>SQLite 简介</h2><p>SQLiteOpenHelper 抽象类<br>{<br>  onCreate()<br>  onUpgrade()</p><p>  getReadableDatabase() //以只读的方式打开db<br>  getWritableDatabase() //以可读写的方式打开db,如果db只读,则返回异常</p><p>  SQLiteOpenHelper() //构造方法<br>  // 参数1 Context 参数2 数据库名 参数3 查询数据的时候返回自定义的cursor(null) 参数4 当前数据库的版本号<br>}</p><p>文件保存在 <code>/data/data/&lt;package name&gt;/databases/</code> 目录下</p><h2 id="SQL-基本操作"><a href="#SQL-基本操作" class="headerlink" title="SQL 基本操作"></a>SQL 基本操作</h2><h3 id="建表-Create"><a href="#建表-Create" class="headerlink" title="建表 Create"></a>建表 Create</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table Book (</span><br><span class="line">id integer primary key autoincrement, // primary key 将 id 设置为主键 // autoincrement 自增长</span><br><span class="line">    author text, // 文本类型</span><br><span class="line">    price real, // 浮点型</span><br><span class="line">    pages integer, // 整型</span><br><span class="line">    name text)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class MyDatabaseHelper extends SQLiteOpenHelper &#123;</span><br><span class="line"></span><br><span class="line">    public static final String CREATE_BOOK = &quot;create table Book (&quot;</span><br><span class="line">            +&quot;id integer primary key autoincrement,&quot;</span><br><span class="line">            +&quot;author text,&quot;</span><br><span class="line">            +&quot;price real,&quot;</span><br><span class="line">            +&quot;pages integer,&quot;</span><br><span class="line">            +&quot;name text)&quot;;</span><br><span class="line"></span><br><span class="line">    private Context mContext;</span><br><span class="line"></span><br><span class="line">    public MyDatabaseHelper(Context context, String name,</span><br><span class="line">                            SQLiteDatabase.CursorFactory factory,</span><br><span class="line">                            int version) &#123;</span><br><span class="line">        super(context, name, factory, version);</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(SQLiteDatabase db) &#123;</span><br><span class="line">        db.execSQL(CREATE_BOOK);</span><br><span class="line">        Toast.makeText(mContext, &quot;Create succeeded&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化抽象类 MyDatabaseHelper<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private MyDatabaseHelper dbHelper;</span><br><span class="line">dbHelper = new MyDatabaseHelper(this, &quot;BookStore.db&quot;,</span><br><span class="line">                null, 1);</span><br><span class="line">        Button createDatabase = findViewById(R.id.create_database);</span><br><span class="line">        createDatabase.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                dbHelper.getWritableDatabase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p><h3 id="删表-Drop"><a href="#删表-Drop" class="headerlink" title="删表 Drop"></a>删表 Drop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.execSQL(&quot;drop table if exists Book&quot;);</span><br><span class="line">db.execSQL(&quot;drop table if exists Category&quot;);</span><br></pre></td></tr></table></figure><h3 id="升级-Update"><a href="#升级-Update" class="headerlink" title="升级 Update"></a>升级 Update</h3><p>第四个参数, 比之前大.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dbHelper = new MyDatabaseHelper(this, &quot;BookStore.db&quot;,</span><br><span class="line">                null, 2);</span><br></pre></td></tr></table></figure></p><h3 id="查表"><a href="#查表" class="headerlink" title="查表"></a>查表</h3><p>.table  //查表<br>.schema //查看建表语句<br>.exit .quit //退出</p><h2 id="数据库操作-CRUD"><a href="#数据库操作-CRUD" class="headerlink" title="数据库操作 CRUD"></a>数据库操作 CRUD</h2><h3 id="添加数据-insert"><a href="#添加数据-insert" class="headerlink" title="添加数据 insert()"></a>添加数据 insert()</h3><p>insert()<br>参数1 表名<br>参数2 未指定添加数据的情况下,给可为空的列自动赋值NULL. 不用就填null<br>参数3 ContentValues 对象, 提供了 put()方法的重载, 用于添加数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class="line"> ContentValues values = new ContentValues();</span><br><span class="line"> // 开始组装第一条数据</span><br><span class="line"> values.put(&quot;name&quot;, &quot;The Da Vinci Code&quot;);</span><br><span class="line"> values.put(&quot;author&quot;, &quot;Dan Brown&quot;);</span><br><span class="line"> values.put(&quot;pages&quot;, 454);</span><br><span class="line"> values.put(&quot;price&quot;, 16.94);</span><br><span class="line"> // 插入第一条数据</span><br><span class="line"> db.insert(&quot;Book&quot;, null, values);</span><br><span class="line"> values.clear();</span><br></pre></td></tr></table></figure></p><h3 id="修改数据-update"><a href="#修改数据-update" class="headerlink" title="修改数据 update()"></a>修改数据 update()</h3><p>update()<br>参数1 表名<br>参数2 ContentValues 对象, 提供了 put()方法的重载, 用于添加数据<br>参数3 4 约束更新某一行或几行 , 默认是更新全部 ; 参数3 对应 where 语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class="line">ContentValues values = new ContentValues();</span><br><span class="line">values.put(&quot;price&quot;, 10.99);</span><br><span class="line">db.update(&quot;Book&quot;, values,</span><br><span class="line">        &quot;name = ?&quot;, new String[] &#123;&quot;The Da Vinci Code&quot;&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="删除数据-deleted"><a href="#删除数据-deleted" class="headerlink" title="删除数据 deleted()"></a>删除数据 deleted()</h3><p>delete()<br>参数 1 表名<br>参数 2 3 whereClause 查询语句 , 比如 pages &gt; ? , new Sting[] {“500”}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class="line">db.delete(&quot;Book&quot;, &quot;pages &gt; ?&quot;,</span><br><span class="line">        new String[] &#123;&quot;500&quot;&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="查询数据-query"><a href="#查询数据-query" class="headerlink" title="查询数据 query()"></a>查询数据 query()</h3><p>query()<br>参数 1 table 表名 , from table_name<br>参数 2 columns 查询哪几列 , select column1,column2<br>参数 3 selection 4 selectionArgs 约束条件  where column = value<br>参数 5 groupBy 的列 , group by column<br>参数 6 having , group by 的约束 , having column = value<br>参数 7 orderBy , 指定查询的排列方式 , order by column1 column2<br>返回 Cursor 对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SQLiteDatabase db = dbHelper.getWritableDatabase();</span><br><span class="line">Cursor cursor = db.query(&quot;Book&quot;, null,null,null,null,null,null);</span><br><span class="line">if(cursor.moveToFirst())&#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        //遍历 Cursor 对象, 取出数据并打印</span><br><span class="line">        String name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;));</span><br><span class="line">        String author = cursor.getString(cursor.getColumnIndex(&quot;author&quot;));</span><br><span class="line">        int pages = cursor.getInt(cursor.getColumnIndex(&quot;pages&quot;));</span><br><span class="line">        double price = cursor.getDouble(cursor.getColumnIndex(&quot;price&quot;));</span><br><span class="line">        Log.d(TAG,&quot;book name is &quot; + name);</span><br><span class="line">        Log.d(TAG,&quot;book author is &quot; + author);</span><br><span class="line">        Log.d(TAG,&quot;book pages is &quot; + pages);</span><br><span class="line">        Log.d(TAG,&quot;book price is &quot; + price);</span><br><span class="line">    &#125; while(cursor.moveToNext());</span><br><span class="line">&#125;</span><br><span class="line">cursor.close();</span><br></pre></td></tr></table></figure></p><h3 id="直接使用-SQL-操作数据"><a href="#直接使用-SQL-操作数据" class="headerlink" title="直接使用 SQL 操作数据"></a>直接使用 SQL 操作数据</h3><p>execSQL 和 rawQuery</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 增</span><br><span class="line">db.execSQL(&quot;insert into Book (name, author, pages, price) values(?, ?, ?, ?)&quot;, </span><br><span class="line">new String[] &#123;&quot;The Da Vinci Code&quot;, &quot;Dan Brown&quot;, &quot;454&quot;, &quot;16.96&quot;&#125;);</span><br><span class="line"># 删</span><br><span class="line">db.execSQL(&quot;delete from Book where pages &gt; ?&quot;, new String[] &#123;&quot;500&quot;&#125;);</span><br><span class="line"># 改</span><br><span class="line">db.execSQL(&quot;update Book set price = ? where name = ?&quot;, new String[] &#123;&quot;10.99&quot;, &quot;The Da Vinci Code&quot;&#125;);</span><br><span class="line"># 查</span><br><span class="line">db.rawQuery(&quot;select * from Book&quot; , null);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;LitePal-基本概念&quot;&gt;&lt;a href=&quot;#LitePal-基本概念&quot; class=&quot;headerlink&quot; title=&quot;LitePal 基本概念&quot;&gt;&lt;/a&gt;LitePal 基本概念&lt;/h2&gt;&lt;p&gt;LitePal 是开源的 Android 数据库框架, 采用
      
    
    </summary>
    
    
      <category term="RockChip" scheme="http://iyounix.com/tags/RockChip/"/>
    
      <category term="Android" scheme="http://iyounix.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>SOP_WebView</title>
    <link href="http://iyounix.com/2018/08/11/Android_App/SOP_WebView/"/>
    <id>http://iyounix.com/2018/08/11/Android_App/SOP_WebView/</id>
    <published>2018-08-11T03:12:05.000Z</published>
    <updated>2018-11-08T03:38:15.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WebView-使用-SOP"><a href="#WebView-使用-SOP" class="headerlink" title="WebView 使用 SOP"></a>WebView 使用 SOP</h2><h3 id="activity-xml"><a href="#activity-xml" class="headerlink" title="activity.xml"></a>activity.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">WebView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/web_view"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span><span class="tag">&lt;/<span class="name">WebView</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="MainActivity-java"><a href="#MainActivity-java" class="headerlink" title="MainActivity.java"></a>MainActivity.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WebView mWebView = findViewById(R.id.web_view);</span><br><span class="line"><span class="comment">// 支持 JS 脚本</span></span><br><span class="line">mWebView.getSettings().setJavaScriptEnabled(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 当跳转网页的时候, 我们希望还是在当前 WebView 中,而不是访问浏览器</span></span><br><span class="line">mWebView.setWebViewClient(<span class="keyword">new</span> WebViewClient());</span><br><span class="line"><span class="comment">// 默认展现的网页</span></span><br><span class="line">mWebView.loadUrl(<span class="string">"http://www.baidu.com"</span>);</span><br></pre></td></tr></table></figure><h3 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="特殊注意事项"><a href="#特殊注意事项" class="headerlink" title="特殊注意事项"></a>特殊注意事项</h2><h3 id="子线程中完成服务器结束响应后的回调"><a href="#子线程中完成服务器结束响应后的回调" class="headerlink" title="子线程中完成服务器结束响应后的回调"></a>子线程中完成服务器结束响应后的回调</h3><p>在获取到服务器响应数据后, 可以对其进行解析和处理.<br>但是网络请求是耗时操作, 需要放在子线程中进行.</p><h2 id="WebView-Http-基本介绍"><a href="#WebView-Http-基本介绍" class="headerlink" title="WebView_Http 基本介绍"></a>WebView_Http 基本介绍</h2><p>Client 向 Server 发一条请求 ,<br>Server 收到后返回一些数据给 Client ,<br>Client 对数据进行解析和处理</p><h2 id="HttpURLConnection-SOP"><a href="#HttpURLConnection-SOP" class="headerlink" title="HttpURLConnection SOP"></a>HttpURLConnection SOP</h2><ol><li><p>实例化对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL url = new URL(&quot;http://www.iyounix.com&quot;);</span><br><span class="line">HttpURLConnection connection = (HttpURLConnection) url.openConnection();</span><br></pre></td></tr></table></figure></li><li><p>设置 Http 请求所使用的方法<br>GET 希望从服务器获取数据<br>POST 希望提交数据给服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">connection.setRequestMethod(&quot;GET&quot;);</span><br><span class="line">connection.setRequestMethod(&quot;POST&quot;);</span><br><span class="line">// 设置连接超时</span><br><span class="line">connection.setConnectTimeout(8000);</span><br><span class="line">// 设置读取超时</span><br><span class="line">connection.setReadTimeout(8000);</span><br></pre></td></tr></table></figure></li><li><p>获取服务器返回的输入流 getInputStream()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = connection.getInputStream();</span><br></pre></td></tr></table></figure></li></ol><p>获取到的输入流可以拿来 进行 各种骚操作.</p><p>example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = connection.getInputStream();</span><br><span class="line">   reader = new BufferedReader(new InputStreamReader(in));</span><br><span class="line">   StringBuilder response = new StringBuilder();</span><br><span class="line">   String line; //读到读完为止</span><br><span class="line">   while ((line = reader.readLine()) != null) &#123;</span><br><span class="line">       response.append(line);</span><br><span class="line">   &#125;</span><br><span class="line">   // Android 的子线程中是无法进行 UI 界面的刷新的</span><br><span class="line">   // 通过调用 runOnUiThread 回到主线程进行 UI 的刷新</span><br><span class="line">   showResponse(response.toString());</span><br></pre></td></tr></table></figure></p><ol start="4"><li><p>提交数据给服务器 getOutputStream()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connection.setRequestMethod(&quot;POST&quot;);</span><br><span class="line">   DataOutputStream out = new DataOutputStream(connection.getOutputStream());</span><br><span class="line">   out.writeBytes(&quot;username=admin &amp; password=123456&quot;);</span><br></pre></td></tr></table></figure></li><li><p>关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.disconnect();</span><br></pre></td></tr></table></figure></li></ol><h2 id="WebView-OKHttp-基本介绍"><a href="#WebView-OKHttp-基本介绍" class="headerlink" title="WebView_OKHttp 基本介绍"></a>WebView_OKHttp 基本介绍</h2><p>Square 公司开发.<br><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">https://github.com/square/okhttp</a></p><h2 id="OKHttp-SOP"><a href="#OKHttp-SOP" class="headerlink" title="OKHttp SOP"></a>OKHttp SOP</h2><h3 id="build-gradle"><a href="#build-gradle" class="headerlink" title="build.gradle"></a>build.gradle</h3><p>添加依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">implementation &apos;com.squareup.okhttp3:okhttp:3.4.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="MainActivity-java-1"><a href="#MainActivity-java-1" class="headerlink" title="MainActivity.java"></a>MainActivity.java</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 1. 创建 OkHttpClient 实例 </span><br><span class="line">OKHttpClient client = new OkHttpClient();</span><br><span class="line"></span><br><span class="line">// 2. 创建 Request 对象用来发送请求</span><br><span class="line">Request request = new Request.Builder().build();    </span><br><span class="line">    // 可以通过连缀其他方法丰富 Request 对象</span><br><span class="line">    Request request = new Request.Builder()</span><br><span class="line">    .url(&quot;http://www.iyounix.com&quot;)</span><br><span class="line">                        .build();</span><br><span class="line">                        </span><br><span class="line">// 3.1 获取服务器返回的数据 GET</span><br><span class="line">Response response = client.newCall(request).execute();</span><br><span class="line">// 如下获取返回的具体的内容</span><br><span class="line">    String reponseData = response.body().string();</span><br><span class="line"></span><br><span class="line">// 3.2 向服务器发送请求  POST</span><br><span class="line">// 构建 RequestBody 对象存放待提交的参数</span><br><span class="line">RequestBody requestBody = new FormBody.Builder()</span><br><span class="line">    .add(&quot;username&quot;,  &quot;admin&quot;)</span><br><span class="line">                                .add(&quot;password&quot;,  &quot;123456&quot;)</span><br><span class="line">                                .build();</span><br><span class="line">// post()</span><br><span class="line">    Request request = new Request.Builder()</span><br><span class="line">    .url(&quot;http://www.iyounix.com&quot;)</span><br><span class="line">                            .post(requestBody)</span><br><span class="line">                            .build();</span><br><span class="line"></span><br><span class="line">    // execute() 请求并获取返回的数据</span><br><span class="line">Response response = client.newCall(request).execute();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;WebView-使用-SOP&quot;&gt;&lt;a href=&quot;#WebView-使用-SOP&quot; class=&quot;headerlink&quot; title=&quot;WebView 使用 SOP&quot;&gt;&lt;/a&gt;WebView 使用 SOP&lt;/h2&gt;&lt;h3 id=&quot;activity-xml&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="RockChip" scheme="http://iyounix.com/tags/RockChip/"/>
    
      <category term="Android" scheme="http://iyounix.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>数据持久化_文件存储</title>
    <link href="http://iyounix.com/2018/08/11/Android_App/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96_%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/"/>
    <id>http://iyounix.com/2018/08/11/Android_App/数据持久化_文件存储/</id>
    <published>2018-08-11T03:12:05.000Z</published>
    <updated>2018-11-08T03:33:42.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写"><a href="#写" class="headerlink" title="写"></a>写</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件名 为 data</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputText</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(String inputText)</span> </span>&#123;</span><br><span class="line">    FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">    BufferedWriter writer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        out = openFileOutput(<span class="string">"data"</span>, Context.MODE_PRIVATE);</span><br><span class="line">        writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(out));</span><br><span class="line">        writer.write(inputText);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (writer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读"><a href="#读" class="headerlink" title="读"></a>读</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FileInputStream in = <span class="keyword">null</span>;</span><br><span class="line">    BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">    StringBuilder content = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// openFileInput 获取 FileInputStream 对象</span></span><br><span class="line">        in = openFileInput(<span class="string">"data"</span>);</span><br><span class="line">        <span class="comment">// 构建 BufferedReader 对象</span></span><br><span class="line">        reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line">        String line = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// 一行行的读, 读到的内容存在 StringBuilder 中</span></span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            content.append(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> content.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写&quot;&gt;&lt;a href=&quot;#写&quot; class=&quot;headerlink&quot; title=&quot;写&quot;&gt;&lt;/a&gt;写&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="RockChip" scheme="http://iyounix.com/tags/RockChip/"/>
    
      <category term="Android" scheme="http://iyounix.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>数据持久化_SharedPreferences</title>
    <link href="http://iyounix.com/2018/08/11/Android_App/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96_SharedPreferences/"/>
    <id>http://iyounix.com/2018/08/11/Android_App/数据持久化_SharedPreferences/</id>
    <published>2018-08-11T03:12:05.000Z</published>
    <updated>2018-11-08T03:34:05.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>通过键值对的方式进行存储. 保存为 xml 文件<br>value - key</p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><ol><li>获取 SharedPreferences 对象<br> SharedPreferences.Editor editor = getSharedPreferences(“data”, MODE_PRIVATE).edit();</li><li>editor.putString(“name”, “Tom”);</li><li>editor.apply();<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 通过 getSharedPreferences() 方法指定 SharedPreferences 文件名为 data</span><br><span class="line">SharedPreferences.Editor editor = getSharedPreferences(&quot;data&quot;, MODE_PRIVATE).edit();</span><br><span class="line">editor.putString(&quot;name&quot;, &quot;Tom&quot;);</span><br><span class="line">editor.putInt(&quot;age&quot;, 28);</span><br><span class="line">editor.putBoolean(&quot;married&quot;,false);</span><br><span class="line">editor.apply();</span><br></pre></td></tr></table></figure></li></ol><h3 id="获取-SharedPreferences-对象的三种方法"><a href="#获取-SharedPreferences-对象的三种方法" class="headerlink" title="获取 SharedPreferences 对象的三种方法"></a>获取 SharedPreferences 对象的三种方法</h3><ol><li>Context 类的 getSharedPreferences():  getSharedPreferences(“data”, MODE_PRIVATE);</li><li>Activity 类的 getPreferences():  getPreferences(MODE_PRIVATE);</li><li>PreferenceManager 类的 getDefaultSharedPreferences(): PreferenceManager.getDefaultSharedPreferences(Context);</li></ol><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences pref = getSharedPreferences(&quot;data&quot;, MODE_PRIVATE);</span><br><span class="line">//SharedPreferences pref2 = getPreferences(MODE_PRIVATE);</span><br><span class="line">//SharedPreferences pref3 = new PreferenceManager.getDefaultSharedPreferences(Context);</span><br><span class="line">String name = pref.getString(&quot;name&quot;, &quot;NOBODY&quot;);</span><br><span class="line">int age = pref.getInt(&quot;age&quot;,0);</span><br><span class="line">boolean married = pref.getBoolean(&quot;married&quot;, false);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;通过键值对的方式进行存储. 保存为 xml 文件&lt;br&gt;value - key&lt;/p&gt;
&lt;h2 id=&quot;存储&quot;&gt;&lt;a href=&quot;#存储&quot; 
      
    
    </summary>
    
    
      <category term="RockChip" scheme="http://iyounix.com/tags/RockChip/"/>
    
      <category term="Android" scheme="http://iyounix.com/tags/Android/"/>
    
  </entry>
  
</feed>
